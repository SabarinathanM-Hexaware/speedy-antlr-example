
// Generated from NaturalParser.g4 by ANTLR 4.13.1


#include "NaturalParserVisitor.h"

#include "NaturalParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct NaturalParserStaticData final {
  NaturalParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NaturalParserStaticData(const NaturalParserStaticData&) = delete;
  NaturalParserStaticData(NaturalParserStaticData&&) = delete;
  NaturalParserStaticData& operator=(const NaturalParserStaticData&) = delete;
  NaturalParserStaticData& operator=(NaturalParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag naturalparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
NaturalParserStaticData *naturalparserParserStaticData = nullptr;

void naturalparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (naturalparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(naturalparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<NaturalParserStaticData>(
    std::vector<std::string>{
      "program", "lineNumberStatement", "statement", "label", "dataDefinition", 
      "compressStatement", "compressEnd", "inputStatement", "inputOptions", 
      "inputUsingMap", "variable", "reinputStatement", "reinputOptions", 
      "sortStatement", "examineStatement", "examineOptions", "moveStatement", 
      "moveOptions", "repeatStatement", "doStatement", "storeStatement", 
      "storePreview2", "storeCondition", "findStatement", "findQuery", "findNumber", 
      "findPreview1", "findPreview2", "readStatement", "readQuery", "readPreview1", 
      "readPreview2", "updateStatement", "updateStartline", "deleteStatement", 
      "getStatements", "getTabledStatements", "getTabledOptions", "getTransactionStatement", 
      "getSameStatement", "histogramStatement", "histogramQuery", "histogramPreview", 
      "histogramOptions", "endTransaction", "backoutTransaction", "readworkfileStatement", 
      "workfilenumberOption", "readworkfileOptions", "atEndOfFileStatement", 
      "writeworkfileStatement", "closeworkfileStatement", "noRecordsFoundStatement", 
      "atStartOfDataStatement", "formatStatement", "formatOptions", "assignmentStatement", 
      "includeStatement", "redefineStatement", "redefineBody", "resetStatement", 
      "callnatStatement", "setkeyStatement", "performStatement", "subroutineNames", 
      "fetchStatement", "callStatement", "forStatement", "acceptRejectIfStatement", 
      "decisionStatement", "ifStatement", "ifStructuredStatement", "elseStructured", 
      "ifElseStatement", "ifMultilinedStatement", "ifSinglelinedStatement", 
      "elseMultilinedStatement", "elseSinglelinedStatement", "onelinerBody", 
      "condition", "optionalCondition", "operand", "naturalKeywords", "logicalOp", 
      "subroutine", "blockContentSubroutine", "subroutineStatement", "functionDefinition", 
      "blockContent", "valueAssignment", "assignStatement", "addOperation", 
      "multiplyOperation", "subtractOperation", "divideOperation", "computeOperation", 
      "arithmaticOperation", "optionalCompute", "calculations", "addContent", 
      "compOp", "arithmaticOp", "endStatement", "otherStatement"
    },
    std::vector<std::string>{
      "", "'DEFINE'", "'FUNCTION'", "'RETURNS'", "'DATA'", "'LOCAL'", "'GLOBAL'", 
      "'PARAMETER'", "'REDEFINE'", "'PERFORM'", "'CALLNAT'", "'ESCAPE'", 
      "'ESCAPE BOTTOM'", "'RETURN'", "'IF'", "'THEN'", "'ELSE'", "'ELSE IF'", 
      "'END-IF'", "'DECIDE'", "'END-DECIDE'", "'WHEN'", "'FOR'", "'THRU'", 
      "'EVERY'", "'FIRST'", "'CONDITION'", "'ANY'", "'NONE'", "'ALL'", "'UNIQUE'", 
      "'REPEAT'", "", "'END-FOR'", "'END'", "'READ'", "", "'SELECT'", "", 
      "'STORE'", "", "'GET'", "'OBTAIN'", "'ADD'", "'SUBTRACT'", "'MULTIPLY'", 
      "'DIVIDE'", "'MOVE'", "'VALUE OF'", "'TO'", "'DO'", "'DEFINE SUBROUTINE'", 
      "'END-SUBROUTINE'", "'DEFINE SUBPROGRAM'", "'END-SUBPROGRAM'", "'DEFINE FUNCTION'", 
      "'END-FUNCTION'", "'END-READ'", "'END-FIND'", "'END-SELECT'", "'END TRANSACTION'", 
      "'BACKOUT TRANSACTION'", "'END-ALL'", "'VALUE'", "'DOEND'", "'USING HELP'", 
      "'USING'", "'COMPUTE'", "'INPUT'", "'MAP'", "'RESET'", "'SET KEY'", 
      "'COMPRESS'", "'NO RECORDS FOUND'", "'NO RECORD FOUND'", "'END-NOREC'", 
      "'REINPUT'", "'MARK'", "'WITH TEXT'", "'FULL'", "'POSITION'", "'IN'", 
      "'ALARM'", "'RECORD'", "'RECORDS'", "'STATEMENT'", "'SET'", "'SAME'", 
      "'GET TRANSACTION DATA'", "'GET SAME'", "'WITH'", "'ACCEPT IF'", "'REJECT IF'", 
      "'EXAMINE'", "'SUBSTRING'", "'REPLACE'", "'GIVING'", "'ABSOLUTE'", 
      "'CHARPOSITION'", "'CHARLENGTH'", "'LENGTH'", "'NUMBER'", "'TRANSLATE'", 
      "'DELIMITER'", "'UPPPER CASE'", "'LOWER CASE'", "'INTO'", "'INVERTED'", 
      "'INDEX'", "'INDEXED'", "'PATTERN'", "'DISPLAY'", "'WRITE'", "'WRITE TITLE'", 
      "'WRITE TRAILER'", "'FIELD'", "'BY NAME'", "'BY POSITION'", "'EDITED'", 
      "'LEFT'", "'RIGHT'", "'JUSTIFIED'", "'NORMALIZED'", "'ENCODED'", "'ROUNDED'", 
      "'SEPARATE'", "'SORT'", "'END-SORT'", "'FORMAT'", "'SKIP'", "'EJECT'", 
      "'NEWPAGE'", "'SUSPEND IDENTICAL SUPPRESS'", "'DEFINE PRINTER'", "'CLOSE PRINTER'", 
      "'DEFINE WINDOW'", "'SET WINDOW'", "'PROCESS PAGE'", "'PROCESS PAGE USING'", 
      "'PROCESS PAGE UPDATE'", "'PROCESS PAGE MODAL'", "'IF SELECTION'", 
      "'DECIDE FOR'", "'DECIDE ON'", "'CALL'", "'CALL FILE'", "'CALL LOOP'", 
      "'FETCH'", "'PROCESS COMMAND'", "'RUN'", "'DEFINE PROTOTYPE'", "'Function Call'", 
      "'STOP'", "'TERMINATE'", "'WRITE WORK FILE'", "'WRITE WORK'", "'DOWNLOAD PC FILE'", 
      "'READ WORK FILE'", "'READ WORK'", "'UPLOAD PC FILE'", "'CLOSE WORK FILE'", 
      "'CLOSE WORK'", "'CLOSE PC FILE'", "'DEFINE WORK FILE'", "'DEFINE CLASS'", 
      "'CREATE OBJECT'", "'SEND METHOD'", "'INTERFACE'", "'METHOD'", "'PROPERTY'", 
      "'EXPAND'", "'REDUCE'", "'RESIZE'", "'OPEN CONVERSATION'", "'CLOSE CONVERSATION'", 
      "'DEFINE DATA CONTEXT'", "'PARSE'", "'REQUEST DOCUMENT'", "'RETRY'", 
      "'AT START OF DATA'", "'AT END OF DATA'", "'AT BREAK'", "'BEFORE BREAK PROCESSING'", 
      "'PERFORM BREAK PROCESSING'", "'CALLDBPROC'", "'COMMIT'", "'PROCESS SQL'", 
      "'READ RESULT SET'", "'ROLLBACK'", "'WRITE / PRINT'", "'AT TOP OF PAGE'", 
      "'AT END OF PAGE'", "'DEFINE DATA'", "'END-DEFINE'", "'INCLUDE'", 
      "'ON ERROR'", "'RELEASE'", "'SET CONTROL'", "'SET GLOBALS'", "'SET TIME'", 
      "'STACK'", "'ACCEPT'", "'REJECT'", "'PASSW'", "'LIMIT'", "'INSERT'", 
      "", "'END-HISTOGRAM'", "'THEN_DO'", "'IGNORE'", "'FRAC'", "'FROM'", 
      "'VIEW'", "'ASSIGN'", "'NUMERIC'", "'LEAVING SPACE'", "", "'END-START'", 
      "'ON'", "'OFF'", "'BY'", "'INTERFACE4'", "'RETAIN AS'", "'WHERE'", 
      "'STARTING WITH'", "'COUPLED'", "'VIA'", "'BUT'", "'SORTED'", "'ASCENDING'", 
      "'DESCENDING'", "'OF'", "'MULTI-FETCH'", "'STARTING FROM'", "'ENDING AT'", 
      "'VARIABLE'", "'DYNAMIC'", "'SEQUENCE'", "'END-WORK'", "'OFFSET'", 
      "'FILLER'", "'ONCE'", "'AT END OF FILE'", "'END-ENDFILE'", "'PASSWORD'", 
      "'CIPHER'", "'FILE'", "'REPOSITION'", "'PHYSICAL'", "'STARTING'", 
      "'ENDING'", "'AT'", "'AS'", "'GT'", "'LT'", "'GE'", "'LE'", "'EQ'", 
      "'NE'", "'AND'", "'OR'", "'NOT'", "'AND='", "'OR='", "'OR ='", "'EQUAL'", 
      "'NOTEQUAL'", "'EQUAL TO'", "'LESS THAN'", "'GREATER THAN'", "'LESS EQUAL'", 
      "'GREATER EQUAL'", "", "':'", "", "", "", "", "", "", "", "'+'", "'-'", 
      "'*'", "'/'", "'='", "'>'", "'<'", "'>='", "'<='", "'!='", "'('", 
      "')'", "", "", "", "", "", "", "','", "'%'", "'&'", "'|'", "'^'", 
      "'!'", "'~'", "'\\u003F'", "'.'", "'['", "']'", "'{'", "'}'", "'DUMMY_TEXT'"
    },
    std::vector<std::string>{
      "", "DEFINE", "FUNCTION", "RETURNS", "DATA", "LOCAL", "GLOBAL", "PARAMETER", 
      "REDEFINE", "PERFORM", "CALLNAT", "ESCAPE", "ESCAPE_BOTTOM", "RETURN", 
      "IF", "THEN", "ELSE", "ELSE_IF", "END_IF", "DECIDE", "END_DECIDE", 
      "WHEN", "FOR", "THRU", "EVERY", "FIRST", "CONDITION", "ANY", "NONE", 
      "ALL", "UNIQUE_LEX", "REPEAT", "LOOP", "END_FOR", "END", "READ", "FIND", 
      "SELECT", "UPDATE", "STORE", "DELETE", "GET", "OBTAIN", "ADD", "SUBTRACT", 
      "MULTIPLY", "DIVIDE", "MOVE", "VALUE_OF", "TO", "DO", "DEFINE_SUBROUTINE", 
      "END_SUBROUTINE", "DEFINE_SUBPROGRAM", "END_SUBPROGRAM", "DEFINE_FUNCTION", 
      "END_FUNCTION", "END_READ", "END_FIND", "END_SELECT", "END_TRANSACTION", 
      "BACKOUT_TRANSACTION", "END_ALL", "VALUE", "DOEND", "USING_HELP", 
      "USING", "COMPUTE", "INPUT", "MAP", "RESET", "SET_KEY", "COMPRESS", 
      "NO_RECORDS_FOUND", "NO_RECORD_FOUND", "END_NOREC", "REINPUT", "MARK", 
      "WITH_TEXT", "FULL", "POSITION", "IN", "ALARM", "RECORD", "RECORDS", 
      "STATEMENT", "SET", "SAME", "GET_TRANSACTION_DATA", "GET_SAME", "WITH", 
      "ACCEPT_IF", "REJECT_IF", "EXAMINE", "SUBSTRING", "REPLACE", "GIVING", 
      "ABSOLUTE", "CHARPOSITION", "CHARLENGTH", "LENGTH", "NUMBER", "TRANSLATE", 
      "DELIMITER", "UPPPER_CASE", "LOWER_CASE", "INTO", "INVERTED", "INDEX", 
      "INDEXED", "PATTERN", "DISPLAY", "WRITE", "WRITE_TITLE", "WRITE_TRAILER", 
      "FIELD", "BY_NAME", "BY_POSITION", "EDITED", "LEFT", "RIGHT", "JUSTIFIED", 
      "NORMALIZED", "ENCODED", "ROUNDED", "SEPARATE", "SORT", "END_SORT", 
      "FORMAT", "SKIP_LEX", "EJECT", "NEWPAGE", "SUSPEND_IDENTICAL_SUPPRESS", 
      "DEFINE_PRINTER", "CLOSE_PRINTER", "DEFINE_WINDOW", "SET_WINDOW", 
      "PROCESS_PAGE", "PROCESS_PAGE_USING", "PROCESS_PAGE_UPDATE", "PROCESS_PAGE_MODAL", 
      "IF_SELECTION", "DECIDE_FOR", "DECIDE_ON", "CALL", "CALL_FILE", "CALL_LOOP", 
      "FETCH", "PROCESS_COMMAND", "RUN", "DEFINE_PROTOTYPE", "FUNCTION_CALL", 
      "STOP", "TERMINATE", "WRITE_WORK_FILE", "WRITE_WORK", "DOWNLOAD_PC_FILE", 
      "READ_WORK_FILE", "READ_WORK", "UPLOAD_PC_FILE", "CLOSE_WORK_FILE", 
      "CLOSE_WORK", "CLOSE_PC_FILE", "DEFINE_WORK_FILE", "DEFINE_CLASS", 
      "CREATE_OBJECT", "SEND_METHOD", "INTERFACE", "METHOD", "PROPERTY", 
      "EXPAND", "REDUCE", "RESIZE", "OPEN_CONVERSATION", "CLOSE_CONVERSATION", 
      "DEFINE_DATA_CONTEXT", "PARSE", "REQUEST_DOCUMENT", "RETRY", "AT_START_OF_DATA", 
      "AT_END_OF_DATA", "AT_BREAK", "BEFORE_BREAK_PROCESSING", "PERFORM_BREAK_PROCESSING", 
      "CALLDBPROC", "COMMIT", "PROCESS_SQL", "READ_RESULT_SET", "ROLLBACK", 
      "WRITE_PRINT", "AT_TOP_OF_PAGE", "AT_END_OF_PAGE", "DEFINE_DATA", 
      "END_DEFINE", "INCLUDE", "ON_ERROR", "RELEASE", "SET_CONTROL", "SET_GLOBALS", 
      "SET_TIME", "STACK", "ACCEPT", "REJECT", "PASSW", "LIMIT", "INSERT", 
      "HISTOGRAM", "END_HISTOGRAM", "THEN_DO", "IGNORE", "FRAC", "FROM", 
      "VIEW", "ASSIGN", "NUMERIC", "LEAVING_SPACE", "LEAVING_NO_SPACE", 
      "END_START", "ON", "OFF", "BY", "INTERFACE4", "RETAIN_AS", "WHERE", 
      "STARTING_WITH", "COUPLED", "VIA", "BUT", "SORTED", "ASCENDING", "DESCENDING", 
      "OF", "MULTI_FETCH", "STARTING_FROM", "ENDING_AT", "VARIABLE", "DYNAMIC", 
      "SEQUENCE", "END_WORK", "OFFSET", "FILLER", "ONCE", "AT_END_OF_FILE", 
      "END_ENDFILE", "PASSWORD", "CIPHER", "FILE", "REPOSITION", "PHYSICAL", 
      "STARTING", "ENDING", "AT", "AS", "GT_TEXT", "LT_TEXT", "GE_TEXT", 
      "LE_TEXT", "EQ_TEXT", "NE_TEXT", "AND_TEXT", "OR_TEXT", "NOT_TEXT", 
      "AND_EQ", "OR_RQ", "OR_SRQ", "EQUAL", "NOTEQUAL", "EQUAL_TO", "LESS_THAN", 
      "GREATER_THAN", "LESS_EQUAL", "GREATER_EQUAL", "STRING", "COLON", 
      "LINE_NUMBER", "FLOAT", "LITERAL", "LINE_REF", "INPUT_PARAM", "DATE_CONSTANT", 
      "H_CONSTANT", "PLUS", "MINUS", "MULT", "DIV", "EQ", "GT", "LT", "GE", 
      "LE", "NE", "LPAREN", "RPAREN", "IDENTIFIER", "TRAILING_COMMENT", 
      "WS", "NL", "WS_C", "NL_C", "COMMA", "MOD", "AND", "OR", "XOR", "NOT", 
      "TILDE", "QUESTION", "DOT", "LBRACK", "RBRACK", "LBRACE", "RBRACE", 
      "LABEL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,312,2046,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,1,0,1,
  	0,1,0,1,0,4,0,213,8,0,11,0,12,0,214,1,1,1,1,3,1,219,8,1,1,1,1,1,1,2,3,
  	2,224,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
  	2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,268,8,2,1,3,1,3,1,4,1,4,4,4,
  	274,8,4,11,4,12,4,275,1,4,1,4,1,5,1,5,5,5,282,8,5,10,5,12,5,285,9,5,1,
  	5,1,5,1,5,4,5,290,8,5,11,5,12,5,291,1,5,1,5,5,5,296,8,5,10,5,12,5,299,
  	9,5,1,5,1,5,5,5,303,8,5,10,5,12,5,306,9,5,1,5,3,5,309,8,5,1,6,1,6,1,6,
  	1,6,3,6,315,8,6,1,6,3,6,318,8,6,1,6,1,6,3,6,322,8,6,1,6,3,6,325,8,6,1,
  	7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,4,7,338,8,7,11,7,12,7,339,1,
  	7,3,7,343,8,7,1,8,1,8,1,9,5,9,348,8,9,10,9,12,9,351,9,9,1,9,3,9,354,8,
  	9,1,9,3,9,357,8,9,1,9,1,9,3,9,361,8,9,1,9,1,9,1,10,1,10,3,10,367,8,10,
  	1,10,3,10,370,8,10,1,10,1,10,1,10,3,10,375,8,10,1,11,1,11,1,11,3,11,380,
  	8,11,1,11,1,11,3,11,384,8,11,1,11,1,11,1,11,5,11,389,8,11,10,11,12,11,
  	392,9,11,1,11,1,11,3,11,396,8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,
  	12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,412,8,12,1,13,1,13,5,13,416,8,13,
  	10,13,12,13,419,9,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,1,14,1,14,1,14,
  	4,14,431,8,14,11,14,12,14,432,1,14,1,14,1,15,1,15,1,16,1,16,3,16,441,
  	8,16,1,16,1,16,1,16,4,16,446,8,16,11,16,12,16,447,1,16,3,16,451,8,16,
  	1,16,1,16,1,16,4,16,456,8,16,11,16,12,16,457,1,17,1,17,1,17,1,17,1,17,
  	1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,477,
  	8,17,1,18,1,18,5,18,481,8,18,10,18,12,18,484,9,18,1,18,1,18,1,19,1,19,
  	5,19,490,8,19,10,19,12,19,493,9,19,1,19,1,19,1,20,1,20,3,20,499,8,20,
  	1,20,3,20,502,8,20,1,20,3,20,505,8,20,1,20,3,20,508,8,20,1,20,3,20,511,
  	8,20,1,20,3,20,514,8,20,1,20,3,20,517,8,20,1,20,1,20,3,20,521,8,20,1,
  	20,3,20,524,8,20,1,20,3,20,527,8,20,1,20,3,20,530,8,20,1,20,3,20,533,
  	8,20,1,20,3,20,536,8,20,1,20,5,20,539,8,20,10,20,12,20,542,9,20,1,20,
  	3,20,545,8,20,1,20,3,20,548,8,20,1,20,5,20,551,8,20,10,20,12,20,554,9,
  	20,1,21,1,21,1,21,3,21,559,8,21,1,21,1,21,3,21,563,8,21,1,21,3,21,566,
  	8,21,1,21,1,21,1,21,3,21,571,8,21,1,21,1,21,3,21,575,8,21,1,21,3,21,578,
  	8,21,1,21,1,21,3,21,582,8,21,1,21,3,21,585,8,21,1,21,3,21,588,8,21,3,
  	21,590,8,21,1,22,3,22,593,8,22,1,22,5,22,596,8,22,10,22,12,22,599,9,22,
  	1,22,1,22,3,22,603,8,22,1,22,3,22,606,8,22,1,22,3,22,609,8,22,1,22,3,
  	22,612,8,22,1,22,3,22,615,8,22,1,22,3,22,618,8,22,1,22,3,22,621,8,22,
  	1,22,1,22,3,22,625,8,22,1,22,3,22,628,8,22,1,22,3,22,631,8,22,1,22,5,
  	22,634,8,22,10,22,12,22,637,9,22,1,22,3,22,640,8,22,1,22,1,22,3,22,644,
  	8,22,1,22,3,22,647,8,22,5,22,649,8,22,10,22,12,22,652,9,22,1,22,5,22,
  	655,8,22,10,22,12,22,658,9,22,1,22,1,22,1,23,1,23,1,23,1,23,1,23,3,23,
  	667,8,23,1,24,1,24,1,24,1,24,1,24,5,24,674,8,24,10,24,12,24,677,9,24,
  	1,24,1,24,3,24,681,8,24,1,24,1,24,1,24,1,25,1,25,1,25,1,25,1,25,1,25,
  	1,25,5,25,693,8,25,10,25,12,25,696,9,25,1,25,1,25,3,25,700,8,25,1,25,
  	1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,26,3,26,711,8,26,1,26,1,26,1,26,
  	3,26,716,8,26,1,26,1,26,1,26,4,26,721,8,26,11,26,12,26,722,3,26,725,8,
  	26,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,
  	27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,5,27,752,8,
  	27,10,27,12,27,755,9,27,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,
  	5,29,766,8,29,10,29,12,29,769,9,29,1,29,1,29,3,29,773,8,29,1,29,1,29,
  	1,29,1,30,1,30,1,30,1,30,3,30,782,8,30,1,30,1,30,1,30,3,30,787,8,30,1,
  	30,1,30,1,30,4,30,792,8,30,11,30,12,30,793,3,30,796,8,30,1,31,1,31,1,
  	31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
  	31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
  	31,1,31,5,31,830,8,31,10,31,12,31,833,9,31,1,32,1,32,4,32,837,8,32,11,
  	32,12,32,838,1,32,3,32,842,8,32,1,32,1,32,1,32,1,32,1,32,3,32,849,8,32,
  	1,32,3,32,852,8,32,1,32,1,32,3,32,856,8,32,1,32,1,32,1,32,4,32,861,8,
  	32,11,32,12,32,862,1,32,3,32,866,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,3,32,878,8,32,1,32,1,32,1,32,1,32,3,32,884,8,32,1,32,
  	1,32,3,32,888,8,32,1,33,1,33,3,33,892,8,33,1,33,3,33,895,8,33,1,33,3,
  	33,898,8,33,1,33,3,33,901,8,33,1,33,3,33,904,8,33,1,33,3,33,907,8,33,
  	1,33,3,33,910,8,33,1,33,3,33,913,8,33,1,34,1,34,3,34,917,8,34,1,34,3,
  	34,920,8,34,1,35,1,35,1,35,3,35,925,8,35,1,36,1,36,1,36,1,36,1,36,5,36,
  	932,8,36,10,36,12,36,935,9,36,1,36,1,36,3,36,939,8,36,1,36,1,36,1,37,
  	1,37,1,38,1,38,4,38,947,8,38,11,38,12,38,948,1,38,1,38,1,39,1,39,3,39,
  	955,8,39,1,39,3,39,958,8,39,1,39,5,39,961,8,39,10,39,12,39,964,9,39,1,
  	39,1,39,1,40,1,40,5,40,970,8,40,10,40,12,40,973,9,40,1,40,1,40,1,41,1,
  	41,3,41,979,8,41,1,41,1,41,1,41,1,41,5,41,985,8,41,10,41,12,41,988,9,
  	41,1,41,1,41,5,41,992,8,41,10,41,12,41,995,9,41,1,41,3,41,998,8,41,1,
  	41,1,41,1,42,1,42,1,42,1,42,3,42,1006,8,42,1,42,1,42,1,42,4,42,1011,8,
  	42,11,42,12,42,1012,3,42,1015,8,42,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
  	1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,
  	1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,5,43,1046,8,43,10,43,12,43,1049,
  	9,43,1,43,1,43,1,44,1,44,1,45,1,45,1,46,1,46,1,46,1,46,3,46,1061,8,46,
  	1,46,3,46,1064,8,46,1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1073,8,46,
  	1,46,3,46,1076,8,46,1,46,1,46,4,46,1080,8,46,11,46,12,46,1081,1,46,1,
  	46,1,46,1,46,1,46,1,46,3,46,1090,8,46,1,46,3,46,1093,8,46,1,46,1,46,4,
  	46,1097,8,46,11,46,12,46,1098,1,46,1,46,3,46,1103,8,46,1,47,1,47,1,48,
  	1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,5,48,1119,8,48,
  	10,48,12,48,1122,9,48,1,49,1,49,5,49,1126,8,49,10,49,12,49,1129,9,49,
  	1,49,1,49,1,50,1,50,1,50,1,50,3,50,1137,8,50,1,50,3,50,1140,8,50,1,50,
  	1,50,1,50,1,50,5,50,1146,8,50,10,50,12,50,1149,9,50,1,50,1,50,1,51,1,
  	51,1,51,1,51,1,52,1,52,1,52,1,52,5,52,1161,8,52,10,52,12,52,1164,9,52,
  	1,52,1,52,1,53,1,53,3,53,1170,8,53,1,53,3,53,1173,8,53,1,53,3,53,1176,
  	8,53,1,53,1,53,3,53,1180,8,53,1,53,5,53,1183,8,53,10,53,12,53,1186,9,
  	53,1,53,1,53,1,54,1,54,5,54,1192,8,54,10,54,12,54,1195,9,54,1,54,1,54,
  	3,54,1199,8,54,1,54,3,54,1202,8,54,1,54,3,54,1205,8,54,5,54,1207,8,54,
  	10,54,12,54,1210,9,54,1,55,1,55,3,55,1214,8,55,1,55,1,55,3,55,1218,8,
  	55,1,56,1,56,1,56,1,56,1,57,1,57,5,57,1226,8,57,10,57,12,57,1229,9,57,
  	1,57,1,57,3,57,1233,8,57,1,57,3,57,1236,8,57,1,57,3,57,1239,8,57,1,58,
  	1,58,3,58,1243,8,58,1,58,1,58,1,59,1,59,1,59,5,59,1250,8,59,10,59,12,
  	59,1253,9,59,1,59,1,59,1,60,1,60,3,60,1259,8,60,1,60,1,60,1,61,1,61,3,
  	61,1265,8,61,1,61,1,61,3,61,1269,8,61,1,61,1,61,1,61,1,61,5,61,1275,8,
  	61,10,61,12,61,1278,9,61,1,61,1,61,1,62,1,62,5,62,1284,8,62,10,62,12,
  	62,1287,9,62,1,63,1,63,3,63,1291,8,63,1,63,1,63,3,63,1295,8,63,1,63,1,
  	63,3,63,1299,8,63,1,63,3,63,1302,8,63,1,64,1,64,1,65,1,65,1,65,3,65,1309,
  	8,65,1,65,3,65,1312,8,65,1,65,1,65,5,65,1316,8,65,10,65,12,65,1319,9,
  	65,1,65,5,65,1322,8,65,10,65,12,65,1325,9,65,1,66,1,66,1,66,3,66,1330,
  	8,66,1,66,3,66,1333,8,66,1,66,1,66,3,66,1337,8,66,1,66,3,66,1340,8,66,
  	1,66,5,66,1343,8,66,10,66,12,66,1346,9,66,1,66,5,66,1349,8,66,10,66,12,
  	66,1352,9,66,1,66,3,66,1355,8,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,
  	67,1,67,5,67,1366,8,67,10,67,12,67,1369,9,67,1,67,1,67,1,68,1,68,3,68,
  	1375,8,68,1,68,1,68,1,69,1,69,3,69,1381,8,69,1,69,1,69,1,69,3,69,1386,
  	8,69,1,69,3,69,1389,8,69,1,69,3,69,1392,8,69,1,69,3,69,1395,8,69,3,69,
  	1397,8,69,1,69,3,69,1400,8,69,1,69,3,69,1403,8,69,1,69,3,69,1406,8,69,
  	1,69,1,69,1,69,5,69,1411,8,69,10,69,12,69,1414,9,69,1,69,1,69,1,70,1,
  	70,1,70,1,70,1,70,3,70,1423,8,70,1,71,1,71,1,71,1,71,5,71,1429,8,71,10,
  	71,12,71,1432,9,71,1,71,3,71,1435,8,71,1,71,4,71,1438,8,71,11,71,12,71,
  	1439,1,71,1,71,3,71,1444,8,71,1,72,1,72,5,72,1448,8,72,10,72,12,72,1451,
  	9,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,3,73,1461,8,73,1,73,3,73,
  	1464,8,73,1,73,3,73,1467,8,73,1,73,1,73,1,73,3,73,1472,8,73,1,73,3,73,
  	1475,8,73,1,73,1,73,1,73,1,73,3,73,1481,8,73,1,73,3,73,1484,8,73,1,73,
  	1,73,3,73,1488,8,73,1,74,1,74,1,74,1,74,5,74,1494,8,74,10,74,12,74,1497,
  	9,74,1,74,1,74,5,74,1501,8,74,10,74,12,74,1504,9,74,1,74,1,74,1,74,3,
  	74,1509,8,74,1,74,3,74,1512,8,74,1,74,1,74,3,74,1516,8,74,3,74,1518,8,
  	74,1,75,1,75,1,75,1,75,5,75,1524,8,75,10,75,12,75,1527,9,75,1,75,3,75,
  	1530,8,75,1,75,5,75,1533,8,75,10,75,12,75,1536,9,75,1,75,1,75,5,75,1540,
  	8,75,10,75,12,75,1543,9,75,1,75,1,75,3,75,1547,8,75,3,75,1549,8,75,1,
  	76,1,76,1,76,1,76,3,76,1555,8,76,1,76,3,76,1558,8,76,1,76,1,76,1,77,1,
  	77,1,77,1,77,3,77,1566,8,77,1,77,3,77,1569,8,77,1,77,1,77,1,78,3,78,1574,
  	8,78,1,78,3,78,1577,8,78,1,78,1,78,1,78,1,78,3,78,1583,8,78,1,78,3,78,
  	1586,8,78,1,78,3,78,1589,8,78,1,79,1,79,1,79,1,79,3,79,1595,8,79,1,79,
  	3,79,1598,8,79,1,79,1,79,1,79,3,79,1603,8,79,1,79,1,79,1,79,3,79,1608,
  	8,79,1,79,3,79,1611,8,79,1,79,1,79,1,79,1,79,3,79,1617,8,79,1,79,3,79,
  	1620,8,79,1,79,3,79,1623,8,79,1,79,1,79,1,79,1,79,3,79,1629,8,79,1,79,
  	3,79,1632,8,79,1,79,3,79,1635,8,79,1,79,1,79,1,79,1,79,1,79,1,79,3,79,
  	1643,8,79,1,79,3,79,1646,8,79,1,79,3,79,1649,8,79,3,79,1651,8,79,1,80,
  	1,80,1,80,3,80,1656,8,80,1,80,1,80,1,80,3,80,1661,8,80,1,80,3,80,1664,
  	8,80,1,80,1,80,1,80,1,80,3,80,1670,8,80,1,80,3,80,1673,8,80,1,80,3,80,
  	1676,8,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
  	3,81,1690,8,81,1,82,1,82,1,82,3,82,1695,8,82,1,83,1,83,1,84,1,84,3,84,
  	1701,8,84,1,84,1,84,3,84,1705,8,84,1,84,1,84,1,84,1,85,1,85,1,85,5,85,
  	1713,8,85,10,85,12,85,1716,9,85,1,85,3,85,1719,8,85,1,86,1,86,1,86,1,
  	86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,
  	86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,
  	86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,3,86,1760,8,86,1,87,1,87,3,87,1764,
  	8,87,1,87,1,87,3,87,1768,8,87,1,87,1,87,3,87,1772,8,87,1,87,1,87,3,87,
  	1776,8,87,1,87,1,87,3,87,1780,8,87,1,87,1,87,1,88,1,88,1,88,5,88,1787,
  	8,88,10,88,12,88,1790,9,88,1,88,3,88,1793,8,88,1,89,1,89,3,89,1797,8,
  	89,1,89,3,89,1800,8,89,1,89,3,89,1803,8,89,1,89,3,89,1806,8,89,1,89,1,
  	89,3,89,1810,8,89,1,89,5,89,1813,8,89,10,89,12,89,1816,9,89,1,89,3,89,
  	1819,8,89,1,89,3,89,1822,8,89,1,89,3,89,1825,8,89,1,89,3,89,1828,8,89,
  	1,89,3,89,1831,8,89,1,89,3,89,1834,8,89,1,89,3,89,1837,8,89,1,89,3,89,
  	1840,8,89,1,89,3,89,1843,8,89,1,89,3,89,1846,8,89,1,89,3,89,1849,8,89,
  	1,89,3,89,1852,8,89,1,89,3,89,1855,8,89,1,89,3,89,1858,8,89,1,89,3,89,
  	1861,8,89,1,90,1,90,3,90,1865,8,90,1,90,3,90,1868,8,90,1,90,3,90,1871,
  	8,90,1,90,1,90,3,90,1875,8,90,1,90,3,90,1878,8,90,1,90,1,90,1,90,4,90,
  	1883,8,90,11,90,12,90,1884,1,91,1,91,5,91,1889,8,91,10,91,12,91,1892,
  	9,91,1,91,3,91,1895,8,91,1,92,1,92,5,92,1899,8,92,10,92,12,92,1902,9,
  	92,1,92,3,92,1905,8,92,1,93,1,93,5,93,1909,8,93,10,93,12,93,1912,9,93,
  	1,93,3,93,1915,8,93,1,94,1,94,5,94,1919,8,94,10,94,12,94,1922,9,94,1,
  	94,3,94,1925,8,94,1,95,1,95,3,95,1929,8,95,1,95,3,95,1932,8,95,1,95,3,
  	95,1935,8,95,1,95,1,95,3,95,1939,8,95,1,95,3,95,1942,8,95,1,95,1,95,3,
  	95,1946,8,95,1,95,1,95,3,95,1950,8,95,1,95,1,95,3,95,1954,8,95,1,95,1,
  	95,3,95,1958,8,95,1,95,3,95,1961,8,95,1,95,1,95,3,95,1965,8,95,1,95,3,
  	95,1968,8,95,1,95,3,95,1971,8,95,1,95,1,95,3,95,1975,8,95,1,95,3,95,1978,
  	8,95,1,95,1,95,3,95,1982,8,95,1,95,1,95,3,95,1986,8,95,1,96,1,96,3,96,
  	1990,8,96,1,96,3,96,1993,8,96,1,96,1,96,3,96,1997,8,96,1,96,1,96,3,96,
  	2001,8,96,1,96,1,96,3,96,2005,8,96,1,96,1,96,3,96,2009,8,96,1,96,3,96,
  	2012,8,96,1,97,1,97,3,97,2016,8,97,1,97,1,97,3,97,2020,8,97,1,97,3,97,
  	2023,8,97,1,98,1,98,1,98,1,98,1,98,1,98,3,98,2031,8,98,1,99,1,99,1,100,
  	1,100,1,101,1,101,1,102,1,102,1,103,4,103,2042,8,103,11,103,12,103,2043,
  	1,103,5,597,635,1193,1227,2043,0,104,0,2,4,6,8,10,12,14,16,18,20,22,24,
  	26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,
  	72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
  	114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,
  	150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,
  	186,188,190,192,194,196,198,200,202,204,206,0,43,3,0,79,79,214,214,295,
  	295,2,0,274,274,295,296,3,0,77,77,80,81,115,115,2,0,277,277,293,293,9,
  	0,22,22,40,40,48,48,66,66,79,81,90,90,94,108,110,110,259,259,2,0,66,66,
  	96,96,1,0,281,282,2,0,32,32,58,58,2,0,218,219,231,231,3,0,81,81,83,84,
  	246,246,2,0,32,32,57,57,1,0,295,296,2,0,86,86,90,90,1,0,83,84,3,0,274,
  	274,293,293,295,296,2,0,293,293,295,295,2,0,32,32,207,207,3,0,25,25,29,
  	30,277,277,2,0,81,81,246,246,1,0,157,158,2,0,32,32,238,238,1,0,154,155,
  	1,0,160,161,1,0,73,74,2,0,64,64,217,217,3,0,218,219,274,274,293,293,2,
  	0,274,274,293,293,2,0,102,102,293,293,2,0,13,13,31,31,2,0,272,272,293,
  	293,1,0,32,33,1,0,91,92,1,0,142,143,1,0,24,25,2,0,48,48,63,63,1,1,296,
  	296,2,0,259,271,301,302,2,0,13,13,52,52,7,0,49,49,96,96,124,124,272,272,
  	274,276,293,293,295,295,2,0,253,258,285,290,1,0,281,284,25,0,8,11,14,
  	14,22,22,31,32,34,47,50,51,55,55,60,61,64,64,67,68,70,72,76,76,88,89,
  	93,93,111,114,125,126,128,128,130,154,156,157,159,160,162,188,190,192,
  	194,200,203,206,217,217,19,0,8,10,13,16,18,18,32,33,35,36,38,39,41,41,
  	47,47,50,51,55,55,63,64,68,68,70,70,76,76,128,128,142,143,179,179,194,
  	194,206,207,2550,0,212,1,0,0,0,2,216,1,0,0,0,4,223,1,0,0,0,6,269,1,0,
  	0,0,8,271,1,0,0,0,10,279,1,0,0,0,12,324,1,0,0,0,14,342,1,0,0,0,16,344,
  	1,0,0,0,18,349,1,0,0,0,20,374,1,0,0,0,22,376,1,0,0,0,24,411,1,0,0,0,26,
  	413,1,0,0,0,28,422,1,0,0,0,30,436,1,0,0,0,32,438,1,0,0,0,34,476,1,0,0,
  	0,36,478,1,0,0,0,38,487,1,0,0,0,40,496,1,0,0,0,42,589,1,0,0,0,44,592,
  	1,0,0,0,46,666,1,0,0,0,48,668,1,0,0,0,50,685,1,0,0,0,52,724,1,0,0,0,54,
  	753,1,0,0,0,56,756,1,0,0,0,58,760,1,0,0,0,60,795,1,0,0,0,62,831,1,0,0,
  	0,64,887,1,0,0,0,66,889,1,0,0,0,68,914,1,0,0,0,70,924,1,0,0,0,72,926,
  	1,0,0,0,74,942,1,0,0,0,76,944,1,0,0,0,78,952,1,0,0,0,80,967,1,0,0,0,82,
  	976,1,0,0,0,84,1014,1,0,0,0,86,1047,1,0,0,0,88,1052,1,0,0,0,90,1054,1,
  	0,0,0,92,1102,1,0,0,0,94,1104,1,0,0,0,96,1120,1,0,0,0,98,1123,1,0,0,0,
  	100,1132,1,0,0,0,102,1152,1,0,0,0,104,1156,1,0,0,0,106,1167,1,0,0,0,108,
  	1189,1,0,0,0,110,1217,1,0,0,0,112,1219,1,0,0,0,114,1223,1,0,0,0,116,1240,
  	1,0,0,0,118,1251,1,0,0,0,120,1256,1,0,0,0,122,1262,1,0,0,0,124,1281,1,
  	0,0,0,126,1288,1,0,0,0,128,1303,1,0,0,0,130,1305,1,0,0,0,132,1326,1,0,
  	0,0,134,1358,1,0,0,0,136,1372,1,0,0,0,138,1378,1,0,0,0,140,1422,1,0,0,
  	0,142,1424,1,0,0,0,144,1445,1,0,0,0,146,1454,1,0,0,0,148,1489,1,0,0,0,
  	150,1519,1,0,0,0,152,1550,1,0,0,0,154,1561,1,0,0,0,156,1588,1,0,0,0,158,
  	1650,1,0,0,0,160,1655,1,0,0,0,162,1689,1,0,0,0,164,1691,1,0,0,0,166,1696,
  	1,0,0,0,168,1698,1,0,0,0,170,1714,1,0,0,0,172,1759,1,0,0,0,174,1761,1,
  	0,0,0,176,1788,1,0,0,0,178,1794,1,0,0,0,180,1862,1,0,0,0,182,1886,1,0,
  	0,0,184,1896,1,0,0,0,186,1906,1,0,0,0,188,1916,1,0,0,0,190,1985,1,0,0,
  	0,192,1987,1,0,0,0,194,2013,1,0,0,0,196,2030,1,0,0,0,198,2032,1,0,0,0,
  	200,2034,1,0,0,0,202,2036,1,0,0,0,204,2038,1,0,0,0,206,2041,1,0,0,0,208,
  	213,3,2,1,0,209,213,3,4,2,0,210,213,5,295,0,0,211,213,5,296,0,0,212,208,
  	1,0,0,0,212,209,1,0,0,0,212,210,1,0,0,0,212,211,1,0,0,0,213,214,1,0,0,
  	0,214,212,1,0,0,0,214,215,1,0,0,0,215,1,1,0,0,0,216,218,5,274,0,0,217,
  	219,5,295,0,0,218,217,1,0,0,0,218,219,1,0,0,0,219,220,1,0,0,0,220,221,
  	3,4,2,0,221,3,1,0,0,0,222,224,3,6,3,0,223,222,1,0,0,0,223,224,1,0,0,0,
  	224,267,1,0,0,0,225,268,3,8,4,0,226,268,3,168,84,0,227,268,3,174,87,0,
  	228,268,3,104,52,0,229,268,3,138,69,0,230,268,3,178,89,0,231,268,3,134,
  	67,0,232,268,3,140,70,0,233,268,3,126,63,0,234,268,3,122,61,0,235,268,
  	3,28,14,0,236,268,3,32,16,0,237,268,3,46,23,0,238,268,3,56,28,0,239,268,
  	3,40,20,0,240,268,3,64,32,0,241,268,3,68,34,0,242,268,3,70,35,0,243,268,
  	3,80,40,0,244,268,3,88,44,0,245,268,3,90,45,0,246,268,3,92,46,0,247,268,
  	3,100,50,0,248,268,3,102,51,0,249,268,3,14,7,0,250,268,3,22,11,0,251,
  	268,3,196,98,0,252,268,3,180,90,0,253,268,3,124,62,0,254,268,3,116,58,
  	0,255,268,3,120,60,0,256,268,3,26,13,0,257,268,3,10,5,0,258,268,3,38,
  	19,0,259,268,3,36,18,0,260,268,3,106,53,0,261,268,3,108,54,0,262,268,
  	3,112,56,0,263,268,3,114,57,0,264,268,3,130,65,0,265,268,3,132,66,0,266,
  	268,3,206,103,0,267,225,1,0,0,0,267,226,1,0,0,0,267,227,1,0,0,0,267,228,
  	1,0,0,0,267,229,1,0,0,0,267,230,1,0,0,0,267,231,1,0,0,0,267,232,1,0,0,
  	0,267,233,1,0,0,0,267,234,1,0,0,0,267,235,1,0,0,0,267,236,1,0,0,0,267,
  	237,1,0,0,0,267,238,1,0,0,0,267,239,1,0,0,0,267,240,1,0,0,0,267,241,1,
  	0,0,0,267,242,1,0,0,0,267,243,1,0,0,0,267,244,1,0,0,0,267,245,1,0,0,0,
  	267,246,1,0,0,0,267,247,1,0,0,0,267,248,1,0,0,0,267,249,1,0,0,0,267,250,
  	1,0,0,0,267,251,1,0,0,0,267,252,1,0,0,0,267,253,1,0,0,0,267,254,1,0,0,
  	0,267,255,1,0,0,0,267,256,1,0,0,0,267,257,1,0,0,0,267,258,1,0,0,0,267,
  	259,1,0,0,0,267,260,1,0,0,0,267,261,1,0,0,0,267,262,1,0,0,0,267,263,1,
  	0,0,0,267,264,1,0,0,0,267,265,1,0,0,0,267,266,1,0,0,0,268,5,1,0,0,0,269,
  	270,5,312,0,0,270,7,1,0,0,0,271,273,5,192,0,0,272,274,3,4,2,0,273,272,
  	1,0,0,0,274,275,1,0,0,0,275,273,1,0,0,0,275,276,1,0,0,0,276,277,1,0,0,
  	0,277,278,5,193,0,0,278,9,1,0,0,0,279,283,5,72,0,0,280,282,7,0,0,0,281,
  	280,1,0,0,0,282,285,1,0,0,0,283,281,1,0,0,0,283,284,1,0,0,0,284,289,1,
  	0,0,0,285,283,1,0,0,0,286,290,3,162,81,0,287,290,5,295,0,0,288,290,5,
  	296,0,0,289,286,1,0,0,0,289,287,1,0,0,0,289,288,1,0,0,0,290,291,1,0,0,
  	0,291,289,1,0,0,0,291,292,1,0,0,0,292,293,1,0,0,0,293,297,5,106,0,0,294,
  	296,7,1,0,0,295,294,1,0,0,0,296,299,1,0,0,0,297,295,1,0,0,0,297,298,1,
  	0,0,0,298,300,1,0,0,0,299,297,1,0,0,0,300,308,3,162,81,0,301,303,7,1,
  	0,0,302,301,1,0,0,0,303,306,1,0,0,0,304,302,1,0,0,0,304,305,1,0,0,0,305,
  	307,1,0,0,0,306,304,1,0,0,0,307,309,3,12,6,0,308,304,1,0,0,0,308,309,
  	1,0,0,0,309,11,1,0,0,0,310,325,5,215,0,0,311,325,5,216,0,0,312,317,5,
  	90,0,0,313,315,5,295,0,0,314,313,1,0,0,0,314,315,1,0,0,0,315,316,1,0,
  	0,0,316,318,5,29,0,0,317,314,1,0,0,0,317,318,1,0,0,0,318,319,1,0,0,0,
  	319,321,5,103,0,0,320,322,5,295,0,0,321,320,1,0,0,0,321,322,1,0,0,0,322,
  	323,1,0,0,0,323,325,5,272,0,0,324,310,1,0,0,0,324,311,1,0,0,0,324,312,
  	1,0,0,0,325,13,1,0,0,0,326,327,5,68,0,0,327,328,5,295,0,0,328,343,3,18,
  	9,0,329,337,5,68,0,0,330,338,5,272,0,0,331,338,3,20,10,0,332,338,3,16,
  	8,0,333,338,5,284,0,0,334,338,5,295,0,0,335,338,5,274,0,0,336,338,5,296,
  	0,0,337,330,1,0,0,0,337,331,1,0,0,0,337,332,1,0,0,0,337,333,1,0,0,0,337,
  	334,1,0,0,0,337,335,1,0,0,0,337,336,1,0,0,0,338,339,1,0,0,0,339,337,1,
  	0,0,0,339,340,1,0,0,0,340,341,1,0,0,0,341,343,5,296,0,0,342,326,1,0,0,
  	0,342,329,1,0,0,0,343,15,1,0,0,0,344,345,7,2,0,0,345,17,1,0,0,0,346,348,
  	3,4,2,0,347,346,1,0,0,0,348,351,1,0,0,0,349,347,1,0,0,0,349,350,1,0,0,
  	0,350,353,1,0,0,0,351,349,1,0,0,0,352,354,5,66,0,0,353,352,1,0,0,0,353,
  	354,1,0,0,0,354,356,1,0,0,0,355,357,5,295,0,0,356,355,1,0,0,0,356,357,
  	1,0,0,0,357,358,1,0,0,0,358,360,5,69,0,0,359,361,5,295,0,0,360,359,1,
  	0,0,0,360,361,1,0,0,0,361,362,1,0,0,0,362,363,5,272,0,0,363,19,1,0,0,
  	0,364,369,5,293,0,0,365,367,5,295,0,0,366,365,1,0,0,0,366,367,1,0,0,0,
  	367,368,1,0,0,0,368,370,7,3,0,0,369,366,1,0,0,0,369,370,1,0,0,0,370,375,
  	1,0,0,0,371,372,5,293,0,0,372,373,5,307,0,0,373,375,5,293,0,0,374,364,
  	1,0,0,0,374,371,1,0,0,0,375,21,1,0,0,0,376,379,5,76,0,0,377,378,5,295,
  	0,0,378,380,5,79,0,0,379,377,1,0,0,0,379,380,1,0,0,0,380,390,1,0,0,0,
  	381,382,5,274,0,0,382,384,5,295,0,0,383,381,1,0,0,0,383,384,1,0,0,0,384,
  	385,1,0,0,0,385,389,3,24,12,0,386,389,5,295,0,0,387,389,5,296,0,0,388,
  	383,1,0,0,0,388,386,1,0,0,0,388,387,1,0,0,0,389,392,1,0,0,0,390,388,1,
  	0,0,0,390,391,1,0,0,0,391,395,1,0,0,0,392,390,1,0,0,0,393,394,5,295,0,
  	0,394,396,5,82,0,0,395,393,1,0,0,0,395,396,1,0,0,0,396,23,1,0,0,0,397,
  	412,5,77,0,0,398,412,5,293,0,0,399,412,5,78,0,0,400,401,5,77,0,0,401,
  	402,5,295,0,0,402,403,5,80,0,0,403,404,5,295,0,0,404,405,5,274,0,0,405,
  	406,5,295,0,0,406,407,5,81,0,0,407,408,5,295,0,0,408,412,5,293,0,0,409,
  	412,5,65,0,0,410,412,5,272,0,0,411,397,1,0,0,0,411,398,1,0,0,0,411,399,
  	1,0,0,0,411,400,1,0,0,0,411,409,1,0,0,0,411,410,1,0,0,0,412,25,1,0,0,
  	0,413,417,5,126,0,0,414,416,3,4,2,0,415,414,1,0,0,0,416,419,1,0,0,0,417,
  	415,1,0,0,0,417,418,1,0,0,0,418,420,1,0,0,0,419,417,1,0,0,0,420,421,5,
  	127,0,0,421,27,1,0,0,0,422,423,5,93,0,0,423,430,5,295,0,0,424,431,3,20,
  	10,0,425,431,5,272,0,0,426,431,3,30,15,0,427,431,5,274,0,0,428,431,5,
  	295,0,0,429,431,5,296,0,0,430,424,1,0,0,0,430,425,1,0,0,0,430,426,1,0,
  	0,0,430,427,1,0,0,0,430,428,1,0,0,0,430,429,1,0,0,0,431,432,1,0,0,0,432,
  	430,1,0,0,0,432,433,1,0,0,0,433,434,1,0,0,0,434,435,5,296,0,0,435,29,
  	1,0,0,0,436,437,7,4,0,0,437,31,1,0,0,0,438,440,5,47,0,0,439,441,5,295,
  	0,0,440,439,1,0,0,0,440,441,1,0,0,0,441,445,1,0,0,0,442,446,3,34,17,0,
  	443,446,5,295,0,0,444,446,5,296,0,0,445,442,1,0,0,0,445,443,1,0,0,0,445,
  	444,1,0,0,0,446,447,1,0,0,0,447,445,1,0,0,0,447,448,1,0,0,0,448,450,1,
  	0,0,0,449,451,5,49,0,0,450,449,1,0,0,0,450,451,1,0,0,0,451,455,1,0,0,
  	0,452,456,3,34,17,0,453,456,5,295,0,0,454,456,5,296,0,0,455,452,1,0,0,
  	0,455,453,1,0,0,0,455,454,1,0,0,0,456,457,1,0,0,0,457,455,1,0,0,0,457,
  	458,1,0,0,0,458,33,1,0,0,0,459,477,3,162,81,0,460,461,5,287,0,0,461,462,
  	3,162,81,0,462,463,5,286,0,0,463,477,1,0,0,0,464,477,5,124,0,0,465,477,
  	5,94,0,0,466,477,5,116,0,0,467,477,5,117,0,0,468,477,5,118,0,0,469,477,
  	5,119,0,0,470,477,5,120,0,0,471,477,5,121,0,0,472,477,5,122,0,0,473,477,
  	5,123,0,0,474,477,5,29,0,0,475,477,5,109,0,0,476,459,1,0,0,0,476,460,
  	1,0,0,0,476,464,1,0,0,0,476,465,1,0,0,0,476,466,1,0,0,0,476,467,1,0,0,
  	0,476,468,1,0,0,0,476,469,1,0,0,0,476,470,1,0,0,0,476,471,1,0,0,0,476,
  	472,1,0,0,0,476,473,1,0,0,0,476,474,1,0,0,0,476,475,1,0,0,0,477,35,1,
  	0,0,0,478,482,5,31,0,0,479,481,3,4,2,0,480,479,1,0,0,0,481,484,1,0,0,
  	0,482,480,1,0,0,0,482,483,1,0,0,0,483,485,1,0,0,0,484,482,1,0,0,0,485,
  	486,5,32,0,0,486,37,1,0,0,0,487,491,5,50,0,0,488,490,3,4,2,0,489,488,
  	1,0,0,0,490,493,1,0,0,0,491,489,1,0,0,0,491,492,1,0,0,0,492,494,1,0,0,
  	0,493,491,1,0,0,0,494,495,5,64,0,0,495,39,1,0,0,0,496,498,5,39,0,0,497,
  	499,5,295,0,0,498,497,1,0,0,0,498,499,1,0,0,0,499,501,1,0,0,0,500,502,
  	5,83,0,0,501,500,1,0,0,0,501,502,1,0,0,0,502,504,1,0,0,0,503,505,5,295,
  	0,0,504,503,1,0,0,0,504,505,1,0,0,0,505,507,1,0,0,0,506,508,5,81,0,0,
  	507,506,1,0,0,0,507,508,1,0,0,0,508,510,1,0,0,0,509,511,5,295,0,0,510,
  	509,1,0,0,0,510,511,1,0,0,0,511,513,1,0,0,0,512,514,5,246,0,0,513,512,
  	1,0,0,0,513,514,1,0,0,0,514,516,1,0,0,0,515,517,5,295,0,0,516,515,1,0,
  	0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,520,5,293,0,0,519,521,5,295,0,
  	0,520,519,1,0,0,0,520,521,1,0,0,0,521,523,1,0,0,0,522,524,5,296,0,0,523,
  	522,1,0,0,0,523,524,1,0,0,0,524,526,1,0,0,0,525,527,5,90,0,0,526,525,
  	1,0,0,0,526,527,1,0,0,0,527,529,1,0,0,0,528,530,5,86,0,0,529,528,1,0,
  	0,0,529,530,1,0,0,0,530,532,1,0,0,0,531,533,5,295,0,0,532,531,1,0,0,0,
  	532,533,1,0,0,0,533,535,1,0,0,0,534,536,5,296,0,0,535,534,1,0,0,0,535,
  	536,1,0,0,0,536,540,1,0,0,0,537,539,3,42,21,0,538,537,1,0,0,0,539,542,
  	1,0,0,0,540,538,1,0,0,0,540,541,1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,
  	0,543,545,5,295,0,0,544,543,1,0,0,0,544,545,1,0,0,0,545,547,1,0,0,0,546,
  	548,5,296,0,0,547,546,1,0,0,0,547,548,1,0,0,0,548,552,1,0,0,0,549,551,
  	3,44,22,0,550,549,1,0,0,0,551,554,1,0,0,0,552,550,1,0,0,0,552,553,1,0,
  	0,0,553,41,1,0,0,0,554,552,1,0,0,0,555,556,5,244,0,0,556,558,5,295,0,
  	0,557,559,5,273,0,0,558,557,1,0,0,0,558,559,1,0,0,0,559,560,1,0,0,0,560,
  	562,5,285,0,0,561,563,5,295,0,0,562,561,1,0,0,0,562,563,1,0,0,0,563,565,
  	1,0,0,0,564,566,3,162,81,0,565,564,1,0,0,0,565,566,1,0,0,0,566,590,1,
  	0,0,0,567,568,5,245,0,0,568,570,5,295,0,0,569,571,5,273,0,0,570,569,1,
  	0,0,0,570,571,1,0,0,0,571,572,1,0,0,0,572,574,5,285,0,0,573,575,5,295,
  	0,0,574,573,1,0,0,0,574,575,1,0,0,0,575,577,1,0,0,0,576,578,3,162,81,
  	0,577,576,1,0,0,0,577,578,1,0,0,0,578,590,1,0,0,0,579,581,7,5,0,0,580,
  	582,5,295,0,0,581,580,1,0,0,0,581,582,1,0,0,0,582,584,1,0,0,0,583,585,
  	5,101,0,0,584,583,1,0,0,0,584,585,1,0,0,0,585,587,1,0,0,0,586,588,3,162,
  	81,0,587,586,1,0,0,0,587,588,1,0,0,0,588,590,1,0,0,0,589,555,1,0,0,0,
  	589,567,1,0,0,0,589,579,1,0,0,0,590,43,1,0,0,0,591,593,5,274,0,0,592,
  	591,1,0,0,0,592,593,1,0,0,0,593,597,1,0,0,0,594,596,5,295,0,0,595,594,
  	1,0,0,0,596,599,1,0,0,0,597,598,1,0,0,0,597,595,1,0,0,0,598,650,1,0,0,
  	0,599,597,1,0,0,0,600,602,3,162,81,0,601,603,5,295,0,0,602,601,1,0,0,
  	0,602,603,1,0,0,0,603,605,1,0,0,0,604,606,5,296,0,0,605,604,1,0,0,0,605,
  	606,1,0,0,0,606,608,1,0,0,0,607,609,5,274,0,0,608,607,1,0,0,0,608,609,
  	1,0,0,0,609,611,1,0,0,0,610,612,5,273,0,0,611,610,1,0,0,0,611,612,1,0,
  	0,0,612,614,1,0,0,0,613,615,5,296,0,0,614,613,1,0,0,0,614,615,1,0,0,0,
  	615,617,1,0,0,0,616,618,5,274,0,0,617,616,1,0,0,0,617,618,1,0,0,0,618,
  	620,1,0,0,0,619,621,5,295,0,0,620,619,1,0,0,0,620,621,1,0,0,0,621,622,
  	1,0,0,0,622,624,5,285,0,0,623,625,5,295,0,0,624,623,1,0,0,0,624,625,1,
  	0,0,0,625,627,1,0,0,0,626,628,5,296,0,0,627,626,1,0,0,0,627,628,1,0,0,
  	0,628,630,1,0,0,0,629,631,5,274,0,0,630,629,1,0,0,0,630,631,1,0,0,0,631,
  	635,1,0,0,0,632,634,5,295,0,0,633,632,1,0,0,0,634,637,1,0,0,0,635,636,
  	1,0,0,0,635,633,1,0,0,0,636,639,1,0,0,0,637,635,1,0,0,0,638,640,7,6,0,
  	0,639,638,1,0,0,0,639,640,1,0,0,0,640,641,1,0,0,0,641,643,3,162,81,0,
  	642,644,5,295,0,0,643,642,1,0,0,0,643,644,1,0,0,0,644,646,1,0,0,0,645,
  	647,5,296,0,0,646,645,1,0,0,0,646,647,1,0,0,0,647,649,1,0,0,0,648,600,
  	1,0,0,0,649,652,1,0,0,0,650,648,1,0,0,0,650,651,1,0,0,0,651,656,1,0,0,
  	0,652,650,1,0,0,0,653,655,5,295,0,0,654,653,1,0,0,0,655,658,1,0,0,0,656,
  	654,1,0,0,0,656,657,1,0,0,0,657,659,1,0,0,0,658,656,1,0,0,0,659,660,5,
  	296,0,0,660,45,1,0,0,0,661,662,3,48,24,0,662,663,3,176,88,0,663,664,7,
  	7,0,0,664,667,1,0,0,0,665,667,3,50,25,0,666,661,1,0,0,0,666,665,1,0,0,
  	0,667,47,1,0,0,0,668,675,5,36,0,0,669,674,3,52,26,0,670,674,5,295,0,0,
  	671,674,5,296,0,0,672,674,5,274,0,0,673,669,1,0,0,0,673,670,1,0,0,0,673,
  	671,1,0,0,0,673,672,1,0,0,0,674,677,1,0,0,0,675,673,1,0,0,0,675,676,1,
  	0,0,0,676,678,1,0,0,0,677,675,1,0,0,0,678,680,5,293,0,0,679,681,5,295,
  	0,0,680,679,1,0,0,0,680,681,1,0,0,0,681,682,1,0,0,0,682,683,3,54,27,0,
  	683,684,5,296,0,0,684,49,1,0,0,0,685,686,5,36,0,0,686,687,5,295,0,0,687,
  	694,5,101,0,0,688,693,3,52,26,0,689,693,5,295,0,0,690,693,5,296,0,0,691,
  	693,5,274,0,0,692,688,1,0,0,0,692,689,1,0,0,0,692,690,1,0,0,0,692,691,
  	1,0,0,0,693,696,1,0,0,0,694,692,1,0,0,0,694,695,1,0,0,0,695,697,1,0,0,
  	0,696,694,1,0,0,0,697,699,5,293,0,0,698,700,5,295,0,0,699,698,1,0,0,0,
  	699,700,1,0,0,0,700,701,1,0,0,0,701,702,3,54,27,0,702,703,5,296,0,0,703,
  	51,1,0,0,0,704,711,5,25,0,0,705,711,5,30,0,0,706,711,5,29,0,0,707,711,
  	5,293,0,0,708,711,5,277,0,0,709,711,3,20,10,0,710,704,1,0,0,0,710,705,
  	1,0,0,0,710,706,1,0,0,0,710,707,1,0,0,0,710,708,1,0,0,0,710,709,1,0,0,
  	0,711,725,1,0,0,0,712,715,5,232,0,0,713,714,5,295,0,0,714,716,7,8,0,0,
  	715,713,1,0,0,0,715,716,1,0,0,0,716,717,1,0,0,0,717,718,5,295,0,0,718,
  	725,5,274,0,0,719,721,7,9,0,0,720,719,1,0,0,0,721,722,1,0,0,0,722,720,
  	1,0,0,0,722,723,1,0,0,0,723,725,1,0,0,0,724,710,1,0,0,0,724,712,1,0,0,
  	0,724,720,1,0,0,0,725,53,1,0,0,0,726,752,3,162,81,0,727,752,5,295,0,0,
  	728,752,5,274,0,0,729,752,5,296,0,0,730,752,5,244,0,0,731,752,5,245,0,
  	0,732,752,5,90,0,0,733,752,5,204,0,0,734,752,5,225,0,0,735,752,5,224,
  	0,0,736,752,5,228,0,0,737,752,5,220,0,0,738,752,5,222,0,0,739,752,5,223,
  	0,0,740,752,5,226,0,0,741,752,5,23,0,0,742,752,5,230,0,0,743,752,5,301,
  	0,0,744,752,5,49,0,0,745,752,5,211,0,0,746,752,5,116,0,0,747,752,5,117,
  	0,0,748,752,5,227,0,0,749,752,3,200,100,0,750,752,3,166,83,0,751,726,
  	1,0,0,0,751,727,1,0,0,0,751,728,1,0,0,0,751,729,1,0,0,0,751,730,1,0,0,
  	0,751,731,1,0,0,0,751,732,1,0,0,0,751,733,1,0,0,0,751,734,1,0,0,0,751,
  	735,1,0,0,0,751,736,1,0,0,0,751,737,1,0,0,0,751,738,1,0,0,0,751,739,1,
  	0,0,0,751,740,1,0,0,0,751,741,1,0,0,0,751,742,1,0,0,0,751,743,1,0,0,0,
  	751,744,1,0,0,0,751,745,1,0,0,0,751,746,1,0,0,0,751,747,1,0,0,0,751,748,
  	1,0,0,0,751,749,1,0,0,0,751,750,1,0,0,0,752,755,1,0,0,0,753,751,1,0,0,
  	0,753,754,1,0,0,0,754,55,1,0,0,0,755,753,1,0,0,0,756,757,3,58,29,0,757,
  	758,3,176,88,0,758,759,7,10,0,0,759,57,1,0,0,0,760,767,5,35,0,0,761,766,
  	3,60,30,0,762,766,5,295,0,0,763,766,5,296,0,0,764,766,5,274,0,0,765,761,
  	1,0,0,0,765,762,1,0,0,0,765,763,1,0,0,0,765,764,1,0,0,0,766,769,1,0,0,
  	0,767,765,1,0,0,0,767,768,1,0,0,0,768,770,1,0,0,0,769,767,1,0,0,0,770,
  	772,5,293,0,0,771,773,5,295,0,0,772,771,1,0,0,0,772,773,1,0,0,0,773,774,
  	1,0,0,0,774,775,3,62,31,0,775,776,5,296,0,0,776,59,1,0,0,0,777,782,5,
  	29,0,0,778,782,5,293,0,0,779,782,5,277,0,0,780,782,3,20,10,0,781,777,
  	1,0,0,0,781,778,1,0,0,0,781,779,1,0,0,0,781,780,1,0,0,0,782,796,1,0,0,
  	0,783,786,5,232,0,0,784,785,5,295,0,0,785,787,7,8,0,0,786,784,1,0,0,0,
  	786,787,1,0,0,0,787,788,1,0,0,0,788,789,5,295,0,0,789,796,5,274,0,0,790,
  	792,7,9,0,0,791,790,1,0,0,0,792,793,1,0,0,0,793,791,1,0,0,0,793,794,1,
  	0,0,0,794,796,1,0,0,0,795,781,1,0,0,0,795,783,1,0,0,0,795,791,1,0,0,0,
  	796,61,1,0,0,0,797,830,3,162,81,0,798,830,5,295,0,0,799,830,5,274,0,0,
  	800,830,5,296,0,0,801,830,5,244,0,0,802,830,5,245,0,0,803,830,5,90,0,
  	0,804,830,5,247,0,0,805,830,5,224,0,0,806,830,5,223,0,0,807,830,5,220,
  	0,0,808,830,5,249,0,0,809,830,5,250,0,0,810,830,5,251,0,0,811,830,5,23,
  	0,0,812,830,5,230,0,0,813,830,5,301,0,0,814,830,5,49,0,0,815,830,5,211,
  	0,0,816,830,5,116,0,0,817,830,5,117,0,0,818,830,5,81,0,0,819,830,5,248,
  	0,0,820,830,5,229,0,0,821,830,5,235,0,0,822,830,5,236,0,0,823,830,5,237,
  	0,0,824,830,5,233,0,0,825,830,5,234,0,0,826,830,5,227,0,0,827,830,3,200,
  	100,0,828,830,3,166,83,0,829,797,1,0,0,0,829,798,1,0,0,0,829,799,1,0,
  	0,0,829,800,1,0,0,0,829,801,1,0,0,0,829,802,1,0,0,0,829,803,1,0,0,0,829,
  	804,1,0,0,0,829,805,1,0,0,0,829,806,1,0,0,0,829,807,1,0,0,0,829,808,1,
  	0,0,0,829,809,1,0,0,0,829,810,1,0,0,0,829,811,1,0,0,0,829,812,1,0,0,0,
  	829,813,1,0,0,0,829,814,1,0,0,0,829,815,1,0,0,0,829,816,1,0,0,0,829,817,
  	1,0,0,0,829,818,1,0,0,0,829,819,1,0,0,0,829,820,1,0,0,0,829,821,1,0,0,
  	0,829,822,1,0,0,0,829,823,1,0,0,0,829,824,1,0,0,0,829,825,1,0,0,0,829,
  	826,1,0,0,0,829,827,1,0,0,0,829,828,1,0,0,0,830,833,1,0,0,0,831,829,1,
  	0,0,0,831,832,1,0,0,0,832,63,1,0,0,0,833,831,1,0,0,0,834,836,3,66,33,
  	0,835,837,7,11,0,0,836,835,1,0,0,0,837,838,1,0,0,0,838,836,1,0,0,0,838,
  	839,1,0,0,0,839,841,1,0,0,0,840,842,7,12,0,0,841,840,1,0,0,0,841,842,
  	1,0,0,0,842,860,1,0,0,0,843,861,5,295,0,0,844,861,5,296,0,0,845,861,5,
  	274,0,0,846,848,3,162,81,0,847,849,5,295,0,0,848,847,1,0,0,0,848,849,
  	1,0,0,0,849,851,1,0,0,0,850,852,5,273,0,0,851,850,1,0,0,0,851,852,1,0,
  	0,0,852,853,1,0,0,0,853,855,5,285,0,0,854,856,5,295,0,0,855,854,1,0,0,
  	0,855,856,1,0,0,0,856,857,1,0,0,0,857,858,3,162,81,0,858,861,1,0,0,0,
  	859,861,3,196,98,0,860,843,1,0,0,0,860,844,1,0,0,0,860,845,1,0,0,0,860,
  	846,1,0,0,0,860,859,1,0,0,0,861,862,1,0,0,0,862,860,1,0,0,0,862,863,1,
  	0,0,0,863,865,1,0,0,0,864,866,5,295,0,0,865,864,1,0,0,0,865,866,1,0,0,
  	0,866,867,1,0,0,0,867,868,5,296,0,0,868,888,1,0,0,0,869,870,3,66,33,0,
  	870,871,5,295,0,0,871,872,5,66,0,0,872,873,5,295,0,0,873,874,5,87,0,0,
  	874,875,5,295,0,0,875,877,5,83,0,0,876,878,5,295,0,0,877,876,1,0,0,0,
  	877,878,1,0,0,0,878,879,1,0,0,0,879,880,5,296,0,0,880,888,1,0,0,0,881,
  	883,3,66,33,0,882,884,5,295,0,0,883,882,1,0,0,0,883,884,1,0,0,0,884,885,
  	1,0,0,0,885,886,5,296,0,0,886,888,1,0,0,0,887,834,1,0,0,0,887,869,1,0,
  	0,0,887,881,1,0,0,0,888,65,1,0,0,0,889,891,5,38,0,0,890,892,5,295,0,0,
  	891,890,1,0,0,0,891,892,1,0,0,0,892,894,1,0,0,0,893,895,5,83,0,0,894,
  	893,1,0,0,0,894,895,1,0,0,0,895,897,1,0,0,0,896,898,5,295,0,0,897,896,
  	1,0,0,0,897,898,1,0,0,0,898,900,1,0,0,0,899,901,5,81,0,0,900,899,1,0,
  	0,0,900,901,1,0,0,0,901,903,1,0,0,0,902,904,5,295,0,0,903,902,1,0,0,0,
  	903,904,1,0,0,0,904,906,1,0,0,0,905,907,5,85,0,0,906,905,1,0,0,0,906,
  	907,1,0,0,0,907,909,1,0,0,0,908,910,5,295,0,0,909,908,1,0,0,0,909,910,
  	1,0,0,0,910,912,1,0,0,0,911,913,7,3,0,0,912,911,1,0,0,0,912,913,1,0,0,
  	0,913,67,1,0,0,0,914,916,5,40,0,0,915,917,5,295,0,0,916,915,1,0,0,0,916,
  	917,1,0,0,0,917,919,1,0,0,0,918,920,5,277,0,0,919,918,1,0,0,0,919,920,
  	1,0,0,0,920,69,1,0,0,0,921,925,3,72,36,0,922,925,3,76,38,0,923,925,3,
  	78,39,0,924,921,1,0,0,0,924,922,1,0,0,0,924,923,1,0,0,0,925,71,1,0,0,
  	0,926,927,5,41,0,0,927,928,5,295,0,0,928,933,5,293,0,0,929,932,3,74,37,
  	0,930,932,5,295,0,0,931,929,1,0,0,0,931,930,1,0,0,0,932,935,1,0,0,0,933,
  	931,1,0,0,0,933,934,1,0,0,0,934,936,1,0,0,0,935,933,1,0,0,0,936,938,3,
  	20,10,0,937,939,5,295,0,0,938,937,1,0,0,0,938,939,1,0,0,0,939,940,1,0,
  	0,0,940,941,5,296,0,0,941,73,1,0,0,0,942,943,7,13,0,0,943,75,1,0,0,0,
  	944,946,5,88,0,0,945,947,7,14,0,0,946,945,1,0,0,0,947,948,1,0,0,0,948,
  	946,1,0,0,0,948,949,1,0,0,0,949,950,1,0,0,0,950,951,5,296,0,0,951,77,
  	1,0,0,0,952,957,5,89,0,0,953,955,5,295,0,0,954,953,1,0,0,0,954,955,1,
  	0,0,0,955,956,1,0,0,0,956,958,5,277,0,0,957,954,1,0,0,0,957,958,1,0,0,
  	0,958,962,1,0,0,0,959,961,7,15,0,0,960,959,1,0,0,0,961,964,1,0,0,0,962,
  	960,1,0,0,0,962,963,1,0,0,0,963,965,1,0,0,0,964,962,1,0,0,0,965,966,5,
  	296,0,0,966,79,1,0,0,0,967,971,3,82,41,0,968,970,3,4,2,0,969,968,1,0,
  	0,0,970,973,1,0,0,0,971,969,1,0,0,0,971,972,1,0,0,0,972,974,1,0,0,0,973,
  	971,1,0,0,0,974,975,7,16,0,0,975,81,1,0,0,0,976,978,5,206,0,0,977,979,
  	5,295,0,0,978,977,1,0,0,0,978,979,1,0,0,0,979,986,1,0,0,0,980,985,3,84,
  	42,0,981,985,5,295,0,0,982,985,5,296,0,0,983,985,5,274,0,0,984,980,1,
  	0,0,0,984,981,1,0,0,0,984,982,1,0,0,0,984,983,1,0,0,0,985,988,1,0,0,0,
  	986,984,1,0,0,0,986,987,1,0,0,0,987,989,1,0,0,0,988,986,1,0,0,0,989,993,
  	5,293,0,0,990,992,5,295,0,0,991,990,1,0,0,0,992,995,1,0,0,0,993,991,1,
  	0,0,0,993,994,1,0,0,0,994,997,1,0,0,0,995,993,1,0,0,0,996,998,5,296,0,
  	0,997,996,1,0,0,0,997,998,1,0,0,0,998,999,1,0,0,0,999,1000,3,86,43,0,
  	1000,83,1,0,0,0,1001,1015,7,17,0,0,1002,1005,5,232,0,0,1003,1004,5,295,
  	0,0,1004,1006,7,8,0,0,1005,1003,1,0,0,0,1005,1006,1,0,0,0,1006,1007,1,
  	0,0,0,1007,1008,5,295,0,0,1008,1015,5,274,0,0,1009,1011,7,18,0,0,1010,
  	1009,1,0,0,0,1011,1012,1,0,0,0,1012,1010,1,0,0,0,1012,1013,1,0,0,0,1013,
  	1015,1,0,0,0,1014,1001,1,0,0,0,1014,1002,1,0,0,0,1014,1010,1,0,0,0,1015,
  	85,1,0,0,0,1016,1046,3,162,81,0,1017,1046,5,277,0,0,1018,1046,5,295,0,
  	0,1019,1046,5,274,0,0,1020,1046,5,296,0,0,1021,1046,5,244,0,0,1022,1046,
  	5,29,0,0,1023,1046,5,211,0,0,1024,1046,5,90,0,0,1025,1046,5,23,0,0,1026,
  	1046,5,81,0,0,1027,1046,5,63,0,0,1028,1046,5,22,0,0,1029,1046,5,115,0,
  	0,1030,1046,5,218,0,0,1031,1046,5,219,0,0,1032,1046,5,231,0,0,1033,1046,
  	5,229,0,0,1034,1046,5,230,0,0,1035,1046,5,235,0,0,1036,1046,5,236,0,0,
  	1037,1046,5,237,0,0,1038,1046,5,249,0,0,1039,1046,5,224,0,0,1040,1046,
  	5,233,0,0,1041,1046,5,234,0,0,1042,1046,5,223,0,0,1043,1046,3,200,100,
  	0,1044,1046,3,166,83,0,1045,1016,1,0,0,0,1045,1017,1,0,0,0,1045,1018,
  	1,0,0,0,1045,1019,1,0,0,0,1045,1020,1,0,0,0,1045,1021,1,0,0,0,1045,1022,
  	1,0,0,0,1045,1023,1,0,0,0,1045,1024,1,0,0,0,1045,1025,1,0,0,0,1045,1026,
  	1,0,0,0,1045,1027,1,0,0,0,1045,1028,1,0,0,0,1045,1029,1,0,0,0,1045,1030,
  	1,0,0,0,1045,1031,1,0,0,0,1045,1032,1,0,0,0,1045,1033,1,0,0,0,1045,1034,
  	1,0,0,0,1045,1035,1,0,0,0,1045,1036,1,0,0,0,1045,1037,1,0,0,0,1045,1038,
  	1,0,0,0,1045,1039,1,0,0,0,1045,1040,1,0,0,0,1045,1041,1,0,0,0,1045,1042,
  	1,0,0,0,1045,1043,1,0,0,0,1045,1044,1,0,0,0,1046,1049,1,0,0,0,1047,1045,
  	1,0,0,0,1047,1048,1,0,0,0,1048,1050,1,0,0,0,1049,1047,1,0,0,0,1050,1051,
  	3,162,81,0,1051,87,1,0,0,0,1052,1053,5,60,0,0,1053,89,1,0,0,0,1054,1055,
  	5,61,0,0,1055,91,1,0,0,0,1056,1057,7,19,0,0,1057,1058,5,295,0,0,1058,
  	1063,3,94,47,0,1059,1061,5,295,0,0,1060,1059,1,0,0,0,1060,1061,1,0,0,
  	0,1061,1062,1,0,0,0,1062,1064,5,241,0,0,1063,1060,1,0,0,0,1063,1064,1,
  	0,0,0,1064,1065,1,0,0,0,1065,1066,3,96,48,0,1066,1067,3,98,49,0,1067,
  	1103,1,0,0,0,1068,1069,7,19,0,0,1069,1070,5,295,0,0,1070,1075,3,94,47,
  	0,1071,1073,5,295,0,0,1072,1071,1,0,0,0,1072,1073,1,0,0,0,1073,1074,1,
  	0,0,0,1074,1076,5,241,0,0,1075,1072,1,0,0,0,1075,1076,1,0,0,0,1076,1077,
  	1,0,0,0,1077,1079,3,96,48,0,1078,1080,3,4,2,0,1079,1078,1,0,0,0,1080,
  	1081,1,0,0,0,1081,1079,1,0,0,0,1081,1082,1,0,0,0,1082,1083,1,0,0,0,1083,
  	1084,5,62,0,0,1084,1103,1,0,0,0,1085,1086,7,19,0,0,1086,1087,5,295,0,
  	0,1087,1092,3,94,47,0,1088,1090,5,295,0,0,1089,1088,1,0,0,0,1089,1090,
  	1,0,0,0,1090,1091,1,0,0,0,1091,1093,5,241,0,0,1092,1089,1,0,0,0,1092,
  	1093,1,0,0,0,1093,1094,1,0,0,0,1094,1096,3,96,48,0,1095,1097,3,4,2,0,
  	1096,1095,1,0,0,0,1097,1098,1,0,0,0,1098,1096,1,0,0,0,1098,1099,1,0,0,
  	0,1099,1100,1,0,0,0,1100,1101,7,20,0,0,1101,1103,1,0,0,0,1102,1056,1,
  	0,0,0,1102,1068,1,0,0,0,1102,1085,1,0,0,0,1103,93,1,0,0,0,1104,1105,5,
  	274,0,0,1105,95,1,0,0,0,1106,1119,3,162,81,0,1107,1119,5,277,0,0,1108,
  	1119,5,295,0,0,1109,1119,5,274,0,0,1110,1119,5,296,0,0,1111,1119,5,83,
  	0,0,1112,1119,5,240,0,0,1113,1119,5,239,0,0,1114,1119,5,301,0,0,1115,
  	1119,5,37,0,0,1116,1119,5,96,0,0,1117,1119,5,100,0,0,1118,1106,1,0,0,
  	0,1118,1107,1,0,0,0,1118,1108,1,0,0,0,1118,1109,1,0,0,0,1118,1110,1,0,
  	0,0,1118,1111,1,0,0,0,1118,1112,1,0,0,0,1118,1113,1,0,0,0,1118,1114,1,
  	0,0,0,1118,1115,1,0,0,0,1118,1116,1,0,0,0,1118,1117,1,0,0,0,1119,1122,
  	1,0,0,0,1120,1118,1,0,0,0,1120,1121,1,0,0,0,1121,97,1,0,0,0,1122,1120,
  	1,0,0,0,1123,1127,5,242,0,0,1124,1126,3,4,2,0,1125,1124,1,0,0,0,1126,
  	1129,1,0,0,0,1127,1125,1,0,0,0,1127,1128,1,0,0,0,1128,1130,1,0,0,0,1129,
  	1127,1,0,0,0,1130,1131,5,243,0,0,1131,99,1,0,0,0,1132,1133,7,21,0,0,1133,
  	1134,5,295,0,0,1134,1139,3,94,47,0,1135,1137,5,295,0,0,1136,1135,1,0,
  	0,0,1136,1137,1,0,0,0,1137,1138,1,0,0,0,1138,1140,5,235,0,0,1139,1136,
  	1,0,0,0,1139,1140,1,0,0,0,1140,1147,1,0,0,0,1141,1146,3,162,81,0,1142,
  	1146,5,274,0,0,1143,1146,5,295,0,0,1144,1146,5,296,0,0,1145,1141,1,0,
  	0,0,1145,1142,1,0,0,0,1145,1143,1,0,0,0,1145,1144,1,0,0,0,1146,1149,1,
  	0,0,0,1147,1145,1,0,0,0,1147,1148,1,0,0,0,1148,1150,1,0,0,0,1149,1147,
  	1,0,0,0,1150,1151,5,296,0,0,1151,101,1,0,0,0,1152,1153,7,22,0,0,1153,
  	1154,5,295,0,0,1154,1155,3,94,47,0,1155,103,1,0,0,0,1156,1157,5,14,0,
  	0,1157,1158,5,295,0,0,1158,1162,7,23,0,0,1159,1161,3,4,2,0,1160,1159,
  	1,0,0,0,1161,1164,1,0,0,0,1162,1160,1,0,0,0,1162,1163,1,0,0,0,1163,1165,
  	1,0,0,0,1164,1162,1,0,0,0,1165,1166,5,75,0,0,1166,105,1,0,0,0,1167,1169,
  	5,179,0,0,1168,1170,5,295,0,0,1169,1168,1,0,0,0,1169,1170,1,0,0,0,1170,
  	1172,1,0,0,0,1171,1173,5,293,0,0,1172,1171,1,0,0,0,1172,1173,1,0,0,0,
  	1173,1175,1,0,0,0,1174,1176,5,296,0,0,1175,1174,1,0,0,0,1175,1176,1,0,
  	0,0,1176,1179,1,0,0,0,1177,1178,5,50,0,0,1178,1180,5,295,0,0,1179,1177,
  	1,0,0,0,1179,1180,1,0,0,0,1180,1184,1,0,0,0,1181,1183,3,4,2,0,1182,1181,
  	1,0,0,0,1183,1186,1,0,0,0,1184,1182,1,0,0,0,1184,1185,1,0,0,0,1185,1187,
  	1,0,0,0,1186,1184,1,0,0,0,1187,1188,7,24,0,0,1188,107,1,0,0,0,1189,1208,
  	3,110,55,0,1190,1192,5,295,0,0,1191,1190,1,0,0,0,1192,1195,1,0,0,0,1193,
  	1194,1,0,0,0,1193,1191,1,0,0,0,1194,1196,1,0,0,0,1195,1193,1,0,0,0,1196,
  	1198,3,112,56,0,1197,1199,5,295,0,0,1198,1197,1,0,0,0,1198,1199,1,0,0,
  	0,1199,1201,1,0,0,0,1200,1202,5,296,0,0,1201,1200,1,0,0,0,1201,1202,1,
  	0,0,0,1202,1204,1,0,0,0,1203,1205,5,274,0,0,1204,1203,1,0,0,0,1204,1205,
  	1,0,0,0,1205,1207,1,0,0,0,1206,1193,1,0,0,0,1207,1210,1,0,0,0,1208,1206,
  	1,0,0,0,1208,1209,1,0,0,0,1209,109,1,0,0,0,1210,1208,1,0,0,0,1211,1213,
  	5,128,0,0,1212,1214,5,295,0,0,1213,1212,1,0,0,0,1213,1214,1,0,0,0,1214,
  	1215,1,0,0,0,1215,1218,5,277,0,0,1216,1218,5,128,0,0,1217,1211,1,0,0,
  	0,1217,1216,1,0,0,0,1218,111,1,0,0,0,1219,1220,5,293,0,0,1220,1221,3,
  	200,100,0,1221,1222,7,25,0,0,1222,113,1,0,0,0,1223,1227,5,194,0,0,1224,
  	1226,5,295,0,0,1225,1224,1,0,0,0,1226,1229,1,0,0,0,1227,1228,1,0,0,0,
  	1227,1225,1,0,0,0,1228,1230,1,0,0,0,1229,1227,1,0,0,0,1230,1232,5,293,
  	0,0,1231,1233,5,295,0,0,1232,1231,1,0,0,0,1232,1233,1,0,0,0,1233,1235,
  	1,0,0,0,1234,1236,5,296,0,0,1235,1234,1,0,0,0,1235,1236,1,0,0,0,1236,
  	1238,1,0,0,0,1237,1239,5,274,0,0,1238,1237,1,0,0,0,1238,1239,1,0,0,0,
  	1239,115,1,0,0,0,1240,1242,5,8,0,0,1241,1243,5,295,0,0,1242,1241,1,0,
  	0,0,1242,1243,1,0,0,0,1243,1244,1,0,0,0,1244,1245,3,118,59,0,1245,117,
  	1,0,0,0,1246,1250,7,26,0,0,1247,1250,5,295,0,0,1248,1250,5,296,0,0,1249,
  	1246,1,0,0,0,1249,1247,1,0,0,0,1249,1248,1,0,0,0,1250,1253,1,0,0,0,1251,
  	1249,1,0,0,0,1251,1252,1,0,0,0,1252,1254,1,0,0,0,1253,1251,1,0,0,0,1254,
  	1255,5,296,0,0,1255,119,1,0,0,0,1256,1258,5,70,0,0,1257,1259,5,295,0,
  	0,1258,1257,1,0,0,0,1258,1259,1,0,0,0,1259,1260,1,0,0,0,1260,1261,3,118,
  	59,0,1261,121,1,0,0,0,1262,1264,5,10,0,0,1263,1265,5,295,0,0,1264,1263,
  	1,0,0,0,1264,1265,1,0,0,0,1265,1266,1,0,0,0,1266,1268,5,272,0,0,1267,
  	1269,5,295,0,0,1268,1267,1,0,0,0,1268,1269,1,0,0,0,1269,1276,1,0,0,0,
  	1270,1275,3,20,10,0,1271,1275,5,295,0,0,1272,1275,5,296,0,0,1273,1275,
  	5,274,0,0,1274,1270,1,0,0,0,1274,1271,1,0,0,0,1274,1272,1,0,0,0,1274,
  	1273,1,0,0,0,1275,1278,1,0,0,0,1276,1274,1,0,0,0,1276,1277,1,0,0,0,1277,
  	1279,1,0,0,0,1278,1276,1,0,0,0,1279,1280,5,296,0,0,1280,123,1,0,0,0,1281,
  	1285,5,71,0,0,1282,1284,5,295,0,0,1283,1282,1,0,0,0,1284,1287,1,0,0,0,
  	1285,1283,1,0,0,0,1285,1286,1,0,0,0,1286,125,1,0,0,0,1287,1285,1,0,0,
  	0,1288,1290,5,9,0,0,1289,1291,5,295,0,0,1290,1289,1,0,0,0,1290,1291,1,
  	0,0,0,1291,1292,1,0,0,0,1292,1301,3,128,64,0,1293,1295,5,295,0,0,1294,
  	1293,1,0,0,0,1294,1295,1,0,0,0,1295,1296,1,0,0,0,1296,1298,5,66,0,0,1297,
  	1299,5,295,0,0,1298,1297,1,0,0,0,1298,1299,1,0,0,0,1299,1300,1,0,0,0,
  	1300,1302,3,20,10,0,1301,1294,1,0,0,0,1301,1302,1,0,0,0,1302,127,1,0,
  	0,0,1303,1304,7,27,0,0,1304,129,1,0,0,0,1305,1308,5,147,0,0,1306,1307,
  	5,295,0,0,1307,1309,7,28,0,0,1308,1306,1,0,0,0,1308,1309,1,0,0,0,1309,
  	1311,1,0,0,0,1310,1312,5,295,0,0,1311,1310,1,0,0,0,1311,1312,1,0,0,0,
  	1312,1313,1,0,0,0,1313,1323,5,272,0,0,1314,1316,7,1,0,0,1315,1314,1,0,
  	0,0,1316,1319,1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,0,1318,1320,1,
  	0,0,0,1319,1317,1,0,0,0,1320,1322,7,29,0,0,1321,1317,1,0,0,0,1322,1325,
  	1,0,0,0,1323,1321,1,0,0,0,1323,1324,1,0,0,0,1324,131,1,0,0,0,1325,1323,
  	1,0,0,0,1326,1329,5,144,0,0,1327,1328,5,295,0,0,1328,1330,5,221,0,0,1329,
  	1327,1,0,0,0,1329,1330,1,0,0,0,1330,1332,1,0,0,0,1331,1333,5,295,0,0,
  	1332,1331,1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,1339,5,272,
  	0,0,1335,1337,5,295,0,0,1336,1335,1,0,0,0,1336,1337,1,0,0,0,1337,1338,
  	1,0,0,0,1338,1340,5,66,0,0,1339,1336,1,0,0,0,1339,1340,1,0,0,0,1340,1350,
  	1,0,0,0,1341,1343,7,1,0,0,1342,1341,1,0,0,0,1343,1346,1,0,0,0,1344,1342,
  	1,0,0,0,1344,1345,1,0,0,0,1345,1347,1,0,0,0,1346,1344,1,0,0,0,1347,1349,
  	7,29,0,0,1348,1344,1,0,0,0,1349,1352,1,0,0,0,1350,1348,1,0,0,0,1350,1351,
  	1,0,0,0,1351,1354,1,0,0,0,1352,1350,1,0,0,0,1353,1355,5,295,0,0,1354,
  	1353,1,0,0,0,1354,1355,1,0,0,0,1355,1356,1,0,0,0,1356,1357,5,296,0,0,
  	1357,133,1,0,0,0,1358,1359,5,22,0,0,1359,1360,5,295,0,0,1360,1361,3,158,
  	79,0,1361,1362,5,49,0,0,1362,1363,5,295,0,0,1363,1367,3,162,81,0,1364,
  	1366,3,4,2,0,1365,1364,1,0,0,0,1366,1369,1,0,0,0,1367,1365,1,0,0,0,1367,
  	1368,1,0,0,0,1368,1370,1,0,0,0,1369,1367,1,0,0,0,1370,1371,7,30,0,0,1371,
  	135,1,0,0,0,1372,1374,7,31,0,0,1373,1375,5,295,0,0,1374,1373,1,0,0,0,
  	1374,1375,1,0,0,0,1375,1376,1,0,0,0,1376,1377,3,158,79,0,1377,137,1,0,
  	0,0,1378,1380,7,32,0,0,1379,1381,5,295,0,0,1380,1379,1,0,0,0,1380,1381,
  	1,0,0,0,1381,1382,1,0,0,0,1382,1396,7,33,0,0,1383,1385,5,295,0,0,1384,
  	1386,5,26,0,0,1385,1384,1,0,0,0,1385,1386,1,0,0,0,1386,1388,1,0,0,0,1387,
  	1389,5,295,0,0,1388,1387,1,0,0,0,1388,1389,1,0,0,0,1389,1391,1,0,0,0,
  	1390,1392,5,296,0,0,1391,1390,1,0,0,0,1391,1392,1,0,0,0,1392,1394,1,0,
  	0,0,1393,1395,5,274,0,0,1394,1393,1,0,0,0,1394,1395,1,0,0,0,1395,1397,
  	1,0,0,0,1396,1383,1,0,0,0,1396,1397,1,0,0,0,1397,1399,1,0,0,0,1398,1400,
  	7,34,0,0,1399,1398,1,0,0,0,1399,1400,1,0,0,0,1400,1402,1,0,0,0,1401,1403,
  	5,295,0,0,1402,1401,1,0,0,0,1402,1403,1,0,0,0,1403,1405,1,0,0,0,1404,
  	1406,5,21,0,0,1405,1404,1,0,0,0,1405,1406,1,0,0,0,1406,1407,1,0,0,0,1407,
  	1408,5,295,0,0,1408,1412,5,293,0,0,1409,1411,3,4,2,0,1410,1409,1,0,0,
  	0,1411,1414,1,0,0,0,1412,1410,1,0,0,0,1412,1413,1,0,0,0,1413,1415,1,0,
  	0,0,1414,1412,1,0,0,0,1415,1416,5,20,0,0,1416,139,1,0,0,0,1417,1423,3,
  	142,71,0,1418,1423,3,146,73,0,1419,1423,3,148,74,0,1420,1423,3,150,75,
  	0,1421,1423,3,136,68,0,1422,1417,1,0,0,0,1422,1418,1,0,0,0,1422,1419,
  	1,0,0,0,1422,1420,1,0,0,0,1422,1421,1,0,0,0,1423,141,1,0,0,0,1424,1425,
  	5,14,0,0,1425,1426,5,295,0,0,1426,1430,3,158,79,0,1427,1429,7,1,0,0,1428,
  	1427,1,0,0,0,1429,1432,1,0,0,0,1430,1428,1,0,0,0,1430,1431,1,0,0,0,1431,
  	1434,1,0,0,0,1432,1430,1,0,0,0,1433,1435,5,15,0,0,1434,1433,1,0,0,0,1434,
  	1435,1,0,0,0,1435,1437,1,0,0,0,1436,1438,3,4,2,0,1437,1436,1,0,0,0,1438,
  	1439,1,0,0,0,1439,1437,1,0,0,0,1439,1440,1,0,0,0,1440,1443,1,0,0,0,1441,
  	1444,5,18,0,0,1442,1444,3,144,72,0,1443,1441,1,0,0,0,1443,1442,1,0,0,
  	0,1444,143,1,0,0,0,1445,1449,5,16,0,0,1446,1448,3,4,2,0,1447,1446,1,0,
  	0,0,1448,1451,1,0,0,0,1449,1447,1,0,0,0,1449,1450,1,0,0,0,1450,1452,1,
  	0,0,0,1451,1449,1,0,0,0,1452,1453,5,18,0,0,1453,145,1,0,0,0,1454,1455,
  	5,14,0,0,1455,1456,5,295,0,0,1456,1463,3,158,79,0,1457,1464,5,295,0,0,
  	1458,1460,5,296,0,0,1459,1461,5,274,0,0,1460,1459,1,0,0,0,1460,1461,1,
  	0,0,0,1461,1462,1,0,0,0,1462,1464,5,295,0,0,1463,1457,1,0,0,0,1463,1458,
  	1,0,0,0,1464,1466,1,0,0,0,1465,1467,5,15,0,0,1466,1465,1,0,0,0,1466,1467,
  	1,0,0,0,1467,1474,1,0,0,0,1468,1475,5,295,0,0,1469,1471,5,296,0,0,1470,
  	1472,5,274,0,0,1471,1470,1,0,0,0,1471,1472,1,0,0,0,1472,1473,1,0,0,0,
  	1473,1475,5,295,0,0,1474,1468,1,0,0,0,1474,1469,1,0,0,0,1474,1475,1,0,
  	0,0,1475,1476,1,0,0,0,1476,1483,3,38,19,0,1477,1484,5,295,0,0,1478,1480,
  	5,296,0,0,1479,1481,5,274,0,0,1480,1479,1,0,0,0,1480,1481,1,0,0,0,1481,
  	1482,1,0,0,0,1482,1484,5,295,0,0,1483,1477,1,0,0,0,1483,1478,1,0,0,0,
  	1484,1487,1,0,0,0,1485,1488,3,152,76,0,1486,1488,3,154,77,0,1487,1485,
  	1,0,0,0,1487,1486,1,0,0,0,1488,147,1,0,0,0,1489,1490,5,14,0,0,1490,1491,
  	5,295,0,0,1491,1495,3,158,79,0,1492,1494,7,1,0,0,1493,1492,1,0,0,0,1494,
  	1497,1,0,0,0,1495,1493,1,0,0,0,1495,1496,1,0,0,0,1496,1498,1,0,0,0,1497,
  	1495,1,0,0,0,1498,1502,5,15,0,0,1499,1501,7,1,0,0,1500,1499,1,0,0,0,1501,
  	1504,1,0,0,0,1502,1500,1,0,0,0,1502,1503,1,0,0,0,1503,1505,1,0,0,0,1504,
  	1502,1,0,0,0,1505,1517,3,38,19,0,1506,1512,5,295,0,0,1507,1509,5,274,
  	0,0,1508,1507,1,0,0,0,1508,1509,1,0,0,0,1509,1510,1,0,0,0,1510,1512,5,
  	295,0,0,1511,1506,1,0,0,0,1511,1508,1,0,0,0,1512,1515,1,0,0,0,1513,1516,
  	3,152,76,0,1514,1516,3,154,77,0,1515,1513,1,0,0,0,1515,1514,1,0,0,0,1516,
  	1518,1,0,0,0,1517,1511,1,0,0,0,1517,1518,1,0,0,0,1518,149,1,0,0,0,1519,
  	1520,5,14,0,0,1520,1521,5,295,0,0,1521,1525,3,158,79,0,1522,1524,7,1,
  	0,0,1523,1522,1,0,0,0,1524,1527,1,0,0,0,1525,1523,1,0,0,0,1525,1526,1,
  	0,0,0,1526,1529,1,0,0,0,1527,1525,1,0,0,0,1528,1530,5,15,0,0,1529,1528,
  	1,0,0,0,1529,1530,1,0,0,0,1530,1534,1,0,0,0,1531,1533,7,1,0,0,1532,1531,
  	1,0,0,0,1533,1536,1,0,0,0,1534,1532,1,0,0,0,1534,1535,1,0,0,0,1535,1537,
  	1,0,0,0,1536,1534,1,0,0,0,1537,1548,3,156,78,0,1538,1540,7,1,0,0,1539,
  	1538,1,0,0,0,1540,1543,1,0,0,0,1541,1539,1,0,0,0,1541,1542,1,0,0,0,1542,
  	1546,1,0,0,0,1543,1541,1,0,0,0,1544,1547,3,152,76,0,1545,1547,3,154,77,
  	0,1546,1544,1,0,0,0,1546,1545,1,0,0,0,1547,1549,1,0,0,0,1548,1541,1,0,
  	0,0,1548,1549,1,0,0,0,1549,151,1,0,0,0,1550,1557,5,16,0,0,1551,1558,5,
  	295,0,0,1552,1554,5,296,0,0,1553,1555,5,274,0,0,1554,1553,1,0,0,0,1554,
  	1555,1,0,0,0,1555,1556,1,0,0,0,1556,1558,5,295,0,0,1557,1551,1,0,0,0,
  	1557,1552,1,0,0,0,1558,1559,1,0,0,0,1559,1560,3,38,19,0,1560,153,1,0,
  	0,0,1561,1568,5,16,0,0,1562,1569,5,295,0,0,1563,1565,5,296,0,0,1564,1566,
  	5,274,0,0,1565,1564,1,0,0,0,1565,1566,1,0,0,0,1566,1567,1,0,0,0,1567,
  	1569,5,295,0,0,1568,1562,1,0,0,0,1568,1563,1,0,0,0,1569,1570,1,0,0,0,
  	1570,1571,3,156,78,0,1571,155,1,0,0,0,1572,1574,5,274,0,0,1573,1572,1,
  	0,0,0,1573,1574,1,0,0,0,1574,1575,1,0,0,0,1575,1577,5,295,0,0,1576,1573,
  	1,0,0,0,1576,1577,1,0,0,0,1577,1578,1,0,0,0,1578,1579,3,4,2,0,1579,1580,
  	7,35,0,0,1580,1589,1,0,0,0,1581,1583,5,274,0,0,1582,1581,1,0,0,0,1582,
  	1583,1,0,0,0,1583,1584,1,0,0,0,1584,1586,5,295,0,0,1585,1582,1,0,0,0,
  	1585,1586,1,0,0,0,1586,1587,1,0,0,0,1587,1589,3,4,2,0,1588,1576,1,0,0,
  	0,1588,1585,1,0,0,0,1589,157,1,0,0,0,1590,1597,3,162,81,0,1591,1598,5,
  	295,0,0,1592,1594,5,296,0,0,1593,1595,5,274,0,0,1594,1593,1,0,0,0,1594,
  	1595,1,0,0,0,1595,1596,1,0,0,0,1596,1598,5,295,0,0,1597,1591,1,0,0,0,
  	1597,1592,1,0,0,0,1598,1602,1,0,0,0,1599,1603,3,166,83,0,1600,1603,3,
  	200,100,0,1601,1603,3,202,101,0,1602,1599,1,0,0,0,1602,1600,1,0,0,0,1602,
  	1601,1,0,0,0,1603,1610,1,0,0,0,1604,1611,5,295,0,0,1605,1607,5,296,0,
  	0,1606,1608,5,274,0,0,1607,1606,1,0,0,0,1607,1608,1,0,0,0,1608,1609,1,
  	0,0,0,1609,1611,5,295,0,0,1610,1604,1,0,0,0,1610,1605,1,0,0,0,1611,1612,
  	1,0,0,0,1612,1622,3,162,81,0,1613,1620,5,295,0,0,1614,1616,5,296,0,0,
  	1615,1617,5,274,0,0,1616,1615,1,0,0,0,1616,1617,1,0,0,0,1617,1618,1,0,
  	0,0,1618,1620,5,295,0,0,1619,1613,1,0,0,0,1619,1614,1,0,0,0,1619,1620,
  	1,0,0,0,1620,1621,1,0,0,0,1621,1623,3,160,80,0,1622,1619,1,0,0,0,1622,
  	1623,1,0,0,0,1623,1651,1,0,0,0,1624,1631,3,162,81,0,1625,1632,5,295,0,
  	0,1626,1628,5,296,0,0,1627,1629,5,274,0,0,1628,1627,1,0,0,0,1628,1629,
  	1,0,0,0,1629,1630,1,0,0,0,1630,1632,5,295,0,0,1631,1625,1,0,0,0,1631,
  	1626,1,0,0,0,1631,1632,1,0,0,0,1632,1634,1,0,0,0,1633,1635,3,160,80,0,
  	1634,1633,1,0,0,0,1634,1635,1,0,0,0,1635,1651,1,0,0,0,1636,1637,5,261,
  	0,0,1637,1638,5,295,0,0,1638,1645,3,162,81,0,1639,1646,5,295,0,0,1640,
  	1642,5,296,0,0,1641,1643,5,274,0,0,1642,1641,1,0,0,0,1642,1643,1,0,0,
  	0,1643,1644,1,0,0,0,1644,1646,5,295,0,0,1645,1639,1,0,0,0,1645,1640,1,
  	0,0,0,1645,1646,1,0,0,0,1646,1648,1,0,0,0,1647,1649,3,160,80,0,1648,1647,
  	1,0,0,0,1648,1649,1,0,0,0,1649,1651,1,0,0,0,1650,1590,1,0,0,0,1650,1624,
  	1,0,0,0,1650,1636,1,0,0,0,1651,159,1,0,0,0,1652,1656,3,166,83,0,1653,
  	1656,3,200,100,0,1654,1656,3,202,101,0,1655,1652,1,0,0,0,1655,1653,1,
  	0,0,0,1655,1654,1,0,0,0,1656,1663,1,0,0,0,1657,1664,5,295,0,0,1658,1660,
  	5,296,0,0,1659,1661,5,274,0,0,1660,1659,1,0,0,0,1660,1661,1,0,0,0,1661,
  	1662,1,0,0,0,1662,1664,5,295,0,0,1663,1657,1,0,0,0,1663,1658,1,0,0,0,
  	1664,1665,1,0,0,0,1665,1672,3,162,81,0,1666,1673,5,295,0,0,1667,1669,
  	5,296,0,0,1668,1670,5,274,0,0,1669,1668,1,0,0,0,1669,1670,1,0,0,0,1670,
  	1671,1,0,0,0,1671,1673,5,295,0,0,1672,1666,1,0,0,0,1672,1667,1,0,0,0,
  	1672,1673,1,0,0,0,1673,1675,1,0,0,0,1674,1676,3,160,80,0,1675,1674,1,
  	0,0,0,1675,1676,1,0,0,0,1676,161,1,0,0,0,1677,1690,3,20,10,0,1678,1690,
  	5,272,0,0,1679,1690,5,274,0,0,1680,1690,5,275,0,0,1681,1690,3,164,82,
  	0,1682,1683,5,291,0,0,1683,1684,3,162,81,0,1684,1685,5,292,0,0,1685,1690,
  	1,0,0,0,1686,1690,5,279,0,0,1687,1690,5,278,0,0,1688,1690,5,280,0,0,1689,
  	1677,1,0,0,0,1689,1678,1,0,0,0,1689,1679,1,0,0,0,1689,1680,1,0,0,0,1689,
  	1681,1,0,0,0,1689,1682,1,0,0,0,1689,1686,1,0,0,0,1689,1687,1,0,0,0,1689,
  	1688,1,0,0,0,1690,163,1,0,0,0,1691,1694,5,80,0,0,1692,1693,5,295,0,0,
  	1693,1695,5,277,0,0,1694,1692,1,0,0,0,1694,1695,1,0,0,0,1695,165,1,0,
  	0,0,1696,1697,7,36,0,0,1697,167,1,0,0,0,1698,1700,5,51,0,0,1699,1701,
  	5,295,0,0,1700,1699,1,0,0,0,1700,1701,1,0,0,0,1701,1702,1,0,0,0,1702,
  	1704,3,128,64,0,1703,1705,5,295,0,0,1704,1703,1,0,0,0,1704,1705,1,0,0,
  	0,1705,1706,1,0,0,0,1706,1707,3,170,85,0,1707,1708,7,37,0,0,1708,169,
  	1,0,0,0,1709,1713,3,172,86,0,1710,1713,5,295,0,0,1711,1713,5,296,0,0,
  	1712,1709,1,0,0,0,1712,1710,1,0,0,0,1712,1711,1,0,0,0,1713,1716,1,0,0,
  	0,1714,1712,1,0,0,0,1714,1715,1,0,0,0,1715,1718,1,0,0,0,1716,1714,1,0,
  	0,0,1717,1719,5,294,0,0,1718,1717,1,0,0,0,1718,1719,1,0,0,0,1719,171,
  	1,0,0,0,1720,1760,3,8,4,0,1721,1760,3,168,84,0,1722,1760,3,174,87,0,1723,
  	1760,3,178,89,0,1724,1760,3,134,67,0,1725,1760,3,140,70,0,1726,1760,3,
  	126,63,0,1727,1760,3,122,61,0,1728,1760,3,116,58,0,1729,1760,3,120,60,
  	0,1730,1760,3,28,14,0,1731,1760,3,32,16,0,1732,1760,3,46,23,0,1733,1760,
  	3,56,28,0,1734,1760,3,40,20,0,1735,1760,3,64,32,0,1736,1760,3,68,34,0,
  	1737,1760,3,70,35,0,1738,1760,3,80,40,0,1739,1760,3,88,44,0,1740,1760,
  	3,90,45,0,1741,1760,3,92,46,0,1742,1760,3,100,50,0,1743,1760,3,102,51,
  	0,1744,1760,3,14,7,0,1745,1760,3,22,11,0,1746,1760,3,196,98,0,1747,1760,
  	3,180,90,0,1748,1760,3,26,13,0,1749,1760,3,10,5,0,1750,1760,3,38,19,0,
  	1751,1760,3,36,18,0,1752,1760,3,106,53,0,1753,1760,3,108,54,0,1754,1760,
  	3,112,56,0,1755,1760,3,114,57,0,1756,1760,3,130,65,0,1757,1760,3,132,
  	66,0,1758,1760,3,206,103,0,1759,1720,1,0,0,0,1759,1721,1,0,0,0,1759,1722,
  	1,0,0,0,1759,1723,1,0,0,0,1759,1724,1,0,0,0,1759,1725,1,0,0,0,1759,1726,
  	1,0,0,0,1759,1727,1,0,0,0,1759,1728,1,0,0,0,1759,1729,1,0,0,0,1759,1730,
  	1,0,0,0,1759,1731,1,0,0,0,1759,1732,1,0,0,0,1759,1733,1,0,0,0,1759,1734,
  	1,0,0,0,1759,1735,1,0,0,0,1759,1736,1,0,0,0,1759,1737,1,0,0,0,1759,1738,
  	1,0,0,0,1759,1739,1,0,0,0,1759,1740,1,0,0,0,1759,1741,1,0,0,0,1759,1742,
  	1,0,0,0,1759,1743,1,0,0,0,1759,1744,1,0,0,0,1759,1745,1,0,0,0,1759,1746,
  	1,0,0,0,1759,1747,1,0,0,0,1759,1748,1,0,0,0,1759,1749,1,0,0,0,1759,1750,
  	1,0,0,0,1759,1751,1,0,0,0,1759,1752,1,0,0,0,1759,1753,1,0,0,0,1759,1754,
  	1,0,0,0,1759,1755,1,0,0,0,1759,1756,1,0,0,0,1759,1757,1,0,0,0,1759,1758,
  	1,0,0,0,1760,173,1,0,0,0,1761,1763,5,55,0,0,1762,1764,5,295,0,0,1763,
  	1762,1,0,0,0,1763,1764,1,0,0,0,1764,1765,1,0,0,0,1765,1767,5,293,0,0,
  	1766,1768,5,295,0,0,1767,1766,1,0,0,0,1767,1768,1,0,0,0,1768,1769,1,0,
  	0,0,1769,1771,5,3,0,0,1770,1772,5,295,0,0,1771,1770,1,0,0,0,1771,1772,
  	1,0,0,0,1772,1773,1,0,0,0,1773,1775,5,293,0,0,1774,1776,5,295,0,0,1775,
  	1774,1,0,0,0,1775,1776,1,0,0,0,1776,1777,1,0,0,0,1777,1779,3,176,88,0,
  	1778,1780,5,295,0,0,1779,1778,1,0,0,0,1779,1780,1,0,0,0,1780,1781,1,0,
  	0,0,1781,1782,5,56,0,0,1782,175,1,0,0,0,1783,1787,3,4,2,0,1784,1787,5,
  	295,0,0,1785,1787,5,296,0,0,1786,1783,1,0,0,0,1786,1784,1,0,0,0,1786,
  	1785,1,0,0,0,1787,1790,1,0,0,0,1788,1786,1,0,0,0,1788,1789,1,0,0,0,1789,
  	1792,1,0,0,0,1790,1788,1,0,0,0,1791,1793,5,294,0,0,1792,1791,1,0,0,0,
  	1792,1793,1,0,0,0,1793,177,1,0,0,0,1794,1796,5,63,0,0,1795,1797,5,295,
  	0,0,1796,1795,1,0,0,0,1796,1797,1,0,0,0,1797,1799,1,0,0,0,1798,1800,5,
  	272,0,0,1799,1798,1,0,0,0,1799,1800,1,0,0,0,1800,1802,1,0,0,0,1801,1803,
  	5,295,0,0,1802,1801,1,0,0,0,1802,1803,1,0,0,0,1803,1814,1,0,0,0,1804,
  	1806,5,295,0,0,1805,1804,1,0,0,0,1805,1806,1,0,0,0,1806,1807,1,0,0,0,
  	1807,1809,5,299,0,0,1808,1810,5,295,0,0,1809,1808,1,0,0,0,1809,1810,1,
  	0,0,0,1810,1811,1,0,0,0,1811,1813,5,272,0,0,1812,1805,1,0,0,0,1813,1816,
  	1,0,0,0,1814,1812,1,0,0,0,1814,1815,1,0,0,0,1815,1818,1,0,0,0,1816,1814,
  	1,0,0,0,1817,1819,5,12,0,0,1818,1817,1,0,0,0,1818,1819,1,0,0,0,1819,1821,
  	1,0,0,0,1820,1822,5,296,0,0,1821,1820,1,0,0,0,1821,1822,1,0,0,0,1822,
  	1824,1,0,0,0,1823,1825,5,274,0,0,1824,1823,1,0,0,0,1824,1825,1,0,0,0,
  	1825,1827,1,0,0,0,1826,1828,5,295,0,0,1827,1826,1,0,0,0,1827,1828,1,0,
  	0,0,1828,1830,1,0,0,0,1829,1831,5,28,0,0,1830,1829,1,0,0,0,1830,1831,
  	1,0,0,0,1831,1833,1,0,0,0,1832,1834,5,295,0,0,1833,1832,1,0,0,0,1833,
  	1834,1,0,0,0,1834,1836,1,0,0,0,1835,1837,5,296,0,0,1836,1835,1,0,0,0,
  	1836,1837,1,0,0,0,1837,1839,1,0,0,0,1838,1840,5,295,0,0,1839,1838,1,0,
  	0,0,1839,1840,1,0,0,0,1840,1842,1,0,0,0,1841,1843,5,293,0,0,1842,1841,
  	1,0,0,0,1842,1843,1,0,0,0,1843,1845,1,0,0,0,1844,1846,5,295,0,0,1845,
  	1844,1,0,0,0,1845,1846,1,0,0,0,1846,1848,1,0,0,0,1847,1849,5,273,0,0,
  	1848,1847,1,0,0,0,1848,1849,1,0,0,0,1849,1851,1,0,0,0,1850,1852,5,285,
  	0,0,1851,1850,1,0,0,0,1851,1852,1,0,0,0,1852,1854,1,0,0,0,1853,1855,5,
  	295,0,0,1854,1853,1,0,0,0,1854,1855,1,0,0,0,1855,1857,1,0,0,0,1856,1858,
  	5,272,0,0,1857,1856,1,0,0,0,1857,1858,1,0,0,0,1858,1860,1,0,0,0,1859,
  	1861,3,178,89,0,1860,1859,1,0,0,0,1860,1861,1,0,0,0,1861,179,1,0,0,0,
  	1862,1864,5,213,0,0,1863,1865,5,295,0,0,1864,1863,1,0,0,0,1864,1865,1,
  	0,0,0,1865,1867,1,0,0,0,1866,1868,5,124,0,0,1867,1866,1,0,0,0,1867,1868,
  	1,0,0,0,1868,1870,1,0,0,0,1869,1871,5,295,0,0,1870,1869,1,0,0,0,1870,
  	1871,1,0,0,0,1871,1872,1,0,0,0,1872,1874,3,20,10,0,1873,1875,5,295,0,
  	0,1874,1873,1,0,0,0,1874,1875,1,0,0,0,1875,1877,1,0,0,0,1876,1878,5,273,
  	0,0,1877,1876,1,0,0,0,1877,1878,1,0,0,0,1878,1879,1,0,0,0,1879,1882,5,
  	285,0,0,1880,1883,3,162,81,0,1881,1883,5,295,0,0,1882,1880,1,0,0,0,1882,
  	1881,1,0,0,0,1883,1884,1,0,0,0,1884,1882,1,0,0,0,1884,1885,1,0,0,0,1885,
  	181,1,0,0,0,1886,1890,5,43,0,0,1887,1889,3,198,99,0,1888,1887,1,0,0,0,
  	1889,1892,1,0,0,0,1890,1888,1,0,0,0,1890,1891,1,0,0,0,1891,1894,1,0,0,
  	0,1892,1890,1,0,0,0,1893,1895,5,296,0,0,1894,1893,1,0,0,0,1894,1895,1,
  	0,0,0,1895,183,1,0,0,0,1896,1900,5,45,0,0,1897,1899,3,198,99,0,1898,1897,
  	1,0,0,0,1899,1902,1,0,0,0,1900,1898,1,0,0,0,1900,1901,1,0,0,0,1901,1904,
  	1,0,0,0,1902,1900,1,0,0,0,1903,1905,5,296,0,0,1904,1903,1,0,0,0,1904,
  	1905,1,0,0,0,1905,185,1,0,0,0,1906,1910,5,44,0,0,1907,1909,3,198,99,0,
  	1908,1907,1,0,0,0,1909,1912,1,0,0,0,1910,1908,1,0,0,0,1910,1911,1,0,0,
  	0,1911,1914,1,0,0,0,1912,1910,1,0,0,0,1913,1915,5,296,0,0,1914,1913,1,
  	0,0,0,1914,1915,1,0,0,0,1915,187,1,0,0,0,1916,1920,5,46,0,0,1917,1919,
  	3,198,99,0,1918,1917,1,0,0,0,1919,1922,1,0,0,0,1920,1918,1,0,0,0,1920,
  	1921,1,0,0,0,1921,1924,1,0,0,0,1922,1920,1,0,0,0,1923,1925,5,296,0,0,
  	1924,1923,1,0,0,0,1924,1925,1,0,0,0,1925,189,1,0,0,0,1926,1928,5,67,0,
  	0,1927,1929,5,295,0,0,1928,1927,1,0,0,0,1928,1929,1,0,0,0,1929,1931,1,
  	0,0,0,1930,1932,5,124,0,0,1931,1930,1,0,0,0,1931,1932,1,0,0,0,1932,1934,
  	1,0,0,0,1933,1935,5,295,0,0,1934,1933,1,0,0,0,1934,1935,1,0,0,0,1935,
  	1936,1,0,0,0,1936,1938,3,20,10,0,1937,1939,5,295,0,0,1938,1937,1,0,0,
  	0,1938,1939,1,0,0,0,1939,1941,1,0,0,0,1940,1942,5,273,0,0,1941,1940,1,
  	0,0,0,1941,1942,1,0,0,0,1942,1943,1,0,0,0,1943,1945,5,285,0,0,1944,1946,
  	5,295,0,0,1945,1944,1,0,0,0,1945,1946,1,0,0,0,1946,1947,1,0,0,0,1947,
  	1949,3,162,81,0,1948,1950,5,295,0,0,1949,1948,1,0,0,0,1949,1950,1,0,0,
  	0,1950,1951,1,0,0,0,1951,1953,3,202,101,0,1952,1954,5,295,0,0,1953,1952,
  	1,0,0,0,1953,1954,1,0,0,0,1954,1955,1,0,0,0,1955,1957,3,162,81,0,1956,
  	1958,5,295,0,0,1957,1956,1,0,0,0,1957,1958,1,0,0,0,1958,1960,1,0,0,0,
  	1959,1961,3,194,97,0,1960,1959,1,0,0,0,1960,1961,1,0,0,0,1961,1986,1,
  	0,0,0,1962,1964,5,67,0,0,1963,1965,5,295,0,0,1964,1963,1,0,0,0,1964,1965,
  	1,0,0,0,1965,1967,1,0,0,0,1966,1968,5,124,0,0,1967,1966,1,0,0,0,1967,
  	1968,1,0,0,0,1968,1970,1,0,0,0,1969,1971,5,295,0,0,1970,1969,1,0,0,0,
  	1970,1971,1,0,0,0,1971,1972,1,0,0,0,1972,1974,3,20,10,0,1973,1975,5,295,
  	0,0,1974,1973,1,0,0,0,1974,1975,1,0,0,0,1975,1977,1,0,0,0,1976,1978,5,
  	273,0,0,1977,1976,1,0,0,0,1977,1978,1,0,0,0,1978,1979,1,0,0,0,1979,1981,
  	5,285,0,0,1980,1982,5,295,0,0,1981,1980,1,0,0,0,1981,1982,1,0,0,0,1982,
  	1983,1,0,0,0,1983,1984,3,162,81,0,1984,1986,1,0,0,0,1985,1926,1,0,0,0,
  	1985,1962,1,0,0,0,1986,191,1,0,0,0,1987,1989,5,293,0,0,1988,1990,5,295,
  	0,0,1989,1988,1,0,0,0,1989,1990,1,0,0,0,1990,1992,1,0,0,0,1991,1993,5,
  	273,0,0,1992,1991,1,0,0,0,1992,1993,1,0,0,0,1993,1994,1,0,0,0,1994,1996,
  	5,285,0,0,1995,1997,5,295,0,0,1996,1995,1,0,0,0,1996,1997,1,0,0,0,1997,
  	1998,1,0,0,0,1998,2000,3,162,81,0,1999,2001,5,295,0,0,2000,1999,1,0,0,
  	0,2000,2001,1,0,0,0,2001,2002,1,0,0,0,2002,2004,3,202,101,0,2003,2005,
  	5,295,0,0,2004,2003,1,0,0,0,2004,2005,1,0,0,0,2005,2006,1,0,0,0,2006,
  	2008,3,162,81,0,2007,2009,5,295,0,0,2008,2007,1,0,0,0,2008,2009,1,0,0,
  	0,2009,2011,1,0,0,0,2010,2012,3,194,97,0,2011,2010,1,0,0,0,2011,2012,
  	1,0,0,0,2012,193,1,0,0,0,2013,2015,3,202,101,0,2014,2016,5,295,0,0,2015,
  	2014,1,0,0,0,2015,2016,1,0,0,0,2016,2017,1,0,0,0,2017,2019,3,162,81,0,
  	2018,2020,5,295,0,0,2019,2018,1,0,0,0,2019,2020,1,0,0,0,2020,2022,1,0,
  	0,0,2021,2023,3,194,97,0,2022,2021,1,0,0,0,2022,2023,1,0,0,0,2023,195,
  	1,0,0,0,2024,2031,3,182,91,0,2025,2031,3,186,93,0,2026,2031,3,184,92,
  	0,2027,2031,3,188,94,0,2028,2031,3,190,95,0,2029,2031,3,192,96,0,2030,
  	2024,1,0,0,0,2030,2025,1,0,0,0,2030,2026,1,0,0,0,2030,2027,1,0,0,0,2030,
  	2028,1,0,0,0,2030,2029,1,0,0,0,2031,197,1,0,0,0,2032,2033,7,38,0,0,2033,
  	199,1,0,0,0,2034,2035,7,39,0,0,2035,201,1,0,0,0,2036,2037,7,40,0,0,2037,
  	203,1,0,0,0,2038,2039,7,41,0,0,2039,205,1,0,0,0,2040,2042,8,42,0,0,2041,
  	2040,1,0,0,0,2042,2043,1,0,0,0,2043,2044,1,0,0,0,2043,2041,1,0,0,0,2044,
  	207,1,0,0,0,357,212,214,218,223,267,275,283,289,291,297,304,308,314,317,
  	321,324,337,339,342,349,353,356,360,366,369,374,379,383,388,390,395,411,
  	417,430,432,440,445,447,450,455,457,476,482,491,498,501,504,507,510,513,
  	516,520,523,526,529,532,535,540,544,547,552,558,562,565,570,574,577,581,
  	584,587,589,592,597,602,605,608,611,614,617,620,624,627,630,635,639,643,
  	646,650,656,666,673,675,680,692,694,699,710,715,722,724,751,753,765,767,
  	772,781,786,793,795,829,831,838,841,848,851,855,860,862,865,877,883,887,
  	891,894,897,900,903,906,909,912,916,919,924,931,933,938,948,954,957,962,
  	971,978,984,986,993,997,1005,1012,1014,1045,1047,1060,1063,1072,1075,
  	1081,1089,1092,1098,1102,1118,1120,1127,1136,1139,1145,1147,1162,1169,
  	1172,1175,1179,1184,1193,1198,1201,1204,1208,1213,1217,1227,1232,1235,
  	1238,1242,1249,1251,1258,1264,1268,1274,1276,1285,1290,1294,1298,1301,
  	1308,1311,1317,1323,1329,1332,1336,1339,1344,1350,1354,1367,1374,1380,
  	1385,1388,1391,1394,1396,1399,1402,1405,1412,1422,1430,1434,1439,1443,
  	1449,1460,1463,1466,1471,1474,1480,1483,1487,1495,1502,1508,1511,1515,
  	1517,1525,1529,1534,1541,1546,1548,1554,1557,1565,1568,1573,1576,1582,
  	1585,1588,1594,1597,1602,1607,1610,1616,1619,1622,1628,1631,1634,1642,
  	1645,1648,1650,1655,1660,1663,1669,1672,1675,1689,1694,1700,1704,1712,
  	1714,1718,1759,1763,1767,1771,1775,1779,1786,1788,1792,1796,1799,1802,
  	1805,1809,1814,1818,1821,1824,1827,1830,1833,1836,1839,1842,1845,1848,
  	1851,1854,1857,1860,1864,1867,1870,1874,1877,1882,1884,1890,1894,1900,
  	1904,1910,1914,1920,1924,1928,1931,1934,1938,1941,1945,1949,1953,1957,
  	1960,1964,1967,1970,1974,1977,1981,1985,1989,1992,1996,2000,2004,2008,
  	2011,2015,2019,2022,2030,2043
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  naturalparserParserStaticData = staticData.release();
}

}

NaturalParser::NaturalParser(TokenStream *input) : NaturalParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NaturalParser::NaturalParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  NaturalParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *naturalparserParserStaticData->atn, naturalparserParserStaticData->decisionToDFA, naturalparserParserStaticData->sharedContextCache, options);
}

NaturalParser::~NaturalParser() {
  delete _interpreter;
}

const atn::ATN& NaturalParser::getATN() const {
  return *naturalparserParserStaticData->atn;
}

std::string NaturalParser::getGrammarFileName() const {
  return "NaturalParser.g4";
}

const std::vector<std::string>& NaturalParser::getRuleNames() const {
  return naturalparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& NaturalParser::getVocabulary() const {
  return naturalparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NaturalParser::getSerializedATN() const {
  return naturalparserParserStaticData->serializedATN;
}


//----------------- ProgramContext ------------------------------------------------------------------

NaturalParser::ProgramContext::ProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::LineNumberStatementContext *> NaturalParser::ProgramContext::lineNumberStatement() {
  return getRuleContexts<NaturalParser::LineNumberStatementContext>();
}

NaturalParser::LineNumberStatementContext* NaturalParser::ProgramContext::lineNumberStatement(size_t i) {
  return getRuleContext<NaturalParser::LineNumberStatementContext>(i);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::ProgramContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::ProgramContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ProgramContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ProgramContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ProgramContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ProgramContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}


size_t NaturalParser::ProgramContext::getRuleIndex() const {
  return NaturalParser::RuleProgram;
}


std::any NaturalParser::ProgramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitProgram(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ProgramContext* NaturalParser::program() {
  ProgramContext *_localctx = _tracker.createInstance<ProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, NaturalParser::RuleProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(212); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(212);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
      case 1: {
        setState(208);
        lineNumberStatement();
        break;
      }

      case 2: {
        setState(209);
        statement();
        break;
      }

      case 3: {
        setState(210);
        match(NaturalParser::WS);
        break;
      }

      case 4: {
        setState(211);
        match(NaturalParser::NL);
        break;
      }

      default:
        break;
      }
      setState(214); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineNumberStatementContext ------------------------------------------------------------------

NaturalParser::LineNumberStatementContext::LineNumberStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::LineNumberStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

NaturalParser::StatementContext* NaturalParser::LineNumberStatementContext::statement() {
  return getRuleContext<NaturalParser::StatementContext>(0);
}

tree::TerminalNode* NaturalParser::LineNumberStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}


size_t NaturalParser::LineNumberStatementContext::getRuleIndex() const {
  return NaturalParser::RuleLineNumberStatement;
}


std::any NaturalParser::LineNumberStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitLineNumberStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::LineNumberStatementContext* NaturalParser::lineNumberStatement() {
  LineNumberStatementContext *_localctx = _tracker.createInstance<LineNumberStatementContext>(_ctx, getState());
  enterRule(_localctx, 2, NaturalParser::RuleLineNumberStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(216);
    match(NaturalParser::LINE_NUMBER);
    setState(218);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      setState(217);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(220);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NaturalParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::DataDefinitionContext* NaturalParser::StatementContext::dataDefinition() {
  return getRuleContext<NaturalParser::DataDefinitionContext>(0);
}

NaturalParser::SubroutineContext* NaturalParser::StatementContext::subroutine() {
  return getRuleContext<NaturalParser::SubroutineContext>(0);
}

NaturalParser::FunctionDefinitionContext* NaturalParser::StatementContext::functionDefinition() {
  return getRuleContext<NaturalParser::FunctionDefinitionContext>(0);
}

NaturalParser::NoRecordsFoundStatementContext* NaturalParser::StatementContext::noRecordsFoundStatement() {
  return getRuleContext<NaturalParser::NoRecordsFoundStatementContext>(0);
}

NaturalParser::DecisionStatementContext* NaturalParser::StatementContext::decisionStatement() {
  return getRuleContext<NaturalParser::DecisionStatementContext>(0);
}

NaturalParser::ValueAssignmentContext* NaturalParser::StatementContext::valueAssignment() {
  return getRuleContext<NaturalParser::ValueAssignmentContext>(0);
}

NaturalParser::ForStatementContext* NaturalParser::StatementContext::forStatement() {
  return getRuleContext<NaturalParser::ForStatementContext>(0);
}

NaturalParser::IfStatementContext* NaturalParser::StatementContext::ifStatement() {
  return getRuleContext<NaturalParser::IfStatementContext>(0);
}

NaturalParser::PerformStatementContext* NaturalParser::StatementContext::performStatement() {
  return getRuleContext<NaturalParser::PerformStatementContext>(0);
}

NaturalParser::CallnatStatementContext* NaturalParser::StatementContext::callnatStatement() {
  return getRuleContext<NaturalParser::CallnatStatementContext>(0);
}

NaturalParser::ExamineStatementContext* NaturalParser::StatementContext::examineStatement() {
  return getRuleContext<NaturalParser::ExamineStatementContext>(0);
}

NaturalParser::MoveStatementContext* NaturalParser::StatementContext::moveStatement() {
  return getRuleContext<NaturalParser::MoveStatementContext>(0);
}

NaturalParser::FindStatementContext* NaturalParser::StatementContext::findStatement() {
  return getRuleContext<NaturalParser::FindStatementContext>(0);
}

NaturalParser::ReadStatementContext* NaturalParser::StatementContext::readStatement() {
  return getRuleContext<NaturalParser::ReadStatementContext>(0);
}

NaturalParser::StoreStatementContext* NaturalParser::StatementContext::storeStatement() {
  return getRuleContext<NaturalParser::StoreStatementContext>(0);
}

NaturalParser::UpdateStatementContext* NaturalParser::StatementContext::updateStatement() {
  return getRuleContext<NaturalParser::UpdateStatementContext>(0);
}

NaturalParser::DeleteStatementContext* NaturalParser::StatementContext::deleteStatement() {
  return getRuleContext<NaturalParser::DeleteStatementContext>(0);
}

NaturalParser::GetStatementsContext* NaturalParser::StatementContext::getStatements() {
  return getRuleContext<NaturalParser::GetStatementsContext>(0);
}

NaturalParser::HistogramStatementContext* NaturalParser::StatementContext::histogramStatement() {
  return getRuleContext<NaturalParser::HistogramStatementContext>(0);
}

NaturalParser::EndTransactionContext* NaturalParser::StatementContext::endTransaction() {
  return getRuleContext<NaturalParser::EndTransactionContext>(0);
}

NaturalParser::BackoutTransactionContext* NaturalParser::StatementContext::backoutTransaction() {
  return getRuleContext<NaturalParser::BackoutTransactionContext>(0);
}

NaturalParser::ReadworkfileStatementContext* NaturalParser::StatementContext::readworkfileStatement() {
  return getRuleContext<NaturalParser::ReadworkfileStatementContext>(0);
}

NaturalParser::WriteworkfileStatementContext* NaturalParser::StatementContext::writeworkfileStatement() {
  return getRuleContext<NaturalParser::WriteworkfileStatementContext>(0);
}

NaturalParser::CloseworkfileStatementContext* NaturalParser::StatementContext::closeworkfileStatement() {
  return getRuleContext<NaturalParser::CloseworkfileStatementContext>(0);
}

NaturalParser::InputStatementContext* NaturalParser::StatementContext::inputStatement() {
  return getRuleContext<NaturalParser::InputStatementContext>(0);
}

NaturalParser::ReinputStatementContext* NaturalParser::StatementContext::reinputStatement() {
  return getRuleContext<NaturalParser::ReinputStatementContext>(0);
}

NaturalParser::CalculationsContext* NaturalParser::StatementContext::calculations() {
  return getRuleContext<NaturalParser::CalculationsContext>(0);
}

NaturalParser::AssignStatementContext* NaturalParser::StatementContext::assignStatement() {
  return getRuleContext<NaturalParser::AssignStatementContext>(0);
}

NaturalParser::SetkeyStatementContext* NaturalParser::StatementContext::setkeyStatement() {
  return getRuleContext<NaturalParser::SetkeyStatementContext>(0);
}

NaturalParser::RedefineStatementContext* NaturalParser::StatementContext::redefineStatement() {
  return getRuleContext<NaturalParser::RedefineStatementContext>(0);
}

NaturalParser::ResetStatementContext* NaturalParser::StatementContext::resetStatement() {
  return getRuleContext<NaturalParser::ResetStatementContext>(0);
}

NaturalParser::SortStatementContext* NaturalParser::StatementContext::sortStatement() {
  return getRuleContext<NaturalParser::SortStatementContext>(0);
}

NaturalParser::CompressStatementContext* NaturalParser::StatementContext::compressStatement() {
  return getRuleContext<NaturalParser::CompressStatementContext>(0);
}

NaturalParser::DoStatementContext* NaturalParser::StatementContext::doStatement() {
  return getRuleContext<NaturalParser::DoStatementContext>(0);
}

NaturalParser::RepeatStatementContext* NaturalParser::StatementContext::repeatStatement() {
  return getRuleContext<NaturalParser::RepeatStatementContext>(0);
}

NaturalParser::AtStartOfDataStatementContext* NaturalParser::StatementContext::atStartOfDataStatement() {
  return getRuleContext<NaturalParser::AtStartOfDataStatementContext>(0);
}

NaturalParser::FormatStatementContext* NaturalParser::StatementContext::formatStatement() {
  return getRuleContext<NaturalParser::FormatStatementContext>(0);
}

NaturalParser::AssignmentStatementContext* NaturalParser::StatementContext::assignmentStatement() {
  return getRuleContext<NaturalParser::AssignmentStatementContext>(0);
}

NaturalParser::IncludeStatementContext* NaturalParser::StatementContext::includeStatement() {
  return getRuleContext<NaturalParser::IncludeStatementContext>(0);
}

NaturalParser::FetchStatementContext* NaturalParser::StatementContext::fetchStatement() {
  return getRuleContext<NaturalParser::FetchStatementContext>(0);
}

NaturalParser::CallStatementContext* NaturalParser::StatementContext::callStatement() {
  return getRuleContext<NaturalParser::CallStatementContext>(0);
}

NaturalParser::OtherStatementContext* NaturalParser::StatementContext::otherStatement() {
  return getRuleContext<NaturalParser::OtherStatementContext>(0);
}

NaturalParser::LabelContext* NaturalParser::StatementContext::label() {
  return getRuleContext<NaturalParser::LabelContext>(0);
}


size_t NaturalParser::StatementContext::getRuleIndex() const {
  return NaturalParser::RuleStatement;
}


std::any NaturalParser::StatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::StatementContext* NaturalParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 4, NaturalParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(223);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      setState(222);
      label();
      break;
    }

    default:
      break;
    }
    setState(267);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx)) {
    case 1: {
      setState(225);
      dataDefinition();
      break;
    }

    case 2: {
      setState(226);
      subroutine();
      break;
    }

    case 3: {
      setState(227);
      functionDefinition();
      break;
    }

    case 4: {
      setState(228);
      noRecordsFoundStatement();
      break;
    }

    case 5: {
      setState(229);
      decisionStatement();
      break;
    }

    case 6: {
      setState(230);
      valueAssignment();
      break;
    }

    case 7: {
      setState(231);
      forStatement();
      break;
    }

    case 8: {
      setState(232);
      ifStatement();
      break;
    }

    case 9: {
      setState(233);
      performStatement();
      break;
    }

    case 10: {
      setState(234);
      callnatStatement();
      break;
    }

    case 11: {
      setState(235);
      examineStatement();
      break;
    }

    case 12: {
      setState(236);
      moveStatement();
      break;
    }

    case 13: {
      setState(237);
      findStatement();
      break;
    }

    case 14: {
      setState(238);
      readStatement();
      break;
    }

    case 15: {
      setState(239);
      storeStatement();
      break;
    }

    case 16: {
      setState(240);
      updateStatement();
      break;
    }

    case 17: {
      setState(241);
      deleteStatement();
      break;
    }

    case 18: {
      setState(242);
      getStatements();
      break;
    }

    case 19: {
      setState(243);
      histogramStatement();
      break;
    }

    case 20: {
      setState(244);
      endTransaction();
      break;
    }

    case 21: {
      setState(245);
      backoutTransaction();
      break;
    }

    case 22: {
      setState(246);
      readworkfileStatement();
      break;
    }

    case 23: {
      setState(247);
      writeworkfileStatement();
      break;
    }

    case 24: {
      setState(248);
      closeworkfileStatement();
      break;
    }

    case 25: {
      setState(249);
      inputStatement();
      break;
    }

    case 26: {
      setState(250);
      reinputStatement();
      break;
    }

    case 27: {
      setState(251);
      calculations();
      break;
    }

    case 28: {
      setState(252);
      assignStatement();
      break;
    }

    case 29: {
      setState(253);
      setkeyStatement();
      break;
    }

    case 30: {
      setState(254);
      redefineStatement();
      break;
    }

    case 31: {
      setState(255);
      resetStatement();
      break;
    }

    case 32: {
      setState(256);
      sortStatement();
      break;
    }

    case 33: {
      setState(257);
      compressStatement();
      break;
    }

    case 34: {
      setState(258);
      doStatement();
      break;
    }

    case 35: {
      setState(259);
      repeatStatement();
      break;
    }

    case 36: {
      setState(260);
      atStartOfDataStatement();
      break;
    }

    case 37: {
      setState(261);
      formatStatement();
      break;
    }

    case 38: {
      setState(262);
      assignmentStatement();
      break;
    }

    case 39: {
      setState(263);
      includeStatement();
      break;
    }

    case 40: {
      setState(264);
      fetchStatement();
      break;
    }

    case 41: {
      setState(265);
      callStatement();
      break;
    }

    case 42: {
      setState(266);
      otherStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelContext ------------------------------------------------------------------

NaturalParser::LabelContext::LabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::LabelContext::LABEL() {
  return getToken(NaturalParser::LABEL, 0);
}


size_t NaturalParser::LabelContext::getRuleIndex() const {
  return NaturalParser::RuleLabel;
}


std::any NaturalParser::LabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitLabel(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::LabelContext* NaturalParser::label() {
  LabelContext *_localctx = _tracker.createInstance<LabelContext>(_ctx, getState());
  enterRule(_localctx, 6, NaturalParser::RuleLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(269);
    match(NaturalParser::LABEL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataDefinitionContext ------------------------------------------------------------------

NaturalParser::DataDefinitionContext::DataDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::DataDefinitionContext::DEFINE_DATA() {
  return getToken(NaturalParser::DEFINE_DATA, 0);
}

tree::TerminalNode* NaturalParser::DataDefinitionContext::END_DEFINE() {
  return getToken(NaturalParser::END_DEFINE, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::DataDefinitionContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::DataDefinitionContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::DataDefinitionContext::getRuleIndex() const {
  return NaturalParser::RuleDataDefinition;
}


std::any NaturalParser::DataDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitDataDefinition(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::DataDefinitionContext* NaturalParser::dataDefinition() {
  DataDefinitionContext *_localctx = _tracker.createInstance<DataDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 8, NaturalParser::RuleDataDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(271);
    match(NaturalParser::DEFINE_DATA);
    setState(273); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(272);
              statement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(275); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(277);
    match(NaturalParser::END_DEFINE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompressStatementContext ------------------------------------------------------------------

NaturalParser::CompressStatementContext::CompressStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CompressStatementContext::COMPRESS() {
  return getToken(NaturalParser::COMPRESS, 0);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::INTO() {
  return getToken(NaturalParser::INTO, 0);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::CompressStatementContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::CompressStatementContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

NaturalParser::CompressEndContext* NaturalParser::CompressStatementContext::compressEnd() {
  return getRuleContext<NaturalParser::CompressEndContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressStatementContext::NUMERIC() {
  return getTokens(NaturalParser::NUMERIC);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::NUMERIC(size_t i) {
  return getToken(NaturalParser::NUMERIC, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressStatementContext::FULL() {
  return getTokens(NaturalParser::FULL);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::FULL(size_t i) {
  return getToken(NaturalParser::FULL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::CompressStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::CompressStatementContext::getRuleIndex() const {
  return NaturalParser::RuleCompressStatement;
}


std::any NaturalParser::CompressStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCompressStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CompressStatementContext* NaturalParser::compressStatement() {
  CompressStatementContext *_localctx = _tracker.createInstance<CompressStatementContext>(_ctx, getState());
  enterRule(_localctx, 10, NaturalParser::RuleCompressStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(279);
    match(NaturalParser::COMPRESS);
    setState(283);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(280);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::FULL || _la == NaturalParser::NUMERIC || _la == NaturalParser::WS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(285);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
    setState(289); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(289);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::POSITION:
        case NaturalParser::STRING:
        case NaturalParser::LINE_NUMBER:
        case NaturalParser::FLOAT:
        case NaturalParser::INPUT_PARAM:
        case NaturalParser::DATE_CONSTANT:
        case NaturalParser::H_CONSTANT:
        case NaturalParser::LPAREN:
        case NaturalParser::IDENTIFIER: {
          setState(286);
          operand();
          break;
        }

        case NaturalParser::WS: {
          setState(287);
          match(NaturalParser::WS);
          break;
        }

        case NaturalParser::NL: {
          setState(288);
          match(NaturalParser::NL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(291); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == NaturalParser::POSITION || ((((_la - 272) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 272)) & 27787725) != 0));
    setState(293);
    match(NaturalParser::INTO);
    setState(297);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(294);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(299);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
    setState(300);
    operand();
    setState(308);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(304);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 6291457) != 0)) {
        setState(301);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(306);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(307);
      compressEnd();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompressEndContext ------------------------------------------------------------------

NaturalParser::CompressEndContext::CompressEndContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CompressEndContext::LEAVING_SPACE() {
  return getToken(NaturalParser::LEAVING_SPACE, 0);
}

tree::TerminalNode* NaturalParser::CompressEndContext::LEAVING_NO_SPACE() {
  return getToken(NaturalParser::LEAVING_NO_SPACE, 0);
}

tree::TerminalNode* NaturalParser::CompressEndContext::WITH() {
  return getToken(NaturalParser::WITH, 0);
}

tree::TerminalNode* NaturalParser::CompressEndContext::DELIMITER() {
  return getToken(NaturalParser::DELIMITER, 0);
}

tree::TerminalNode* NaturalParser::CompressEndContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}

tree::TerminalNode* NaturalParser::CompressEndContext::ALL() {
  return getToken(NaturalParser::ALL, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::CompressEndContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::CompressEndContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}


size_t NaturalParser::CompressEndContext::getRuleIndex() const {
  return NaturalParser::RuleCompressEnd;
}


std::any NaturalParser::CompressEndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCompressEnd(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CompressEndContext* NaturalParser::compressEnd() {
  CompressEndContext *_localctx = _tracker.createInstance<CompressEndContext>(_ctx, getState());
  enterRule(_localctx, 12, NaturalParser::RuleCompressEnd);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(324);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::LEAVING_SPACE: {
        enterOuterAlt(_localctx, 1);
        setState(310);
        match(NaturalParser::LEAVING_SPACE);
        break;
      }

      case NaturalParser::LEAVING_NO_SPACE: {
        enterOuterAlt(_localctx, 2);
        setState(311);
        match(NaturalParser::LEAVING_NO_SPACE);
        break;
      }

      case NaturalParser::WITH: {
        enterOuterAlt(_localctx, 3);
        setState(312);
        match(NaturalParser::WITH);
        setState(317);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::ALL || _la == NaturalParser::WS) {
          setState(314);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == NaturalParser::WS) {
            setState(313);
            match(NaturalParser::WS);
          }
          setState(316);
          match(NaturalParser::ALL);
        }
        setState(319);
        match(NaturalParser::DELIMITER);
        setState(321);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(320);
          match(NaturalParser::WS);
        }
        setState(323);
        match(NaturalParser::STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InputStatementContext ------------------------------------------------------------------

NaturalParser::InputStatementContext::InputStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::InputStatementContext::INPUT() {
  return getToken(NaturalParser::INPUT, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::InputStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::InputStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::InputUsingMapContext* NaturalParser::InputStatementContext::inputUsingMap() {
  return getRuleContext<NaturalParser::InputUsingMapContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::InputStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::InputStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::InputStatementContext::STRING() {
  return getTokens(NaturalParser::STRING);
}

tree::TerminalNode* NaturalParser::InputStatementContext::STRING(size_t i) {
  return getToken(NaturalParser::STRING, i);
}

std::vector<NaturalParser::VariableContext *> NaturalParser::InputStatementContext::variable() {
  return getRuleContexts<NaturalParser::VariableContext>();
}

NaturalParser::VariableContext* NaturalParser::InputStatementContext::variable(size_t i) {
  return getRuleContext<NaturalParser::VariableContext>(i);
}

std::vector<NaturalParser::InputOptionsContext *> NaturalParser::InputStatementContext::inputOptions() {
  return getRuleContexts<NaturalParser::InputOptionsContext>();
}

NaturalParser::InputOptionsContext* NaturalParser::InputStatementContext::inputOptions(size_t i) {
  return getRuleContext<NaturalParser::InputOptionsContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::InputStatementContext::DIV() {
  return getTokens(NaturalParser::DIV);
}

tree::TerminalNode* NaturalParser::InputStatementContext::DIV(size_t i) {
  return getToken(NaturalParser::DIV, i);
}

std::vector<tree::TerminalNode *> NaturalParser::InputStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::InputStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::InputStatementContext::getRuleIndex() const {
  return NaturalParser::RuleInputStatement;
}


std::any NaturalParser::InputStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitInputStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::InputStatementContext* NaturalParser::inputStatement() {
  InputStatementContext *_localctx = _tracker.createInstance<InputStatementContext>(_ctx, getState());
  enterRule(_localctx, 14, NaturalParser::RuleInputStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(342);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(326);
      match(NaturalParser::INPUT);
      setState(327);
      match(NaturalParser::WS);
      setState(328);
      inputUsingMap();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(329);
      match(NaturalParser::INPUT);
      setState(337); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(337);
                _errHandler->sync(this);
                switch (_input->LA(1)) {
                  case NaturalParser::STRING: {
                    setState(330);
                    match(NaturalParser::STRING);
                    break;
                  }

                  case NaturalParser::IDENTIFIER: {
                    setState(331);
                    variable();
                    break;
                  }

                  case NaturalParser::MARK:
                  case NaturalParser::POSITION:
                  case NaturalParser::IN:
                  case NaturalParser::FIELD: {
                    setState(332);
                    inputOptions();
                    break;
                  }

                  case NaturalParser::DIV: {
                    setState(333);
                    match(NaturalParser::DIV);
                    break;
                  }

                  case NaturalParser::WS: {
                    setState(334);
                    match(NaturalParser::WS);
                    break;
                  }

                  case NaturalParser::LINE_NUMBER: {
                    setState(335);
                    match(NaturalParser::LINE_NUMBER);
                    break;
                  }

                  case NaturalParser::NL: {
                    setState(336);
                    match(NaturalParser::NL);
                    break;
                  }

                default:
                  throw NoViableAltException(this);
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(339); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(341);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InputOptionsContext ------------------------------------------------------------------

NaturalParser::InputOptionsContext::InputOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::InputOptionsContext::MARK() {
  return getToken(NaturalParser::MARK, 0);
}

tree::TerminalNode* NaturalParser::InputOptionsContext::POSITION() {
  return getToken(NaturalParser::POSITION, 0);
}

tree::TerminalNode* NaturalParser::InputOptionsContext::IN() {
  return getToken(NaturalParser::IN, 0);
}

tree::TerminalNode* NaturalParser::InputOptionsContext::FIELD() {
  return getToken(NaturalParser::FIELD, 0);
}


size_t NaturalParser::InputOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleInputOptions;
}


std::any NaturalParser::InputOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitInputOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::InputOptionsContext* NaturalParser::inputOptions() {
  InputOptionsContext *_localctx = _tracker.createInstance<InputOptionsContext>(_ctx, getState());
  enterRule(_localctx, 16, NaturalParser::RuleInputOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(344);
    _la = _input->LA(1);
    if (!(((((_la - 77) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 77)) & 274877906969) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InputUsingMapContext ------------------------------------------------------------------

NaturalParser::InputUsingMapContext::InputUsingMapContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::InputUsingMapContext::MAP() {
  return getToken(NaturalParser::MAP, 0);
}

tree::TerminalNode* NaturalParser::InputUsingMapContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::InputUsingMapContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::InputUsingMapContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

tree::TerminalNode* NaturalParser::InputUsingMapContext::USING() {
  return getToken(NaturalParser::USING, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::InputUsingMapContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::InputUsingMapContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}


size_t NaturalParser::InputUsingMapContext::getRuleIndex() const {
  return NaturalParser::RuleInputUsingMap;
}


std::any NaturalParser::InputUsingMapContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitInputUsingMap(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::InputUsingMapContext* NaturalParser::inputUsingMap() {
  InputUsingMapContext *_localctx = _tracker.createInstance<InputUsingMapContext>(_ctx, getState());
  enterRule(_localctx, 18, NaturalParser::RuleInputUsingMap);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(349);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(346);
        statement(); 
      }
      setState(351);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    }
    setState(353);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::USING) {
      setState(352);
      match(NaturalParser::USING);
    }
    setState(356);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(355);
      match(NaturalParser::WS);
    }
    setState(358);
    match(NaturalParser::MAP);
    setState(360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(359);
      match(NaturalParser::WS);
    }
    setState(362);
    match(NaturalParser::STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

NaturalParser::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::VariableContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::VariableContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}

tree::TerminalNode* NaturalParser::VariableContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

tree::TerminalNode* NaturalParser::VariableContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::VariableContext::DOT() {
  return getToken(NaturalParser::DOT, 0);
}


size_t NaturalParser::VariableContext::getRuleIndex() const {
  return NaturalParser::RuleVariable;
}


std::any NaturalParser::VariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitVariable(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::VariableContext* NaturalParser::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 20, NaturalParser::RuleVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(374);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(364);
      match(NaturalParser::IDENTIFIER);
      setState(369);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
      case 1: {
        setState(366);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(365);
          match(NaturalParser::WS);
        }
        setState(368);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::LINE_REF

        || _la == NaturalParser::IDENTIFIER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(371);
      match(NaturalParser::IDENTIFIER);
      setState(372);
      match(NaturalParser::DOT);
      setState(373);
      match(NaturalParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReinputStatementContext ------------------------------------------------------------------

NaturalParser::ReinputStatementContext::ReinputStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::REINPUT() {
  return getToken(NaturalParser::REINPUT, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReinputStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::FULL() {
  return getToken(NaturalParser::FULL, 0);
}

std::vector<NaturalParser::ReinputOptionsContext *> NaturalParser::ReinputStatementContext::reinputOptions() {
  return getRuleContexts<NaturalParser::ReinputOptionsContext>();
}

NaturalParser::ReinputOptionsContext* NaturalParser::ReinputStatementContext::reinputOptions(size_t i) {
  return getRuleContext<NaturalParser::ReinputOptionsContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReinputStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::ALARM() {
  return getToken(NaturalParser::ALARM, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReinputStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ReinputStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::ReinputStatementContext::getRuleIndex() const {
  return NaturalParser::RuleReinputStatement;
}


std::any NaturalParser::ReinputStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReinputStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReinputStatementContext* NaturalParser::reinputStatement() {
  ReinputStatementContext *_localctx = _tracker.createInstance<ReinputStatementContext>(_ctx, getState());
  enterRule(_localctx, 22, NaturalParser::RuleReinputStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(376);
    match(NaturalParser::REINPUT);
    setState(379);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(377);
      match(NaturalParser::WS);
      setState(378);
      match(NaturalParser::FULL);
      break;
    }

    default:
      break;
    }
    setState(390);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(388);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::USING_HELP:
          case NaturalParser::MARK:
          case NaturalParser::WITH_TEXT:
          case NaturalParser::STRING:
          case NaturalParser::LINE_NUMBER:
          case NaturalParser::IDENTIFIER: {
            setState(383);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == NaturalParser::LINE_NUMBER) {
              setState(381);
              match(NaturalParser::LINE_NUMBER);
              setState(382);
              match(NaturalParser::WS);
            }
            setState(385);
            reinputOptions();
            break;
          }

          case NaturalParser::WS: {
            setState(386);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(387);
            match(NaturalParser::NL);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(392);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx);
    }
    setState(395);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(393);
      match(NaturalParser::WS);
      setState(394);
      match(NaturalParser::ALARM);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReinputOptionsContext ------------------------------------------------------------------

NaturalParser::ReinputOptionsContext::ReinputOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::MARK() {
  return getToken(NaturalParser::MARK, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::WITH_TEXT() {
  return getToken(NaturalParser::WITH_TEXT, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReinputOptionsContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::POSITION() {
  return getToken(NaturalParser::POSITION, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::IN() {
  return getToken(NaturalParser::IN, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::USING_HELP() {
  return getToken(NaturalParser::USING_HELP, 0);
}

tree::TerminalNode* NaturalParser::ReinputOptionsContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}


size_t NaturalParser::ReinputOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleReinputOptions;
}


std::any NaturalParser::ReinputOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReinputOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReinputOptionsContext* NaturalParser::reinputOptions() {
  ReinputOptionsContext *_localctx = _tracker.createInstance<ReinputOptionsContext>(_ctx, getState());
  enterRule(_localctx, 24, NaturalParser::RuleReinputOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(411);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(397);
      match(NaturalParser::MARK);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(398);
      match(NaturalParser::IDENTIFIER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(399);
      match(NaturalParser::WITH_TEXT);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(400);
      match(NaturalParser::MARK);
      setState(401);
      match(NaturalParser::WS);
      setState(402);
      match(NaturalParser::POSITION);
      setState(403);
      match(NaturalParser::WS);
      setState(404);
      match(NaturalParser::LINE_NUMBER);
      setState(405);
      match(NaturalParser::WS);
      setState(406);
      match(NaturalParser::IN);
      setState(407);
      match(NaturalParser::WS);
      setState(408);
      match(NaturalParser::IDENTIFIER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(409);
      match(NaturalParser::USING_HELP);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(410);
      match(NaturalParser::STRING);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SortStatementContext ------------------------------------------------------------------

NaturalParser::SortStatementContext::SortStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::SortStatementContext::SORT() {
  return getToken(NaturalParser::SORT, 0);
}

tree::TerminalNode* NaturalParser::SortStatementContext::END_SORT() {
  return getToken(NaturalParser::END_SORT, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::SortStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::SortStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::SortStatementContext::getRuleIndex() const {
  return NaturalParser::RuleSortStatement;
}


std::any NaturalParser::SortStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSortStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SortStatementContext* NaturalParser::sortStatement() {
  SortStatementContext *_localctx = _tracker.createInstance<SortStatementContext>(_ctx, getState());
  enterRule(_localctx, 26, NaturalParser::RuleSortStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(413);
    match(NaturalParser::SORT);
    setState(417);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(414);
        statement(); 
      }
      setState(419);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    }
    setState(420);
    match(NaturalParser::END_SORT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExamineStatementContext ------------------------------------------------------------------

NaturalParser::ExamineStatementContext::ExamineStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ExamineStatementContext::EXAMINE() {
  return getToken(NaturalParser::EXAMINE, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ExamineStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ExamineStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ExamineStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ExamineStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<NaturalParser::VariableContext *> NaturalParser::ExamineStatementContext::variable() {
  return getRuleContexts<NaturalParser::VariableContext>();
}

NaturalParser::VariableContext* NaturalParser::ExamineStatementContext::variable(size_t i) {
  return getRuleContext<NaturalParser::VariableContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ExamineStatementContext::STRING() {
  return getTokens(NaturalParser::STRING);
}

tree::TerminalNode* NaturalParser::ExamineStatementContext::STRING(size_t i) {
  return getToken(NaturalParser::STRING, i);
}

std::vector<NaturalParser::ExamineOptionsContext *> NaturalParser::ExamineStatementContext::examineOptions() {
  return getRuleContexts<NaturalParser::ExamineOptionsContext>();
}

NaturalParser::ExamineOptionsContext* NaturalParser::ExamineStatementContext::examineOptions(size_t i) {
  return getRuleContext<NaturalParser::ExamineOptionsContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ExamineStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ExamineStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::ExamineStatementContext::getRuleIndex() const {
  return NaturalParser::RuleExamineStatement;
}


std::any NaturalParser::ExamineStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitExamineStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ExamineStatementContext* NaturalParser::examineStatement() {
  ExamineStatementContext *_localctx = _tracker.createInstance<ExamineStatementContext>(_ctx, getState());
  enterRule(_localctx, 28, NaturalParser::RuleExamineStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(422);
    match(NaturalParser::EXAMINE);
    setState(423);
    match(NaturalParser::WS);
    setState(430); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(430);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case NaturalParser::IDENTIFIER: {
                  setState(424);
                  variable();
                  break;
                }

                case NaturalParser::STRING: {
                  setState(425);
                  match(NaturalParser::STRING);
                  break;
                }

                case NaturalParser::FOR:
                case NaturalParser::DELETE:
                case NaturalParser::VALUE_OF:
                case NaturalParser::USING:
                case NaturalParser::FULL:
                case NaturalParser::POSITION:
                case NaturalParser::IN:
                case NaturalParser::WITH:
                case NaturalParser::SUBSTRING:
                case NaturalParser::REPLACE:
                case NaturalParser::GIVING:
                case NaturalParser::ABSOLUTE:
                case NaturalParser::CHARPOSITION:
                case NaturalParser::CHARLENGTH:
                case NaturalParser::LENGTH:
                case NaturalParser::NUMBER:
                case NaturalParser::TRANSLATE:
                case NaturalParser::DELIMITER:
                case NaturalParser::UPPPER_CASE:
                case NaturalParser::LOWER_CASE:
                case NaturalParser::INTO:
                case NaturalParser::INVERTED:
                case NaturalParser::INDEX:
                case NaturalParser::PATTERN:
                case NaturalParser::AND_TEXT: {
                  setState(426);
                  examineOptions();
                  break;
                }

                case NaturalParser::LINE_NUMBER: {
                  setState(427);
                  match(NaturalParser::LINE_NUMBER);
                  break;
                }

                case NaturalParser::WS: {
                  setState(428);
                  match(NaturalParser::WS);
                  break;
                }

                case NaturalParser::NL: {
                  setState(429);
                  match(NaturalParser::NL);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(432); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(434);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExamineOptionsContext ------------------------------------------------------------------

NaturalParser::ExamineOptionsContext::ExamineOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::USING() {
  return getToken(NaturalParser::USING, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::FOR() {
  return getToken(NaturalParser::FOR, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::AND_TEXT() {
  return getToken(NaturalParser::AND_TEXT, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::FULL() {
  return getToken(NaturalParser::FULL, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::SUBSTRING() {
  return getToken(NaturalParser::SUBSTRING, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::REPLACE() {
  return getToken(NaturalParser::REPLACE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::DELETE() {
  return getToken(NaturalParser::DELETE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::GIVING() {
  return getToken(NaturalParser::GIVING, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::WITH() {
  return getToken(NaturalParser::WITH, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::ABSOLUTE() {
  return getToken(NaturalParser::ABSOLUTE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::POSITION() {
  return getToken(NaturalParser::POSITION, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::CHARPOSITION() {
  return getToken(NaturalParser::CHARPOSITION, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::CHARLENGTH() {
  return getToken(NaturalParser::CHARLENGTH, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::LENGTH() {
  return getToken(NaturalParser::LENGTH, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::IN() {
  return getToken(NaturalParser::IN, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::NUMBER() {
  return getToken(NaturalParser::NUMBER, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::TRANSLATE() {
  return getToken(NaturalParser::TRANSLATE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::DELIMITER() {
  return getToken(NaturalParser::DELIMITER, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::UPPPER_CASE() {
  return getToken(NaturalParser::UPPPER_CASE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::LOWER_CASE() {
  return getToken(NaturalParser::LOWER_CASE, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::INTO() {
  return getToken(NaturalParser::INTO, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::INVERTED() {
  return getToken(NaturalParser::INVERTED, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::INDEX() {
  return getToken(NaturalParser::INDEX, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::PATTERN() {
  return getToken(NaturalParser::PATTERN, 0);
}

tree::TerminalNode* NaturalParser::ExamineOptionsContext::VALUE_OF() {
  return getToken(NaturalParser::VALUE_OF, 0);
}


size_t NaturalParser::ExamineOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleExamineOptions;
}


std::any NaturalParser::ExamineOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitExamineOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ExamineOptionsContext* NaturalParser::examineOptions() {
  ExamineOptionsContext *_localctx = _tracker.createInstance<ExamineOptionsContext>(_ctx, getState());
  enterRule(_localctx, 30, NaturalParser::RuleExamineOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 282574492532736) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 26388027465729) != 0) || _la == NaturalParser::AND_TEXT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoveStatementContext ------------------------------------------------------------------

NaturalParser::MoveStatementContext::MoveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::MoveStatementContext::MOVE() {
  return getToken(NaturalParser::MOVE, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::MoveStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::MoveStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<NaturalParser::MoveOptionsContext *> NaturalParser::MoveStatementContext::moveOptions() {
  return getRuleContexts<NaturalParser::MoveOptionsContext>();
}

NaturalParser::MoveOptionsContext* NaturalParser::MoveStatementContext::moveOptions(size_t i) {
  return getRuleContext<NaturalParser::MoveOptionsContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::MoveStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::MoveStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::MoveStatementContext::TO() {
  return getToken(NaturalParser::TO, 0);
}


size_t NaturalParser::MoveStatementContext::getRuleIndex() const {
  return NaturalParser::RuleMoveStatement;
}


std::any NaturalParser::MoveStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitMoveStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::MoveStatementContext* NaturalParser::moveStatement() {
  MoveStatementContext *_localctx = _tracker.createInstance<MoveStatementContext>(_ctx, getState());
  enterRule(_localctx, 32, NaturalParser::RuleMoveStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(438);
    match(NaturalParser::MOVE);
    setState(440);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(439);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(445); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(445);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case NaturalParser::ALL:
                case NaturalParser::POSITION:
                case NaturalParser::SUBSTRING:
                case NaturalParser::INDEXED:
                case NaturalParser::BY_NAME:
                case NaturalParser::BY_POSITION:
                case NaturalParser::EDITED:
                case NaturalParser::LEFT:
                case NaturalParser::RIGHT:
                case NaturalParser::JUSTIFIED:
                case NaturalParser::NORMALIZED:
                case NaturalParser::ENCODED:
                case NaturalParser::ROUNDED:
                case NaturalParser::STRING:
                case NaturalParser::LINE_NUMBER:
                case NaturalParser::FLOAT:
                case NaturalParser::INPUT_PARAM:
                case NaturalParser::DATE_CONSTANT:
                case NaturalParser::H_CONSTANT:
                case NaturalParser::LT:
                case NaturalParser::LPAREN:
                case NaturalParser::IDENTIFIER: {
                  setState(442);
                  moveOptions();
                  break;
                }

                case NaturalParser::WS: {
                  setState(443);
                  match(NaturalParser::WS);
                  break;
                }

                case NaturalParser::NL: {
                  setState(444);
                  match(NaturalParser::NL);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(447); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(450);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::TO) {
      setState(449);
      match(NaturalParser::TO);
    }
    setState(455); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(455);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case NaturalParser::ALL:
                case NaturalParser::POSITION:
                case NaturalParser::SUBSTRING:
                case NaturalParser::INDEXED:
                case NaturalParser::BY_NAME:
                case NaturalParser::BY_POSITION:
                case NaturalParser::EDITED:
                case NaturalParser::LEFT:
                case NaturalParser::RIGHT:
                case NaturalParser::JUSTIFIED:
                case NaturalParser::NORMALIZED:
                case NaturalParser::ENCODED:
                case NaturalParser::ROUNDED:
                case NaturalParser::STRING:
                case NaturalParser::LINE_NUMBER:
                case NaturalParser::FLOAT:
                case NaturalParser::INPUT_PARAM:
                case NaturalParser::DATE_CONSTANT:
                case NaturalParser::H_CONSTANT:
                case NaturalParser::LT:
                case NaturalParser::LPAREN:
                case NaturalParser::IDENTIFIER: {
                  setState(452);
                  moveOptions();
                  break;
                }

                case NaturalParser::WS: {
                  setState(453);
                  match(NaturalParser::WS);
                  break;
                }

                case NaturalParser::NL: {
                  setState(454);
                  match(NaturalParser::NL);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(457); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MoveOptionsContext ------------------------------------------------------------------

NaturalParser::MoveOptionsContext::MoveOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::OperandContext* NaturalParser::MoveOptionsContext::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::LT() {
  return getToken(NaturalParser::LT, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::GT() {
  return getToken(NaturalParser::GT, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::ROUNDED() {
  return getToken(NaturalParser::ROUNDED, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::SUBSTRING() {
  return getToken(NaturalParser::SUBSTRING, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::BY_NAME() {
  return getToken(NaturalParser::BY_NAME, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::BY_POSITION() {
  return getToken(NaturalParser::BY_POSITION, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::EDITED() {
  return getToken(NaturalParser::EDITED, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::LEFT() {
  return getToken(NaturalParser::LEFT, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::RIGHT() {
  return getToken(NaturalParser::RIGHT, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::JUSTIFIED() {
  return getToken(NaturalParser::JUSTIFIED, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::NORMALIZED() {
  return getToken(NaturalParser::NORMALIZED, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::ENCODED() {
  return getToken(NaturalParser::ENCODED, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::ALL() {
  return getToken(NaturalParser::ALL, 0);
}

tree::TerminalNode* NaturalParser::MoveOptionsContext::INDEXED() {
  return getToken(NaturalParser::INDEXED, 0);
}


size_t NaturalParser::MoveOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleMoveOptions;
}


std::any NaturalParser::MoveOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitMoveOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::MoveOptionsContext* NaturalParser::moveOptions() {
  MoveOptionsContext *_localctx = _tracker.createInstance<MoveOptionsContext>(_ctx, getState());
  enterRule(_localctx, 34, NaturalParser::RuleMoveOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(476);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::POSITION:
      case NaturalParser::STRING:
      case NaturalParser::LINE_NUMBER:
      case NaturalParser::FLOAT:
      case NaturalParser::INPUT_PARAM:
      case NaturalParser::DATE_CONSTANT:
      case NaturalParser::H_CONSTANT:
      case NaturalParser::LPAREN:
      case NaturalParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(459);
        operand();
        break;
      }

      case NaturalParser::LT: {
        enterOuterAlt(_localctx, 2);
        setState(460);
        match(NaturalParser::LT);
        setState(461);
        operand();
        setState(462);
        match(NaturalParser::GT);
        break;
      }

      case NaturalParser::ROUNDED: {
        enterOuterAlt(_localctx, 3);
        setState(464);
        match(NaturalParser::ROUNDED);
        break;
      }

      case NaturalParser::SUBSTRING: {
        enterOuterAlt(_localctx, 4);
        setState(465);
        match(NaturalParser::SUBSTRING);
        break;
      }

      case NaturalParser::BY_NAME: {
        enterOuterAlt(_localctx, 5);
        setState(466);
        match(NaturalParser::BY_NAME);
        break;
      }

      case NaturalParser::BY_POSITION: {
        enterOuterAlt(_localctx, 6);
        setState(467);
        match(NaturalParser::BY_POSITION);
        break;
      }

      case NaturalParser::EDITED: {
        enterOuterAlt(_localctx, 7);
        setState(468);
        match(NaturalParser::EDITED);
        break;
      }

      case NaturalParser::LEFT: {
        enterOuterAlt(_localctx, 8);
        setState(469);
        match(NaturalParser::LEFT);
        break;
      }

      case NaturalParser::RIGHT: {
        enterOuterAlt(_localctx, 9);
        setState(470);
        match(NaturalParser::RIGHT);
        break;
      }

      case NaturalParser::JUSTIFIED: {
        enterOuterAlt(_localctx, 10);
        setState(471);
        match(NaturalParser::JUSTIFIED);
        break;
      }

      case NaturalParser::NORMALIZED: {
        enterOuterAlt(_localctx, 11);
        setState(472);
        match(NaturalParser::NORMALIZED);
        break;
      }

      case NaturalParser::ENCODED: {
        enterOuterAlt(_localctx, 12);
        setState(473);
        match(NaturalParser::ENCODED);
        break;
      }

      case NaturalParser::ALL: {
        enterOuterAlt(_localctx, 13);
        setState(474);
        match(NaturalParser::ALL);
        break;
      }

      case NaturalParser::INDEXED: {
        enterOuterAlt(_localctx, 14);
        setState(475);
        match(NaturalParser::INDEXED);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatStatementContext ------------------------------------------------------------------

NaturalParser::RepeatStatementContext::RepeatStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::RepeatStatementContext::REPEAT() {
  return getToken(NaturalParser::REPEAT, 0);
}

tree::TerminalNode* NaturalParser::RepeatStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::RepeatStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::RepeatStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::RepeatStatementContext::getRuleIndex() const {
  return NaturalParser::RuleRepeatStatement;
}


std::any NaturalParser::RepeatStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitRepeatStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::RepeatStatementContext* NaturalParser::repeatStatement() {
  RepeatStatementContext *_localctx = _tracker.createInstance<RepeatStatementContext>(_ctx, getState());
  enterRule(_localctx, 36, NaturalParser::RuleRepeatStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    match(NaturalParser::REPEAT);
    setState(482);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0)) {
      setState(479);
      statement();
      setState(484);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(485);
    match(NaturalParser::LOOP);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

NaturalParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::DoStatementContext::DO() {
  return getToken(NaturalParser::DO, 0);
}

tree::TerminalNode* NaturalParser::DoStatementContext::DOEND() {
  return getToken(NaturalParser::DOEND, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::DoStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::DoStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::DoStatementContext::getRuleIndex() const {
  return NaturalParser::RuleDoStatement;
}


std::any NaturalParser::DoStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitDoStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::DoStatementContext* NaturalParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 38, NaturalParser::RuleDoStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(487);
    match(NaturalParser::DO);
    setState(491);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0)) {
      setState(488);
      statement();
      setState(493);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(494);
    match(NaturalParser::DOEND);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StoreStatementContext ------------------------------------------------------------------

NaturalParser::StoreStatementContext::StoreStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::StoreStatementContext::STORE() {
  return getToken(NaturalParser::STORE, 0);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::RECORD() {
  return getToken(NaturalParser::RECORD, 0);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::IN() {
  return getToken(NaturalParser::IN, 0);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::FILE() {
  return getToken(NaturalParser::FILE, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::WITH() {
  return getToken(NaturalParser::WITH, 0);
}

tree::TerminalNode* NaturalParser::StoreStatementContext::SET() {
  return getToken(NaturalParser::SET, 0);
}

std::vector<NaturalParser::StorePreview2Context *> NaturalParser::StoreStatementContext::storePreview2() {
  return getRuleContexts<NaturalParser::StorePreview2Context>();
}

NaturalParser::StorePreview2Context* NaturalParser::StoreStatementContext::storePreview2(size_t i) {
  return getRuleContext<NaturalParser::StorePreview2Context>(i);
}

std::vector<NaturalParser::StoreConditionContext *> NaturalParser::StoreStatementContext::storeCondition() {
  return getRuleContexts<NaturalParser::StoreConditionContext>();
}

NaturalParser::StoreConditionContext* NaturalParser::StoreStatementContext::storeCondition(size_t i) {
  return getRuleContext<NaturalParser::StoreConditionContext>(i);
}


size_t NaturalParser::StoreStatementContext::getRuleIndex() const {
  return NaturalParser::RuleStoreStatement;
}


std::any NaturalParser::StoreStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitStoreStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::StoreStatementContext* NaturalParser::storeStatement() {
  StoreStatementContext *_localctx = _tracker.createInstance<StoreStatementContext>(_ctx, getState());
  enterRule(_localctx, 40, NaturalParser::RuleStoreStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(496);
    match(NaturalParser::STORE);
    setState(498);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(497);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(501);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::RECORD) {
      setState(500);
      match(NaturalParser::RECORD);
    }
    setState(504);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
    case 1: {
      setState(503);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(507);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::IN) {
      setState(506);
      match(NaturalParser::IN);
    }
    setState(510);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      setState(509);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(513);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::FILE) {
      setState(512);
      match(NaturalParser::FILE);
    }
    setState(516);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(515);
      match(NaturalParser::WS);
    }
    setState(518);
    antlrcpp::downCast<StoreStatementContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(520);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(519);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(523);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      setState(522);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(526);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      setState(525);
      match(NaturalParser::WITH);
      break;
    }

    default:
      break;
    }
    setState(529);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(528);
      match(NaturalParser::SET);
      break;
    }

    default:
      break;
    }
    setState(532);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
    case 1: {
      setState(531);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(535);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
    case 1: {
      setState(534);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(540);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(537);
        storePreview2(); 
      }
      setState(542);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx);
    }
    setState(544);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      setState(543);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(547);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
    case 1: {
      setState(546);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(552);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(549);
        storeCondition(); 
      }
      setState(554);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorePreview2Context ------------------------------------------------------------------

NaturalParser::StorePreview2Context::StorePreview2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::StorePreview2Context::PASSWORD() {
  return getToken(NaturalParser::PASSWORD, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::StorePreview2Context::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::COLON() {
  return getToken(NaturalParser::COLON, 0);
}

NaturalParser::OperandContext* NaturalParser::StorePreview2Context::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::CIPHER() {
  return getToken(NaturalParser::CIPHER, 0);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::USING() {
  return getToken(NaturalParser::USING, 0);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::GIVING() {
  return getToken(NaturalParser::GIVING, 0);
}

tree::TerminalNode* NaturalParser::StorePreview2Context::NUMBER() {
  return getToken(NaturalParser::NUMBER, 0);
}


size_t NaturalParser::StorePreview2Context::getRuleIndex() const {
  return NaturalParser::RuleStorePreview2;
}


std::any NaturalParser::StorePreview2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitStorePreview2(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::StorePreview2Context* NaturalParser::storePreview2() {
  StorePreview2Context *_localctx = _tracker.createInstance<StorePreview2Context>(_ctx, getState());
  enterRule(_localctx, 42, NaturalParser::RuleStorePreview2);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(589);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::PASSWORD: {
        enterOuterAlt(_localctx, 1);
        setState(555);
        match(NaturalParser::PASSWORD);
        setState(556);
        match(NaturalParser::WS);
        setState(558);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::COLON) {
          setState(557);
          match(NaturalParser::COLON);
        }
        setState(560);
        match(NaturalParser::EQ);
        setState(562);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
        case 1: {
          setState(561);
          match(NaturalParser::WS);
          break;
        }

        default:
          break;
        }
        setState(565);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
        case 1: {
          setState(564);
          operand();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NaturalParser::CIPHER: {
        enterOuterAlt(_localctx, 2);
        setState(567);
        match(NaturalParser::CIPHER);
        setState(568);
        match(NaturalParser::WS);
        setState(570);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::COLON) {
          setState(569);
          match(NaturalParser::COLON);
        }
        setState(572);
        match(NaturalParser::EQ);
        setState(574);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
        case 1: {
          setState(573);
          match(NaturalParser::WS);
          break;
        }

        default:
          break;
        }
        setState(577);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
        case 1: {
          setState(576);
          operand();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NaturalParser::USING:
      case NaturalParser::GIVING: {
        enterOuterAlt(_localctx, 3);
        setState(579);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::USING

        || _la == NaturalParser::GIVING)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(581);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
        case 1: {
          setState(580);
          match(NaturalParser::WS);
          break;
        }

        default:
          break;
        }
        setState(584);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
        case 1: {
          setState(583);
          match(NaturalParser::NUMBER);
          break;
        }

        default:
          break;
        }
        setState(587);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
        case 1: {
          setState(586);
          operand();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StoreConditionContext ------------------------------------------------------------------

NaturalParser::StoreConditionContext::StoreConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::StoreConditionContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::StoreConditionContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::EQ() {
  return getTokens(NaturalParser::EQ);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::EQ(size_t i) {
  return getToken(NaturalParser::EQ, i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::COLON() {
  return getTokens(NaturalParser::COLON);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::COLON(size_t i) {
  return getToken(NaturalParser::COLON, i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::PLUS() {
  return getTokens(NaturalParser::PLUS);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::PLUS(size_t i) {
  return getToken(NaturalParser::PLUS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::StoreConditionContext::MINUS() {
  return getTokens(NaturalParser::MINUS);
}

tree::TerminalNode* NaturalParser::StoreConditionContext::MINUS(size_t i) {
  return getToken(NaturalParser::MINUS, i);
}


size_t NaturalParser::StoreConditionContext::getRuleIndex() const {
  return NaturalParser::RuleStoreCondition;
}


std::any NaturalParser::StoreConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitStoreCondition(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::StoreConditionContext* NaturalParser::storeCondition() {
  StoreConditionContext *_localctx = _tracker.createInstance<StoreConditionContext>(_ctx, getState());
  enterRule(_localctx, 44, NaturalParser::RuleStoreCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(592);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(591);
      match(NaturalParser::LINE_NUMBER);
      break;
    }

    default:
      break;
    }
    setState(597);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(594);
        match(NaturalParser::WS); 
      }
      setState(599);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
    }
    setState(650);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NaturalParser::POSITION || ((((_la - 272) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 272)) & 2621901) != 0)) {
      setState(600);
      operand();
      setState(602);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
      case 1: {
        setState(601);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(605);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
      case 1: {
        setState(604);
        match(NaturalParser::NL);
        break;
      }

      default:
        break;
      }
      setState(608);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        setState(607);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      default:
        break;
      }
      setState(611);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::COLON) {
        setState(610);
        match(NaturalParser::COLON);
      }
      setState(614);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::NL) {
        setState(613);
        match(NaturalParser::NL);
      }
      setState(617);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::LINE_NUMBER) {
        setState(616);
        match(NaturalParser::LINE_NUMBER);
      }
      setState(620);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(619);
        match(NaturalParser::WS);
      }
      setState(622);
      match(NaturalParser::EQ);
      setState(624);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
      case 1: {
        setState(623);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::NL) {
        setState(626);
        match(NaturalParser::NL);
      }
      setState(630);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
      case 1: {
        setState(629);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      default:
        break;
      }
      setState(635);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1 + 1) {
          setState(632);
          match(NaturalParser::WS); 
        }
        setState(637);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx);
      }
      setState(639);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::PLUS

      || _la == NaturalParser::MINUS) {
        setState(638);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::PLUS

        || _la == NaturalParser::MINUS)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(641);
      operand();
      setState(643);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
      case 1: {
        setState(642);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(646);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
      case 1: {
        setState(645);
        match(NaturalParser::NL);
        break;
      }

      default:
        break;
      }
      setState(652);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(656);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NaturalParser::WS) {
      setState(653);
      match(NaturalParser::WS);
      setState(658);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(659);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindStatementContext ------------------------------------------------------------------

NaturalParser::FindStatementContext::FindStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::FindQueryContext* NaturalParser::FindStatementContext::findQuery() {
  return getRuleContext<NaturalParser::FindQueryContext>(0);
}

NaturalParser::BlockContentContext* NaturalParser::FindStatementContext::blockContent() {
  return getRuleContext<NaturalParser::BlockContentContext>(0);
}

tree::TerminalNode* NaturalParser::FindStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

tree::TerminalNode* NaturalParser::FindStatementContext::END_FIND() {
  return getToken(NaturalParser::END_FIND, 0);
}

NaturalParser::FindNumberContext* NaturalParser::FindStatementContext::findNumber() {
  return getRuleContext<NaturalParser::FindNumberContext>(0);
}


size_t NaturalParser::FindStatementContext::getRuleIndex() const {
  return NaturalParser::RuleFindStatement;
}


std::any NaturalParser::FindStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFindStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FindStatementContext* NaturalParser::findStatement() {
  FindStatementContext *_localctx = _tracker.createInstance<FindStatementContext>(_ctx, getState());
  enterRule(_localctx, 46, NaturalParser::RuleFindStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(666);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(661);
      findQuery();
      setState(662);
      blockContent();
      setState(663);
      antlrcpp::downCast<FindStatementContext *>(_localctx)->endBlock = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::LOOP

      || _la == NaturalParser::END_FIND)) {
        antlrcpp::downCast<FindStatementContext *>(_localctx)->endBlock = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(665);
      findNumber();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindQueryContext ------------------------------------------------------------------

NaturalParser::FindQueryContext::FindQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FindQueryContext::FIND() {
  return getToken(NaturalParser::FIND, 0);
}

NaturalParser::FindPreview2Context* NaturalParser::FindQueryContext::findPreview2() {
  return getRuleContext<NaturalParser::FindPreview2Context>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::FindQueryContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::FindQueryContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::FindQueryContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<NaturalParser::FindPreview1Context *> NaturalParser::FindQueryContext::findPreview1() {
  return getRuleContexts<NaturalParser::FindPreview1Context>();
}

NaturalParser::FindPreview1Context* NaturalParser::FindQueryContext::findPreview1(size_t i) {
  return getRuleContext<NaturalParser::FindPreview1Context>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindQueryContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FindQueryContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindQueryContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::FindQueryContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::FindQueryContext::getRuleIndex() const {
  return NaturalParser::RuleFindQuery;
}


std::any NaturalParser::FindQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFindQuery(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FindQueryContext* NaturalParser::findQuery() {
  FindQueryContext *_localctx = _tracker.createInstance<FindQueryContext>(_ctx, getState());
  enterRule(_localctx, 48, NaturalParser::RuleFindQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(668);
    match(NaturalParser::FIND);
    setState(675);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(673);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::FIRST:
          case NaturalParser::ALL:
          case NaturalParser::UNIQUE_LEX:
          case NaturalParser::IN:
          case NaturalParser::RECORD:
          case NaturalParser::RECORDS:
          case NaturalParser::MULTI_FETCH:
          case NaturalParser::FILE:
          case NaturalParser::LINE_REF:
          case NaturalParser::IDENTIFIER: {
            setState(669);
            findPreview1();
            break;
          }

          case NaturalParser::WS: {
            setState(670);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(671);
            match(NaturalParser::NL);
            break;
          }

          case NaturalParser::LINE_NUMBER: {
            setState(672);
            match(NaturalParser::LINE_NUMBER);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(677);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 91, _ctx);
    }
    setState(678);
    antlrcpp::downCast<FindQueryContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(680);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      setState(679);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(682);
    findPreview2();
    setState(683);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindNumberContext ------------------------------------------------------------------

NaturalParser::FindNumberContext::FindNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FindNumberContext::FIND() {
  return getToken(NaturalParser::FIND, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FindNumberContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FindNumberContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::FindNumberContext::NUMBER() {
  return getToken(NaturalParser::NUMBER, 0);
}

NaturalParser::FindPreview2Context* NaturalParser::FindNumberContext::findPreview2() {
  return getRuleContext<NaturalParser::FindPreview2Context>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::FindNumberContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::FindNumberContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::FindNumberContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<NaturalParser::FindPreview1Context *> NaturalParser::FindNumberContext::findPreview1() {
  return getRuleContexts<NaturalParser::FindPreview1Context>();
}

NaturalParser::FindPreview1Context* NaturalParser::FindNumberContext::findPreview1(size_t i) {
  return getRuleContext<NaturalParser::FindPreview1Context>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindNumberContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::FindNumberContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::FindNumberContext::getRuleIndex() const {
  return NaturalParser::RuleFindNumber;
}


std::any NaturalParser::FindNumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFindNumber(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FindNumberContext* NaturalParser::findNumber() {
  FindNumberContext *_localctx = _tracker.createInstance<FindNumberContext>(_ctx, getState());
  enterRule(_localctx, 50, NaturalParser::RuleFindNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(NaturalParser::FIND);
    setState(686);
    match(NaturalParser::WS);
    setState(687);
    match(NaturalParser::NUMBER);
    setState(694);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(692);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::FIRST:
          case NaturalParser::ALL:
          case NaturalParser::UNIQUE_LEX:
          case NaturalParser::IN:
          case NaturalParser::RECORD:
          case NaturalParser::RECORDS:
          case NaturalParser::MULTI_FETCH:
          case NaturalParser::FILE:
          case NaturalParser::LINE_REF:
          case NaturalParser::IDENTIFIER: {
            setState(688);
            findPreview1();
            break;
          }

          case NaturalParser::WS: {
            setState(689);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(690);
            match(NaturalParser::NL);
            break;
          }

          case NaturalParser::LINE_NUMBER: {
            setState(691);
            match(NaturalParser::LINE_NUMBER);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(696);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 94, _ctx);
    }
    setState(697);
    antlrcpp::downCast<FindNumberContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(699);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx)) {
    case 1: {
      setState(698);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(701);
    findPreview2();
    setState(702);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindPreview1Context ------------------------------------------------------------------

NaturalParser::FindPreview1Context::FindPreview1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FindPreview1Context::FIRST() {
  return getToken(NaturalParser::FIRST, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::UNIQUE_LEX() {
  return getToken(NaturalParser::UNIQUE_LEX, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::ALL() {
  return getToken(NaturalParser::ALL, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

NaturalParser::VariableContext* NaturalParser::FindPreview1Context::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::MULTI_FETCH() {
  return getToken(NaturalParser::MULTI_FETCH, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview1Context::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::OF() {
  return getToken(NaturalParser::OF, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::ON() {
  return getToken(NaturalParser::ON, 0);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::OFF() {
  return getToken(NaturalParser::OFF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview1Context::RECORD() {
  return getTokens(NaturalParser::RECORD);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::RECORD(size_t i) {
  return getToken(NaturalParser::RECORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview1Context::RECORDS() {
  return getTokens(NaturalParser::RECORDS);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::RECORDS(size_t i) {
  return getToken(NaturalParser::RECORDS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview1Context::IN() {
  return getTokens(NaturalParser::IN);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::IN(size_t i) {
  return getToken(NaturalParser::IN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview1Context::FILE() {
  return getTokens(NaturalParser::FILE);
}

tree::TerminalNode* NaturalParser::FindPreview1Context::FILE(size_t i) {
  return getToken(NaturalParser::FILE, i);
}


size_t NaturalParser::FindPreview1Context::getRuleIndex() const {
  return NaturalParser::RuleFindPreview1;
}


std::any NaturalParser::FindPreview1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFindPreview1(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FindPreview1Context* NaturalParser::findPreview1() {
  FindPreview1Context *_localctx = _tracker.createInstance<FindPreview1Context>(_ctx, getState());
  enterRule(_localctx, 52, NaturalParser::RuleFindPreview1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(724);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::FIRST:
      case NaturalParser::ALL:
      case NaturalParser::UNIQUE_LEX:
      case NaturalParser::LINE_REF:
      case NaturalParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(710);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 96, _ctx)) {
        case 1: {
          setState(704);
          match(NaturalParser::FIRST);
          break;
        }

        case 2: {
          setState(705);
          match(NaturalParser::UNIQUE_LEX);
          break;
        }

        case 3: {
          setState(706);
          match(NaturalParser::ALL);
          break;
        }

        case 4: {
          setState(707);
          match(NaturalParser::IDENTIFIER);
          break;
        }

        case 5: {
          setState(708);
          match(NaturalParser::LINE_REF);
          break;
        }

        case 6: {
          setState(709);
          variable();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NaturalParser::MULTI_FETCH: {
        enterOuterAlt(_localctx, 2);
        setState(712);
        match(NaturalParser::MULTI_FETCH);
        setState(715);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 97, _ctx)) {
        case 1: {
          setState(713);
          match(NaturalParser::WS);
          setState(714);
          _la = _input->LA(1);
          if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 218)) & 8195) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(717);
        match(NaturalParser::WS);
        setState(718);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      case NaturalParser::IN:
      case NaturalParser::RECORD:
      case NaturalParser::RECORDS:
      case NaturalParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(720); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(719);
                  _la = _input->LA(1);
                  if (!(((((_la - 81) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 81)) & 13) != 0) || _la == NaturalParser::FILE)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(722); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FindPreview2Context ------------------------------------------------------------------

NaturalParser::FindPreview2Context::FindPreview2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::OperandContext *> NaturalParser::FindPreview2Context::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::FindPreview2Context::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::PASSWORD() {
  return getTokens(NaturalParser::PASSWORD);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::PASSWORD(size_t i) {
  return getToken(NaturalParser::PASSWORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::CIPHER() {
  return getTokens(NaturalParser::CIPHER);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::CIPHER(size_t i) {
  return getToken(NaturalParser::CIPHER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::WITH() {
  return getTokens(NaturalParser::WITH);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::WITH(size_t i) {
  return getToken(NaturalParser::WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::LIMIT() {
  return getTokens(NaturalParser::LIMIT);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::LIMIT(size_t i) {
  return getToken(NaturalParser::LIMIT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::COUPLED() {
  return getTokens(NaturalParser::COUPLED);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::COUPLED(size_t i) {
  return getToken(NaturalParser::COUPLED, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::STARTING_WITH() {
  return getTokens(NaturalParser::STARTING_WITH);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::STARTING_WITH(size_t i) {
  return getToken(NaturalParser::STARTING_WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::SORTED() {
  return getTokens(NaturalParser::SORTED);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::SORTED(size_t i) {
  return getToken(NaturalParser::SORTED, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::BY() {
  return getTokens(NaturalParser::BY);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::BY(size_t i) {
  return getToken(NaturalParser::BY, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::RETAIN_AS() {
  return getTokens(NaturalParser::RETAIN_AS);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::RETAIN_AS(size_t i) {
  return getToken(NaturalParser::RETAIN_AS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::WHERE() {
  return getTokens(NaturalParser::WHERE);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::WHERE(size_t i) {
  return getToken(NaturalParser::WHERE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::VIA() {
  return getTokens(NaturalParser::VIA);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::VIA(size_t i) {
  return getToken(NaturalParser::VIA, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::THRU() {
  return getTokens(NaturalParser::THRU);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::THRU(size_t i) {
  return getToken(NaturalParser::THRU, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::DESCENDING() {
  return getTokens(NaturalParser::DESCENDING);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::DESCENDING(size_t i) {
  return getToken(NaturalParser::DESCENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::AND() {
  return getTokens(NaturalParser::AND);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::AND(size_t i) {
  return getToken(NaturalParser::AND, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::TO() {
  return getTokens(NaturalParser::TO);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::TO(size_t i) {
  return getToken(NaturalParser::TO, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::FROM() {
  return getTokens(NaturalParser::FROM);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::FROM(size_t i) {
  return getToken(NaturalParser::FROM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::BY_NAME() {
  return getTokens(NaturalParser::BY_NAME);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::BY_NAME(size_t i) {
  return getToken(NaturalParser::BY_NAME, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::BY_POSITION() {
  return getTokens(NaturalParser::BY_POSITION);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::BY_POSITION(size_t i) {
  return getToken(NaturalParser::BY_POSITION, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FindPreview2Context::BUT() {
  return getTokens(NaturalParser::BUT);
}

tree::TerminalNode* NaturalParser::FindPreview2Context::BUT(size_t i) {
  return getToken(NaturalParser::BUT, i);
}

std::vector<NaturalParser::CompOpContext *> NaturalParser::FindPreview2Context::compOp() {
  return getRuleContexts<NaturalParser::CompOpContext>();
}

NaturalParser::CompOpContext* NaturalParser::FindPreview2Context::compOp(size_t i) {
  return getRuleContext<NaturalParser::CompOpContext>(i);
}

std::vector<NaturalParser::LogicalOpContext *> NaturalParser::FindPreview2Context::logicalOp() {
  return getRuleContexts<NaturalParser::LogicalOpContext>();
}

NaturalParser::LogicalOpContext* NaturalParser::FindPreview2Context::logicalOp(size_t i) {
  return getRuleContext<NaturalParser::LogicalOpContext>(i);
}


size_t NaturalParser::FindPreview2Context::getRuleIndex() const {
  return NaturalParser::RuleFindPreview2;
}


std::any NaturalParser::FindPreview2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFindPreview2(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FindPreview2Context* NaturalParser::findPreview2() {
  FindPreview2Context *_localctx = _tracker.createInstance<FindPreview2Context>(_ctx, getState());
  enterRule(_localctx, 54, NaturalParser::RuleFindPreview2);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(753);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(751);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
        case 1: {
          setState(726);
          operand();
          break;
        }

        case 2: {
          setState(727);
          match(NaturalParser::WS);
          break;
        }

        case 3: {
          setState(728);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        case 4: {
          setState(729);
          match(NaturalParser::NL);
          break;
        }

        case 5: {
          setState(730);
          match(NaturalParser::PASSWORD);
          break;
        }

        case 6: {
          setState(731);
          match(NaturalParser::CIPHER);
          break;
        }

        case 7: {
          setState(732);
          match(NaturalParser::WITH);
          break;
        }

        case 8: {
          setState(733);
          match(NaturalParser::LIMIT);
          break;
        }

        case 9: {
          setState(734);
          match(NaturalParser::COUPLED);
          break;
        }

        case 10: {
          setState(735);
          match(NaturalParser::STARTING_WITH);
          break;
        }

        case 11: {
          setState(736);
          match(NaturalParser::SORTED);
          break;
        }

        case 12: {
          setState(737);
          match(NaturalParser::BY);
          break;
        }

        case 13: {
          setState(738);
          match(NaturalParser::RETAIN_AS);
          break;
        }

        case 14: {
          setState(739);
          match(NaturalParser::WHERE);
          break;
        }

        case 15: {
          setState(740);
          match(NaturalParser::VIA);
          break;
        }

        case 16: {
          setState(741);
          match(NaturalParser::THRU);
          break;
        }

        case 17: {
          setState(742);
          match(NaturalParser::DESCENDING);
          break;
        }

        case 18: {
          setState(743);
          match(NaturalParser::AND);
          break;
        }

        case 19: {
          setState(744);
          match(NaturalParser::TO);
          break;
        }

        case 20: {
          setState(745);
          match(NaturalParser::FROM);
          break;
        }

        case 21: {
          setState(746);
          match(NaturalParser::BY_NAME);
          break;
        }

        case 22: {
          setState(747);
          match(NaturalParser::BY_POSITION);
          break;
        }

        case 23: {
          setState(748);
          match(NaturalParser::BUT);
          break;
        }

        case 24: {
          setState(749);
          compOp();
          break;
        }

        case 25: {
          setState(750);
          logicalOp();
          break;
        }

        default:
          break;
        } 
      }
      setState(755);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadStatementContext ------------------------------------------------------------------

NaturalParser::ReadStatementContext::ReadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::ReadQueryContext* NaturalParser::ReadStatementContext::readQuery() {
  return getRuleContext<NaturalParser::ReadQueryContext>(0);
}

NaturalParser::BlockContentContext* NaturalParser::ReadStatementContext::blockContent() {
  return getRuleContext<NaturalParser::BlockContentContext>(0);
}

tree::TerminalNode* NaturalParser::ReadStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

tree::TerminalNode* NaturalParser::ReadStatementContext::END_READ() {
  return getToken(NaturalParser::END_READ, 0);
}


size_t NaturalParser::ReadStatementContext::getRuleIndex() const {
  return NaturalParser::RuleReadStatement;
}


std::any NaturalParser::ReadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadStatementContext* NaturalParser::readStatement() {
  ReadStatementContext *_localctx = _tracker.createInstance<ReadStatementContext>(_ctx, getState());
  enterRule(_localctx, 56, NaturalParser::RuleReadStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(756);
    readQuery();
    setState(757);
    blockContent();
    setState(758);
    antlrcpp::downCast<ReadStatementContext *>(_localctx)->endBlock = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::LOOP

    || _la == NaturalParser::END_READ)) {
      antlrcpp::downCast<ReadStatementContext *>(_localctx)->endBlock = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadQueryContext ------------------------------------------------------------------

NaturalParser::ReadQueryContext::ReadQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ReadQueryContext::READ() {
  return getToken(NaturalParser::READ, 0);
}

NaturalParser::ReadPreview2Context* NaturalParser::ReadQueryContext::readPreview2() {
  return getRuleContext<NaturalParser::ReadPreview2Context>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadQueryContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ReadQueryContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::ReadQueryContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<NaturalParser::ReadPreview1Context *> NaturalParser::ReadQueryContext::readPreview1() {
  return getRuleContexts<NaturalParser::ReadPreview1Context>();
}

NaturalParser::ReadPreview1Context* NaturalParser::ReadQueryContext::readPreview1(size_t i) {
  return getRuleContext<NaturalParser::ReadPreview1Context>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadQueryContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReadQueryContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadQueryContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ReadQueryContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::ReadQueryContext::getRuleIndex() const {
  return NaturalParser::RuleReadQuery;
}


std::any NaturalParser::ReadQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadQuery(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadQueryContext* NaturalParser::readQuery() {
  ReadQueryContext *_localctx = _tracker.createInstance<ReadQueryContext>(_ctx, getState());
  enterRule(_localctx, 58, NaturalParser::RuleReadQuery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(760);
    match(NaturalParser::READ);
    setState(767);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(765);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::ALL:
          case NaturalParser::IN:
          case NaturalParser::RECORD:
          case NaturalParser::RECORDS:
          case NaturalParser::MULTI_FETCH:
          case NaturalParser::FILE:
          case NaturalParser::LINE_REF:
          case NaturalParser::IDENTIFIER: {
            setState(761);
            readPreview1();
            break;
          }

          case NaturalParser::WS: {
            setState(762);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(763);
            match(NaturalParser::NL);
            break;
          }

          case NaturalParser::LINE_NUMBER: {
            setState(764);
            match(NaturalParser::LINE_NUMBER);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(769);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    }
    setState(770);
    antlrcpp::downCast<ReadQueryContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(772);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(771);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(774);
    readPreview2();
    setState(775);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadPreview1Context ------------------------------------------------------------------

NaturalParser::ReadPreview1Context::ReadPreview1Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::ALL() {
  return getToken(NaturalParser::ALL, 0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

NaturalParser::VariableContext* NaturalParser::ReadPreview1Context::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::MULTI_FETCH() {
  return getToken(NaturalParser::MULTI_FETCH, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview1Context::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::OF() {
  return getToken(NaturalParser::OF, 0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::ON() {
  return getToken(NaturalParser::ON, 0);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::OFF() {
  return getToken(NaturalParser::OFF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview1Context::RECORD() {
  return getTokens(NaturalParser::RECORD);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::RECORD(size_t i) {
  return getToken(NaturalParser::RECORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview1Context::RECORDS() {
  return getTokens(NaturalParser::RECORDS);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::RECORDS(size_t i) {
  return getToken(NaturalParser::RECORDS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview1Context::IN() {
  return getTokens(NaturalParser::IN);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::IN(size_t i) {
  return getToken(NaturalParser::IN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview1Context::FILE() {
  return getTokens(NaturalParser::FILE);
}

tree::TerminalNode* NaturalParser::ReadPreview1Context::FILE(size_t i) {
  return getToken(NaturalParser::FILE, i);
}


size_t NaturalParser::ReadPreview1Context::getRuleIndex() const {
  return NaturalParser::RuleReadPreview1;
}


std::any NaturalParser::ReadPreview1Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadPreview1(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadPreview1Context* NaturalParser::readPreview1() {
  ReadPreview1Context *_localctx = _tracker.createInstance<ReadPreview1Context>(_ctx, getState());
  enterRule(_localctx, 60, NaturalParser::RuleReadPreview1);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::ALL:
      case NaturalParser::LINE_REF:
      case NaturalParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(781);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
        case 1: {
          setState(777);
          match(NaturalParser::ALL);
          break;
        }

        case 2: {
          setState(778);
          match(NaturalParser::IDENTIFIER);
          break;
        }

        case 3: {
          setState(779);
          match(NaturalParser::LINE_REF);
          break;
        }

        case 4: {
          setState(780);
          variable();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NaturalParser::MULTI_FETCH: {
        enterOuterAlt(_localctx, 2);
        setState(783);
        match(NaturalParser::MULTI_FETCH);
        setState(786);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
        case 1: {
          setState(784);
          match(NaturalParser::WS);
          setState(785);
          _la = _input->LA(1);
          if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 218)) & 8195) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(788);
        match(NaturalParser::WS);
        setState(789);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      case NaturalParser::IN:
      case NaturalParser::RECORD:
      case NaturalParser::RECORDS:
      case NaturalParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(791); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(790);
                  _la = _input->LA(1);
                  if (!(((((_la - 81) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 81)) & 13) != 0) || _la == NaturalParser::FILE)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(793); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadPreview2Context ------------------------------------------------------------------

NaturalParser::ReadPreview2Context::ReadPreview2Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::OperandContext *> NaturalParser::ReadPreview2Context::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::ReadPreview2Context::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::PASSWORD() {
  return getTokens(NaturalParser::PASSWORD);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::PASSWORD(size_t i) {
  return getToken(NaturalParser::PASSWORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::CIPHER() {
  return getTokens(NaturalParser::CIPHER);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::CIPHER(size_t i) {
  return getToken(NaturalParser::CIPHER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::WITH() {
  return getTokens(NaturalParser::WITH);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::WITH(size_t i) {
  return getToken(NaturalParser::WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::REPOSITION() {
  return getTokens(NaturalParser::REPOSITION);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::REPOSITION(size_t i) {
  return getToken(NaturalParser::REPOSITION, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::STARTING_WITH() {
  return getTokens(NaturalParser::STARTING_WITH);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::STARTING_WITH(size_t i) {
  return getToken(NaturalParser::STARTING_WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::WHERE() {
  return getTokens(NaturalParser::WHERE);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::WHERE(size_t i) {
  return getToken(NaturalParser::WHERE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::BY() {
  return getTokens(NaturalParser::BY);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::BY(size_t i) {
  return getToken(NaturalParser::BY, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::STARTING() {
  return getTokens(NaturalParser::STARTING);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::STARTING(size_t i) {
  return getToken(NaturalParser::STARTING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::ENDING() {
  return getTokens(NaturalParser::ENDING);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::ENDING(size_t i) {
  return getToken(NaturalParser::ENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::AT() {
  return getTokens(NaturalParser::AT);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::AT(size_t i) {
  return getToken(NaturalParser::AT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::THRU() {
  return getTokens(NaturalParser::THRU);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::THRU(size_t i) {
  return getToken(NaturalParser::THRU, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::DESCENDING() {
  return getTokens(NaturalParser::DESCENDING);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::DESCENDING(size_t i) {
  return getToken(NaturalParser::DESCENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::AND() {
  return getTokens(NaturalParser::AND);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::AND(size_t i) {
  return getToken(NaturalParser::AND, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::TO() {
  return getTokens(NaturalParser::TO);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::TO(size_t i) {
  return getToken(NaturalParser::TO, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::FROM() {
  return getTokens(NaturalParser::FROM);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::FROM(size_t i) {
  return getToken(NaturalParser::FROM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::BY_NAME() {
  return getTokens(NaturalParser::BY_NAME);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::BY_NAME(size_t i) {
  return getToken(NaturalParser::BY_NAME, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::BY_POSITION() {
  return getTokens(NaturalParser::BY_POSITION);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::BY_POSITION(size_t i) {
  return getToken(NaturalParser::BY_POSITION, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::IN() {
  return getTokens(NaturalParser::IN);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::IN(size_t i) {
  return getToken(NaturalParser::IN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::PHYSICAL() {
  return getTokens(NaturalParser::PHYSICAL);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::PHYSICAL(size_t i) {
  return getToken(NaturalParser::PHYSICAL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::ASCENDING() {
  return getTokens(NaturalParser::ASCENDING);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::ASCENDING(size_t i) {
  return getToken(NaturalParser::ASCENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::VARIABLE() {
  return getTokens(NaturalParser::VARIABLE);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::VARIABLE(size_t i) {
  return getToken(NaturalParser::VARIABLE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::DYNAMIC() {
  return getTokens(NaturalParser::DYNAMIC);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::DYNAMIC(size_t i) {
  return getToken(NaturalParser::DYNAMIC, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::SEQUENCE() {
  return getTokens(NaturalParser::SEQUENCE);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::SEQUENCE(size_t i) {
  return getToken(NaturalParser::SEQUENCE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::STARTING_FROM() {
  return getTokens(NaturalParser::STARTING_FROM);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::STARTING_FROM(size_t i) {
  return getToken(NaturalParser::STARTING_FROM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::ENDING_AT() {
  return getTokens(NaturalParser::ENDING_AT);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::ENDING_AT(size_t i) {
  return getToken(NaturalParser::ENDING_AT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadPreview2Context::BUT() {
  return getTokens(NaturalParser::BUT);
}

tree::TerminalNode* NaturalParser::ReadPreview2Context::BUT(size_t i) {
  return getToken(NaturalParser::BUT, i);
}

std::vector<NaturalParser::CompOpContext *> NaturalParser::ReadPreview2Context::compOp() {
  return getRuleContexts<NaturalParser::CompOpContext>();
}

NaturalParser::CompOpContext* NaturalParser::ReadPreview2Context::compOp(size_t i) {
  return getRuleContext<NaturalParser::CompOpContext>(i);
}

std::vector<NaturalParser::LogicalOpContext *> NaturalParser::ReadPreview2Context::logicalOp() {
  return getRuleContexts<NaturalParser::LogicalOpContext>();
}

NaturalParser::LogicalOpContext* NaturalParser::ReadPreview2Context::logicalOp(size_t i) {
  return getRuleContext<NaturalParser::LogicalOpContext>(i);
}


size_t NaturalParser::ReadPreview2Context::getRuleIndex() const {
  return NaturalParser::RuleReadPreview2;
}


std::any NaturalParser::ReadPreview2Context::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadPreview2(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadPreview2Context* NaturalParser::readPreview2() {
  ReadPreview2Context *_localctx = _tracker.createInstance<ReadPreview2Context>(_ctx, getState());
  enterRule(_localctx, 62, NaturalParser::RuleReadPreview2);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(831);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(829);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
        case 1: {
          setState(797);
          operand();
          break;
        }

        case 2: {
          setState(798);
          match(NaturalParser::WS);
          break;
        }

        case 3: {
          setState(799);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        case 4: {
          setState(800);
          match(NaturalParser::NL);
          break;
        }

        case 5: {
          setState(801);
          match(NaturalParser::PASSWORD);
          break;
        }

        case 6: {
          setState(802);
          match(NaturalParser::CIPHER);
          break;
        }

        case 7: {
          setState(803);
          match(NaturalParser::WITH);
          break;
        }

        case 8: {
          setState(804);
          match(NaturalParser::REPOSITION);
          break;
        }

        case 9: {
          setState(805);
          match(NaturalParser::STARTING_WITH);
          break;
        }

        case 10: {
          setState(806);
          match(NaturalParser::WHERE);
          break;
        }

        case 11: {
          setState(807);
          match(NaturalParser::BY);
          break;
        }

        case 12: {
          setState(808);
          match(NaturalParser::STARTING);
          break;
        }

        case 13: {
          setState(809);
          match(NaturalParser::ENDING);
          break;
        }

        case 14: {
          setState(810);
          match(NaturalParser::AT);
          break;
        }

        case 15: {
          setState(811);
          match(NaturalParser::THRU);
          break;
        }

        case 16: {
          setState(812);
          match(NaturalParser::DESCENDING);
          break;
        }

        case 17: {
          setState(813);
          match(NaturalParser::AND);
          break;
        }

        case 18: {
          setState(814);
          match(NaturalParser::TO);
          break;
        }

        case 19: {
          setState(815);
          match(NaturalParser::FROM);
          break;
        }

        case 20: {
          setState(816);
          match(NaturalParser::BY_NAME);
          break;
        }

        case 21: {
          setState(817);
          match(NaturalParser::BY_POSITION);
          break;
        }

        case 22: {
          setState(818);
          match(NaturalParser::IN);
          break;
        }

        case 23: {
          setState(819);
          match(NaturalParser::PHYSICAL);
          break;
        }

        case 24: {
          setState(820);
          match(NaturalParser::ASCENDING);
          break;
        }

        case 25: {
          setState(821);
          match(NaturalParser::VARIABLE);
          break;
        }

        case 26: {
          setState(822);
          match(NaturalParser::DYNAMIC);
          break;
        }

        case 27: {
          setState(823);
          match(NaturalParser::SEQUENCE);
          break;
        }

        case 28: {
          setState(824);
          match(NaturalParser::STARTING_FROM);
          break;
        }

        case 29: {
          setState(825);
          match(NaturalParser::ENDING_AT);
          break;
        }

        case 30: {
          setState(826);
          match(NaturalParser::BUT);
          break;
        }

        case 31: {
          setState(827);
          compOp();
          break;
        }

        case 32: {
          setState(828);
          logicalOp();
          break;
        }

        default:
          break;
        } 
      }
      setState(833);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStatementContext ------------------------------------------------------------------

NaturalParser::UpdateStatementContext::UpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::UpdateStartlineContext* NaturalParser::UpdateStatementContext::updateStartline() {
  return getRuleContext<NaturalParser::UpdateStartlineContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::UpdateStatementContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::UpdateStatementContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStatementContext::EQ() {
  return getTokens(NaturalParser::EQ);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::EQ(size_t i) {
  return getToken(NaturalParser::EQ, i);
}

std::vector<NaturalParser::CalculationsContext *> NaturalParser::UpdateStatementContext::calculations() {
  return getRuleContexts<NaturalParser::CalculationsContext>();
}

NaturalParser::CalculationsContext* NaturalParser::UpdateStatementContext::calculations(size_t i) {
  return getRuleContext<NaturalParser::CalculationsContext>(i);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::SET() {
  return getToken(NaturalParser::SET, 0);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::WITH() {
  return getToken(NaturalParser::WITH, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStatementContext::COLON() {
  return getTokens(NaturalParser::COLON);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::COLON(size_t i) {
  return getToken(NaturalParser::COLON, i);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::USING() {
  return getToken(NaturalParser::USING, 0);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::SAME() {
  return getToken(NaturalParser::SAME, 0);
}

tree::TerminalNode* NaturalParser::UpdateStatementContext::RECORD() {
  return getToken(NaturalParser::RECORD, 0);
}


size_t NaturalParser::UpdateStatementContext::getRuleIndex() const {
  return NaturalParser::RuleUpdateStatement;
}


std::any NaturalParser::UpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::UpdateStatementContext* NaturalParser::updateStatement() {
  UpdateStatementContext *_localctx = _tracker.createInstance<UpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, NaturalParser::RuleUpdateStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(887);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(834);
      updateStartline();
      setState(836); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(835);
                _la = _input->LA(1);
                if (!(_la == NaturalParser::WS

                || _la == NaturalParser::NL)) {
                _errHandler->recoverInline(this);
                }
                else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(838); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::SET

      || _la == NaturalParser::WITH) {
        setState(840);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::SET

        || _la == NaturalParser::WITH)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      setState(860); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(860);
                _errHandler->sync(this);
                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
                case 1: {
                  setState(843);
                  match(NaturalParser::WS);
                  break;
                }

                case 2: {
                  setState(844);
                  match(NaturalParser::NL);
                  break;
                }

                case 3: {
                  setState(845);
                  match(NaturalParser::LINE_NUMBER);
                  break;
                }

                case 4: {
                  setState(846);
                  operand();
                  setState(848);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == NaturalParser::WS) {
                    setState(847);
                    match(NaturalParser::WS);
                  }
                  setState(851);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == NaturalParser::COLON) {
                    setState(850);
                    match(NaturalParser::COLON);
                  }
                  setState(853);
                  match(NaturalParser::EQ);
                  setState(855);
                  _errHandler->sync(this);

                  _la = _input->LA(1);
                  if (_la == NaturalParser::WS) {
                    setState(854);
                    match(NaturalParser::WS);
                  }
                  setState(857);
                  operand();
                  break;
                }

                case 5: {
                  setState(859);
                  calculations();
                  break;
                }

                default:
                  break;
                }
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(862); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(865);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(864);
        match(NaturalParser::WS);
      }
      setState(867);
      match(NaturalParser::NL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(869);
      updateStartline();
      setState(870);
      match(NaturalParser::WS);
      setState(871);
      match(NaturalParser::USING);
      setState(872);
      match(NaturalParser::WS);
      setState(873);
      match(NaturalParser::SAME);
      setState(874);
      match(NaturalParser::WS);
      setState(875);
      match(NaturalParser::RECORD);
      setState(877);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(876);
        match(NaturalParser::WS);
      }
      setState(879);
      match(NaturalParser::NL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(881);
      updateStartline();
      setState(883);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(882);
        match(NaturalParser::WS);
      }
      setState(885);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStartlineContext ------------------------------------------------------------------

NaturalParser::UpdateStartlineContext::UpdateStartlineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::UPDATE() {
  return getToken(NaturalParser::UPDATE, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::UpdateStartlineContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::RECORD() {
  return getToken(NaturalParser::RECORD, 0);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::IN() {
  return getToken(NaturalParser::IN, 0);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::STATEMENT() {
  return getToken(NaturalParser::STATEMENT, 0);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

tree::TerminalNode* NaturalParser::UpdateStartlineContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}


size_t NaturalParser::UpdateStartlineContext::getRuleIndex() const {
  return NaturalParser::RuleUpdateStartline;
}


std::any NaturalParser::UpdateStartlineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitUpdateStartline(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::UpdateStartlineContext* NaturalParser::updateStartline() {
  UpdateStartlineContext *_localctx = _tracker.createInstance<UpdateStartlineContext>(_ctx, getState());
  enterRule(_localctx, 66, NaturalParser::RuleUpdateStartline);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(889);
    match(NaturalParser::UPDATE);
    setState(891);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(890);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(894);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::RECORD) {
      setState(893);
      match(NaturalParser::RECORD);
    }
    setState(897);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      setState(896);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(900);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::IN) {
      setState(899);
      match(NaturalParser::IN);
    }
    setState(903);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      setState(902);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(906);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::STATEMENT) {
      setState(905);
      match(NaturalParser::STATEMENT);
    }
    setState(909);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      setState(908);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(912);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::LINE_REF

    || _la == NaturalParser::IDENTIFIER) {
      setState(911);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::LINE_REF

      || _la == NaturalParser::IDENTIFIER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

NaturalParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::DeleteStatementContext::DELETE() {
  return getToken(NaturalParser::DELETE, 0);
}

tree::TerminalNode* NaturalParser::DeleteStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::DeleteStatementContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}


size_t NaturalParser::DeleteStatementContext::getRuleIndex() const {
  return NaturalParser::RuleDeleteStatement;
}


std::any NaturalParser::DeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::DeleteStatementContext* NaturalParser::deleteStatement() {
  DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, NaturalParser::RuleDeleteStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    match(NaturalParser::DELETE);
    setState(916);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
    case 1: {
      setState(915);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(919);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
    case 1: {
      setState(918);
      match(NaturalParser::LINE_REF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetStatementsContext ------------------------------------------------------------------

NaturalParser::GetStatementsContext::GetStatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::GetTabledStatementsContext* NaturalParser::GetStatementsContext::getTabledStatements() {
  return getRuleContext<NaturalParser::GetTabledStatementsContext>(0);
}

NaturalParser::GetTransactionStatementContext* NaturalParser::GetStatementsContext::getTransactionStatement() {
  return getRuleContext<NaturalParser::GetTransactionStatementContext>(0);
}

NaturalParser::GetSameStatementContext* NaturalParser::GetStatementsContext::getSameStatement() {
  return getRuleContext<NaturalParser::GetSameStatementContext>(0);
}


size_t NaturalParser::GetStatementsContext::getRuleIndex() const {
  return NaturalParser::RuleGetStatements;
}


std::any NaturalParser::GetStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitGetStatements(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::GetStatementsContext* NaturalParser::getStatements() {
  GetStatementsContext *_localctx = _tracker.createInstance<GetStatementsContext>(_ctx, getState());
  enterRule(_localctx, 70, NaturalParser::RuleGetStatements);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(924);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::GET: {
        enterOuterAlt(_localctx, 1);
        setState(921);
        getTabledStatements();
        break;
      }

      case NaturalParser::GET_TRANSACTION_DATA: {
        enterOuterAlt(_localctx, 2);
        setState(922);
        getTransactionStatement();
        break;
      }

      case NaturalParser::GET_SAME: {
        enterOuterAlt(_localctx, 3);
        setState(923);
        getSameStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetTabledStatementsContext ------------------------------------------------------------------

NaturalParser::GetTabledStatementsContext::GetTabledStatementsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::GetTabledStatementsContext::GET() {
  return getToken(NaturalParser::GET, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::GetTabledStatementsContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::GetTabledStatementsContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::GetTabledStatementsContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::GetTabledStatementsContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

NaturalParser::VariableContext* NaturalParser::GetTabledStatementsContext::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

std::vector<NaturalParser::GetTabledOptionsContext *> NaturalParser::GetTabledStatementsContext::getTabledOptions() {
  return getRuleContexts<NaturalParser::GetTabledOptionsContext>();
}

NaturalParser::GetTabledOptionsContext* NaturalParser::GetTabledStatementsContext::getTabledOptions(size_t i) {
  return getRuleContext<NaturalParser::GetTabledOptionsContext>(i);
}


size_t NaturalParser::GetTabledStatementsContext::getRuleIndex() const {
  return NaturalParser::RuleGetTabledStatements;
}


std::any NaturalParser::GetTabledStatementsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitGetTabledStatements(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::GetTabledStatementsContext* NaturalParser::getTabledStatements() {
  GetTabledStatementsContext *_localctx = _tracker.createInstance<GetTabledStatementsContext>(_ctx, getState());
  enterRule(_localctx, 72, NaturalParser::RuleGetTabledStatements);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(926);
    match(NaturalParser::GET);
    setState(927);
    match(NaturalParser::WS);
    setState(928);
    antlrcpp::downCast<GetTabledStatementsContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(933);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NaturalParser::RECORD

    || _la == NaturalParser::RECORDS || _la == NaturalParser::WS) {
      setState(931);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::RECORD:
        case NaturalParser::RECORDS: {
          setState(929);
          getTabledOptions();
          break;
        }

        case NaturalParser::WS: {
          setState(930);
          match(NaturalParser::WS);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(935);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(936);
    antlrcpp::downCast<GetTabledStatementsContext *>(_localctx)->filterCondition = variable();
    setState(938);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(937);
      match(NaturalParser::WS);
    }
    setState(940);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetTabledOptionsContext ------------------------------------------------------------------

NaturalParser::GetTabledOptionsContext::GetTabledOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::GetTabledOptionsContext::RECORD() {
  return getToken(NaturalParser::RECORD, 0);
}

tree::TerminalNode* NaturalParser::GetTabledOptionsContext::RECORDS() {
  return getToken(NaturalParser::RECORDS, 0);
}


size_t NaturalParser::GetTabledOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleGetTabledOptions;
}


std::any NaturalParser::GetTabledOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitGetTabledOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::GetTabledOptionsContext* NaturalParser::getTabledOptions() {
  GetTabledOptionsContext *_localctx = _tracker.createInstance<GetTabledOptionsContext>(_ctx, getState());
  enterRule(_localctx, 74, NaturalParser::RuleGetTabledOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(942);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::RECORD

    || _la == NaturalParser::RECORDS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetTransactionStatementContext ------------------------------------------------------------------

NaturalParser::GetTransactionStatementContext::GetTransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::GetTransactionStatementContext::GET_TRANSACTION_DATA() {
  return getToken(NaturalParser::GET_TRANSACTION_DATA, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::GetTransactionStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::GetTransactionStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::GetTransactionStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::GetTransactionStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::GetTransactionStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::GetTransactionStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::GetTransactionStatementContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::GetTransactionStatementContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}


size_t NaturalParser::GetTransactionStatementContext::getRuleIndex() const {
  return NaturalParser::RuleGetTransactionStatement;
}


std::any NaturalParser::GetTransactionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitGetTransactionStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::GetTransactionStatementContext* NaturalParser::getTransactionStatement() {
  GetTransactionStatementContext *_localctx = _tracker.createInstance<GetTransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 76, NaturalParser::RuleGetTransactionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(944);
    match(NaturalParser::GET_TRANSACTION_DATA);
    setState(946); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(945);
              _la = _input->LA(1);
              if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 274)) & 6815745) != 0))) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(948); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(950);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetSameStatementContext ------------------------------------------------------------------

NaturalParser::GetSameStatementContext::GetSameStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::GetSameStatementContext::GET_SAME() {
  return getToken(NaturalParser::GET_SAME, 0);
}

tree::TerminalNode* NaturalParser::GetSameStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::GetSameStatementContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::GetSameStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::GetSameStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::GetSameStatementContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::GetSameStatementContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}


size_t NaturalParser::GetSameStatementContext::getRuleIndex() const {
  return NaturalParser::RuleGetSameStatement;
}


std::any NaturalParser::GetSameStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitGetSameStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::GetSameStatementContext* NaturalParser::getSameStatement() {
  GetSameStatementContext *_localctx = _tracker.createInstance<GetSameStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, NaturalParser::RuleGetSameStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    match(NaturalParser::GET_SAME);
    setState(957);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx)) {
    case 1: {
      setState(954);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(953);
        match(NaturalParser::WS);
      }
      setState(956);
      match(NaturalParser::LINE_REF);
      break;
    }

    default:
      break;
    }
    setState(962);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NaturalParser::IDENTIFIER

    || _la == NaturalParser::WS) {
      setState(959);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::IDENTIFIER

      || _la == NaturalParser::WS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(964);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(965);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramStatementContext ------------------------------------------------------------------

NaturalParser::HistogramStatementContext::HistogramStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::HistogramQueryContext* NaturalParser::HistogramStatementContext::histogramQuery() {
  return getRuleContext<NaturalParser::HistogramQueryContext>(0);
}

tree::TerminalNode* NaturalParser::HistogramStatementContext::END_HISTOGRAM() {
  return getToken(NaturalParser::END_HISTOGRAM, 0);
}

tree::TerminalNode* NaturalParser::HistogramStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::HistogramStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::HistogramStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::HistogramStatementContext::getRuleIndex() const {
  return NaturalParser::RuleHistogramStatement;
}


std::any NaturalParser::HistogramStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitHistogramStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::HistogramStatementContext* NaturalParser::histogramStatement() {
  HistogramStatementContext *_localctx = _tracker.createInstance<HistogramStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, NaturalParser::RuleHistogramStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(967);
    histogramQuery();
    setState(971);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0)) {
      setState(968);
      statement();
      setState(973);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(974);
    antlrcpp::downCast<HistogramStatementContext *>(_localctx)->endBlock = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::LOOP || _la == NaturalParser::END_HISTOGRAM)) {
      antlrcpp::downCast<HistogramStatementContext *>(_localctx)->endBlock = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramQueryContext ------------------------------------------------------------------

NaturalParser::HistogramQueryContext::HistogramQueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::HistogramQueryContext::HISTOGRAM() {
  return getToken(NaturalParser::HISTOGRAM, 0);
}

NaturalParser::HistogramOptionsContext* NaturalParser::HistogramQueryContext::histogramOptions() {
  return getRuleContext<NaturalParser::HistogramOptionsContext>(0);
}

tree::TerminalNode* NaturalParser::HistogramQueryContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramQueryContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::HistogramQueryContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<NaturalParser::HistogramPreviewContext *> NaturalParser::HistogramQueryContext::histogramPreview() {
  return getRuleContexts<NaturalParser::HistogramPreviewContext>();
}

NaturalParser::HistogramPreviewContext* NaturalParser::HistogramQueryContext::histogramPreview(size_t i) {
  return getRuleContext<NaturalParser::HistogramPreviewContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramQueryContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::HistogramQueryContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramQueryContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::HistogramQueryContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::HistogramQueryContext::getRuleIndex() const {
  return NaturalParser::RuleHistogramQuery;
}


std::any NaturalParser::HistogramQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitHistogramQuery(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::HistogramQueryContext* NaturalParser::histogramQuery() {
  HistogramQueryContext *_localctx = _tracker.createInstance<HistogramQueryContext>(_ctx, getState());
  enterRule(_localctx, 82, NaturalParser::RuleHistogramQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(976);
    match(NaturalParser::HISTOGRAM);
    setState(978);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(977);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(986);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 25) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 25)) & 72057594037927985) != 0) || ((((_la - 232) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 232)) & -9223332454436159487) != 0) || _la == NaturalParser::NL) {
      setState(984);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::FIRST:
        case NaturalParser::ALL:
        case NaturalParser::UNIQUE_LEX:
        case NaturalParser::IN:
        case NaturalParser::MULTI_FETCH:
        case NaturalParser::FILE:
        case NaturalParser::LINE_REF: {
          setState(980);
          histogramPreview();
          break;
        }

        case NaturalParser::WS: {
          setState(981);
          match(NaturalParser::WS);
          break;
        }

        case NaturalParser::NL: {
          setState(982);
          match(NaturalParser::NL);
          break;
        }

        case NaturalParser::LINE_NUMBER: {
          setState(983);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(988);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(989);
    antlrcpp::downCast<HistogramQueryContext *>(_localctx)->tableName = match(NaturalParser::IDENTIFIER);
    setState(993);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(990);
        match(NaturalParser::WS); 
      }
      setState(995);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
    }
    setState(997);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx)) {
    case 1: {
      setState(996);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(999);
    histogramOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramPreviewContext ------------------------------------------------------------------

NaturalParser::HistogramPreviewContext::HistogramPreviewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::FIRST() {
  return getToken(NaturalParser::FIRST, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::UNIQUE_LEX() {
  return getToken(NaturalParser::UNIQUE_LEX, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::ALL() {
  return getToken(NaturalParser::ALL, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::MULTI_FETCH() {
  return getToken(NaturalParser::MULTI_FETCH, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramPreviewContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::OF() {
  return getToken(NaturalParser::OF, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::ON() {
  return getToken(NaturalParser::ON, 0);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::OFF() {
  return getToken(NaturalParser::OFF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramPreviewContext::IN() {
  return getTokens(NaturalParser::IN);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::IN(size_t i) {
  return getToken(NaturalParser::IN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramPreviewContext::FILE() {
  return getTokens(NaturalParser::FILE);
}

tree::TerminalNode* NaturalParser::HistogramPreviewContext::FILE(size_t i) {
  return getToken(NaturalParser::FILE, i);
}


size_t NaturalParser::HistogramPreviewContext::getRuleIndex() const {
  return NaturalParser::RuleHistogramPreview;
}


std::any NaturalParser::HistogramPreviewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitHistogramPreview(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::HistogramPreviewContext* NaturalParser::histogramPreview() {
  HistogramPreviewContext *_localctx = _tracker.createInstance<HistogramPreviewContext>(_ctx, getState());
  enterRule(_localctx, 84, NaturalParser::RuleHistogramPreview);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1014);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::FIRST:
      case NaturalParser::ALL:
      case NaturalParser::UNIQUE_LEX:
      case NaturalParser::LINE_REF: {
        enterOuterAlt(_localctx, 1);
        setState(1001);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1644167168) != 0) || _la == NaturalParser::LINE_REF)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case NaturalParser::MULTI_FETCH: {
        enterOuterAlt(_localctx, 2);
        setState(1002);
        match(NaturalParser::MULTI_FETCH);
        setState(1005);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx)) {
        case 1: {
          setState(1003);
          match(NaturalParser::WS);
          setState(1004);
          _la = _input->LA(1);
          if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 218)) & 8195) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(1007);
        match(NaturalParser::WS);
        setState(1008);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      case NaturalParser::IN:
      case NaturalParser::FILE: {
        enterOuterAlt(_localctx, 3);
        setState(1010); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(1009);
                  _la = _input->LA(1);
                  if (!(_la == NaturalParser::IN || _la == NaturalParser::FILE)) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(1012); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramOptionsContext ------------------------------------------------------------------

NaturalParser::HistogramOptionsContext::HistogramOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::OperandContext *> NaturalParser::HistogramOptionsContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::HistogramOptionsContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::LINE_REF() {
  return getTokens(NaturalParser::LINE_REF);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::LINE_REF(size_t i) {
  return getToken(NaturalParser::LINE_REF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::PASSWORD() {
  return getTokens(NaturalParser::PASSWORD);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::PASSWORD(size_t i) {
  return getToken(NaturalParser::PASSWORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::ALL() {
  return getTokens(NaturalParser::ALL);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::ALL(size_t i) {
  return getToken(NaturalParser::ALL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::FROM() {
  return getTokens(NaturalParser::FROM);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::FROM(size_t i) {
  return getToken(NaturalParser::FROM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::WITH() {
  return getTokens(NaturalParser::WITH);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::WITH(size_t i) {
  return getToken(NaturalParser::WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::THRU() {
  return getTokens(NaturalParser::THRU);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::THRU(size_t i) {
  return getToken(NaturalParser::THRU, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::IN() {
  return getTokens(NaturalParser::IN);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::IN(size_t i) {
  return getToken(NaturalParser::IN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::VALUE() {
  return getTokens(NaturalParser::VALUE);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::VALUE(size_t i) {
  return getToken(NaturalParser::VALUE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::FOR() {
  return getTokens(NaturalParser::FOR);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::FOR(size_t i) {
  return getToken(NaturalParser::FOR, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::FIELD() {
  return getTokens(NaturalParser::FIELD);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::FIELD(size_t i) {
  return getToken(NaturalParser::FIELD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::ON() {
  return getTokens(NaturalParser::ON);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::ON(size_t i) {
  return getToken(NaturalParser::ON, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::OFF() {
  return getTokens(NaturalParser::OFF);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::OFF(size_t i) {
  return getToken(NaturalParser::OFF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::OF() {
  return getTokens(NaturalParser::OF);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::OF(size_t i) {
  return getToken(NaturalParser::OF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::ASCENDING() {
  return getTokens(NaturalParser::ASCENDING);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::ASCENDING(size_t i) {
  return getToken(NaturalParser::ASCENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::DESCENDING() {
  return getTokens(NaturalParser::DESCENDING);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::DESCENDING(size_t i) {
  return getToken(NaturalParser::DESCENDING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::VARIABLE() {
  return getTokens(NaturalParser::VARIABLE);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::VARIABLE(size_t i) {
  return getToken(NaturalParser::VARIABLE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::DYNAMIC() {
  return getTokens(NaturalParser::DYNAMIC);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::DYNAMIC(size_t i) {
  return getToken(NaturalParser::DYNAMIC, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::SEQUENCE() {
  return getTokens(NaturalParser::SEQUENCE);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::SEQUENCE(size_t i) {
  return getToken(NaturalParser::SEQUENCE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::STARTING() {
  return getTokens(NaturalParser::STARTING);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::STARTING(size_t i) {
  return getToken(NaturalParser::STARTING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::STARTING_WITH() {
  return getTokens(NaturalParser::STARTING_WITH);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::STARTING_WITH(size_t i) {
  return getToken(NaturalParser::STARTING_WITH, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::STARTING_FROM() {
  return getTokens(NaturalParser::STARTING_FROM);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::STARTING_FROM(size_t i) {
  return getToken(NaturalParser::STARTING_FROM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::ENDING_AT() {
  return getTokens(NaturalParser::ENDING_AT);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::ENDING_AT(size_t i) {
  return getToken(NaturalParser::ENDING_AT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::HistogramOptionsContext::WHERE() {
  return getTokens(NaturalParser::WHERE);
}

tree::TerminalNode* NaturalParser::HistogramOptionsContext::WHERE(size_t i) {
  return getToken(NaturalParser::WHERE, i);
}

std::vector<NaturalParser::CompOpContext *> NaturalParser::HistogramOptionsContext::compOp() {
  return getRuleContexts<NaturalParser::CompOpContext>();
}

NaturalParser::CompOpContext* NaturalParser::HistogramOptionsContext::compOp(size_t i) {
  return getRuleContext<NaturalParser::CompOpContext>(i);
}

std::vector<NaturalParser::LogicalOpContext *> NaturalParser::HistogramOptionsContext::logicalOp() {
  return getRuleContexts<NaturalParser::LogicalOpContext>();
}

NaturalParser::LogicalOpContext* NaturalParser::HistogramOptionsContext::logicalOp(size_t i) {
  return getRuleContext<NaturalParser::LogicalOpContext>(i);
}


size_t NaturalParser::HistogramOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleHistogramOptions;
}


std::any NaturalParser::HistogramOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitHistogramOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::HistogramOptionsContext* NaturalParser::histogramOptions() {
  HistogramOptionsContext *_localctx = _tracker.createInstance<HistogramOptionsContext>(_ctx, getState());
  enterRule(_localctx, 86, NaturalParser::RuleHistogramOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1047);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1045);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
        case 1: {
          setState(1016);
          operand();
          break;
        }

        case 2: {
          setState(1017);
          match(NaturalParser::LINE_REF);
          break;
        }

        case 3: {
          setState(1018);
          match(NaturalParser::WS);
          break;
        }

        case 4: {
          setState(1019);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        case 5: {
          setState(1020);
          match(NaturalParser::NL);
          break;
        }

        case 6: {
          setState(1021);
          match(NaturalParser::PASSWORD);
          break;
        }

        case 7: {
          setState(1022);
          match(NaturalParser::ALL);
          break;
        }

        case 8: {
          setState(1023);
          match(NaturalParser::FROM);
          break;
        }

        case 9: {
          setState(1024);
          match(NaturalParser::WITH);
          break;
        }

        case 10: {
          setState(1025);
          match(NaturalParser::THRU);
          break;
        }

        case 11: {
          setState(1026);
          match(NaturalParser::IN);
          break;
        }

        case 12: {
          setState(1027);
          match(NaturalParser::VALUE);
          break;
        }

        case 13: {
          setState(1028);
          match(NaturalParser::FOR);
          break;
        }

        case 14: {
          setState(1029);
          match(NaturalParser::FIELD);
          break;
        }

        case 15: {
          setState(1030);
          match(NaturalParser::ON);
          break;
        }

        case 16: {
          setState(1031);
          match(NaturalParser::OFF);
          break;
        }

        case 17: {
          setState(1032);
          match(NaturalParser::OF);
          break;
        }

        case 18: {
          setState(1033);
          match(NaturalParser::ASCENDING);
          break;
        }

        case 19: {
          setState(1034);
          match(NaturalParser::DESCENDING);
          break;
        }

        case 20: {
          setState(1035);
          match(NaturalParser::VARIABLE);
          break;
        }

        case 21: {
          setState(1036);
          match(NaturalParser::DYNAMIC);
          break;
        }

        case 22: {
          setState(1037);
          match(NaturalParser::SEQUENCE);
          break;
        }

        case 23: {
          setState(1038);
          match(NaturalParser::STARTING);
          break;
        }

        case 24: {
          setState(1039);
          match(NaturalParser::STARTING_WITH);
          break;
        }

        case 25: {
          setState(1040);
          match(NaturalParser::STARTING_FROM);
          break;
        }

        case 26: {
          setState(1041);
          match(NaturalParser::ENDING_AT);
          break;
        }

        case 27: {
          setState(1042);
          match(NaturalParser::WHERE);
          break;
        }

        case 28: {
          setState(1043);
          compOp();
          break;
        }

        case 29: {
          setState(1044);
          logicalOp();
          break;
        }

        default:
          break;
        } 
      }
      setState(1049);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx);
    }
    setState(1050);
    operand();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndTransactionContext ------------------------------------------------------------------

NaturalParser::EndTransactionContext::EndTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::EndTransactionContext::END_TRANSACTION() {
  return getToken(NaturalParser::END_TRANSACTION, 0);
}


size_t NaturalParser::EndTransactionContext::getRuleIndex() const {
  return NaturalParser::RuleEndTransaction;
}


std::any NaturalParser::EndTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitEndTransaction(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::EndTransactionContext* NaturalParser::endTransaction() {
  EndTransactionContext *_localctx = _tracker.createInstance<EndTransactionContext>(_ctx, getState());
  enterRule(_localctx, 88, NaturalParser::RuleEndTransaction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1052);
    match(NaturalParser::END_TRANSACTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BackoutTransactionContext ------------------------------------------------------------------

NaturalParser::BackoutTransactionContext::BackoutTransactionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::BackoutTransactionContext::BACKOUT_TRANSACTION() {
  return getToken(NaturalParser::BACKOUT_TRANSACTION, 0);
}


size_t NaturalParser::BackoutTransactionContext::getRuleIndex() const {
  return NaturalParser::RuleBackoutTransaction;
}


std::any NaturalParser::BackoutTransactionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitBackoutTransaction(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::BackoutTransactionContext* NaturalParser::backoutTransaction() {
  BackoutTransactionContext *_localctx = _tracker.createInstance<BackoutTransactionContext>(_ctx, getState());
  enterRule(_localctx, 90, NaturalParser::RuleBackoutTransaction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1054);
    match(NaturalParser::BACKOUT_TRANSACTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadworkfileStatementContext ------------------------------------------------------------------

NaturalParser::ReadworkfileStatementContext::ReadworkfileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::WorkfilenumberOptionContext* NaturalParser::ReadworkfileStatementContext::workfilenumberOption() {
  return getRuleContext<NaturalParser::WorkfilenumberOptionContext>(0);
}

NaturalParser::ReadworkfileOptionsContext* NaturalParser::ReadworkfileStatementContext::readworkfileOptions() {
  return getRuleContext<NaturalParser::ReadworkfileOptionsContext>(0);
}

NaturalParser::AtEndOfFileStatementContext* NaturalParser::ReadworkfileStatementContext::atEndOfFileStatement() {
  return getRuleContext<NaturalParser::AtEndOfFileStatementContext>(0);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::READ_WORK_FILE() {
  return getToken(NaturalParser::READ_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::READ_WORK() {
  return getToken(NaturalParser::READ_WORK, 0);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::ONCE() {
  return getToken(NaturalParser::ONCE, 0);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::END_ALL() {
  return getToken(NaturalParser::END_ALL, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::ReadworkfileStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::ReadworkfileStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::END_WORK() {
  return getToken(NaturalParser::END_WORK, 0);
}

tree::TerminalNode* NaturalParser::ReadworkfileStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}


size_t NaturalParser::ReadworkfileStatementContext::getRuleIndex() const {
  return NaturalParser::RuleReadworkfileStatement;
}


std::any NaturalParser::ReadworkfileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadworkfileStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadworkfileStatementContext* NaturalParser::readworkfileStatement() {
  ReadworkfileStatementContext *_localctx = _tracker.createInstance<ReadworkfileStatementContext>(_ctx, getState());
  enterRule(_localctx, 92, NaturalParser::RuleReadworkfileStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1102);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1056);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::READ_WORK_FILE

      || _la == NaturalParser::READ_WORK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1057);
      match(NaturalParser::WS);
      setState(1058);
      workfilenumberOption();
      setState(1063);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
      case 1: {
        setState(1060);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(1059);
          match(NaturalParser::WS);
        }
        setState(1062);
        match(NaturalParser::ONCE);
        break;
      }

      default:
        break;
      }
      setState(1065);
      readworkfileOptions();
      setState(1066);
      atEndOfFileStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1068);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::READ_WORK_FILE

      || _la == NaturalParser::READ_WORK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1069);
      match(NaturalParser::WS);
      setState(1070);
      workfilenumberOption();
      setState(1075);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
      case 1: {
        setState(1072);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(1071);
          match(NaturalParser::WS);
        }
        setState(1074);
        match(NaturalParser::ONCE);
        break;
      }

      default:
        break;
      }
      setState(1077);
      readworkfileOptions();
      setState(1079); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1078);
                statement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1081); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1083);
      match(NaturalParser::END_ALL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1085);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::READ_WORK_FILE

      || _la == NaturalParser::READ_WORK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1086);
      match(NaturalParser::WS);
      setState(1087);
      workfilenumberOption();
      setState(1092);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
      case 1: {
        setState(1089);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(1088);
          match(NaturalParser::WS);
        }
        setState(1091);
        match(NaturalParser::ONCE);
        break;
      }

      default:
        break;
      }
      setState(1094);
      readworkfileOptions();
      setState(1096); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1095);
                statement();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1098); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(1100);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::LOOP || _la == NaturalParser::END_WORK)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WorkfilenumberOptionContext ------------------------------------------------------------------

NaturalParser::WorkfilenumberOptionContext::WorkfilenumberOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::WorkfilenumberOptionContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::WorkfilenumberOptionContext::getRuleIndex() const {
  return NaturalParser::RuleWorkfilenumberOption;
}


std::any NaturalParser::WorkfilenumberOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitWorkfilenumberOption(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::WorkfilenumberOptionContext* NaturalParser::workfilenumberOption() {
  WorkfilenumberOptionContext *_localctx = _tracker.createInstance<WorkfilenumberOptionContext>(_ctx, getState());
  enterRule(_localctx, 94, NaturalParser::RuleWorkfilenumberOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1104);
    match(NaturalParser::LINE_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReadworkfileOptionsContext ------------------------------------------------------------------

NaturalParser::ReadworkfileOptionsContext::ReadworkfileOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::OperandContext *> NaturalParser::ReadworkfileOptionsContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::ReadworkfileOptionsContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::LINE_REF() {
  return getTokens(NaturalParser::LINE_REF);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::LINE_REF(size_t i) {
  return getToken(NaturalParser::LINE_REF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::RECORD() {
  return getTokens(NaturalParser::RECORD);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::RECORD(size_t i) {
  return getToken(NaturalParser::RECORD, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::FILLER() {
  return getTokens(NaturalParser::FILLER);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::FILLER(size_t i) {
  return getToken(NaturalParser::FILLER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::OFFSET() {
  return getTokens(NaturalParser::OFFSET);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::OFFSET(size_t i) {
  return getToken(NaturalParser::OFFSET, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::AND() {
  return getTokens(NaturalParser::AND);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::AND(size_t i) {
  return getToken(NaturalParser::AND, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::SELECT() {
  return getTokens(NaturalParser::SELECT);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::SELECT(size_t i) {
  return getToken(NaturalParser::SELECT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::GIVING() {
  return getTokens(NaturalParser::GIVING);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::GIVING(size_t i) {
  return getToken(NaturalParser::GIVING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ReadworkfileOptionsContext::LENGTH() {
  return getTokens(NaturalParser::LENGTH);
}

tree::TerminalNode* NaturalParser::ReadworkfileOptionsContext::LENGTH(size_t i) {
  return getToken(NaturalParser::LENGTH, i);
}


size_t NaturalParser::ReadworkfileOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleReadworkfileOptions;
}


std::any NaturalParser::ReadworkfileOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitReadworkfileOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ReadworkfileOptionsContext* NaturalParser::readworkfileOptions() {
  ReadworkfileOptionsContext *_localctx = _tracker.createInstance<ReadworkfileOptionsContext>(_ctx, getState());
  enterRule(_localctx, 96, NaturalParser::RuleReadworkfileOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1120);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1118);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
        case 1: {
          setState(1106);
          operand();
          break;
        }

        case 2: {
          setState(1107);
          match(NaturalParser::LINE_REF);
          break;
        }

        case 3: {
          setState(1108);
          match(NaturalParser::WS);
          break;
        }

        case 4: {
          setState(1109);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        case 5: {
          setState(1110);
          match(NaturalParser::NL);
          break;
        }

        case 6: {
          setState(1111);
          match(NaturalParser::RECORD);
          break;
        }

        case 7: {
          setState(1112);
          match(NaturalParser::FILLER);
          break;
        }

        case 8: {
          setState(1113);
          match(NaturalParser::OFFSET);
          break;
        }

        case 9: {
          setState(1114);
          match(NaturalParser::AND);
          break;
        }

        case 10: {
          setState(1115);
          match(NaturalParser::SELECT);
          break;
        }

        case 11: {
          setState(1116);
          match(NaturalParser::GIVING);
          break;
        }

        case 12: {
          setState(1117);
          match(NaturalParser::LENGTH);
          break;
        }

        default:
          break;
        } 
      }
      setState(1122);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtEndOfFileStatementContext ------------------------------------------------------------------

NaturalParser::AtEndOfFileStatementContext::AtEndOfFileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::AtEndOfFileStatementContext::AT_END_OF_FILE() {
  return getToken(NaturalParser::AT_END_OF_FILE, 0);
}

tree::TerminalNode* NaturalParser::AtEndOfFileStatementContext::END_ENDFILE() {
  return getToken(NaturalParser::END_ENDFILE, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::AtEndOfFileStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::AtEndOfFileStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::AtEndOfFileStatementContext::getRuleIndex() const {
  return NaturalParser::RuleAtEndOfFileStatement;
}


std::any NaturalParser::AtEndOfFileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAtEndOfFileStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AtEndOfFileStatementContext* NaturalParser::atEndOfFileStatement() {
  AtEndOfFileStatementContext *_localctx = _tracker.createInstance<AtEndOfFileStatementContext>(_ctx, getState());
  enterRule(_localctx, 98, NaturalParser::RuleAtEndOfFileStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1123);
    match(NaturalParser::AT_END_OF_FILE);
    setState(1127);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1124);
        statement(); 
      }
      setState(1129);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx);
    }
    setState(1130);
    match(NaturalParser::END_ENDFILE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WriteworkfileStatementContext ------------------------------------------------------------------

NaturalParser::WriteworkfileStatementContext::WriteworkfileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::WriteworkfileStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::WorkfilenumberOptionContext* NaturalParser::WriteworkfileStatementContext::workfilenumberOption() {
  return getRuleContext<NaturalParser::WorkfilenumberOptionContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::WriteworkfileStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::WRITE_WORK_FILE() {
  return getToken(NaturalParser::WRITE_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::WRITE_WORK() {
  return getToken(NaturalParser::WRITE_WORK, 0);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::VARIABLE() {
  return getToken(NaturalParser::VARIABLE, 0);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::WriteworkfileStatementContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::WriteworkfileStatementContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::WriteworkfileStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::WriteworkfileStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::WriteworkfileStatementContext::getRuleIndex() const {
  return NaturalParser::RuleWriteworkfileStatement;
}


std::any NaturalParser::WriteworkfileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitWriteworkfileStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::WriteworkfileStatementContext* NaturalParser::writeworkfileStatement() {
  WriteworkfileStatementContext *_localctx = _tracker.createInstance<WriteworkfileStatementContext>(_ctx, getState());
  enterRule(_localctx, 100, NaturalParser::RuleWriteworkfileStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1132);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::WRITE_WORK_FILE

    || _la == NaturalParser::WRITE_WORK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1133);
    match(NaturalParser::WS);
    setState(1134);
    workfilenumberOption();
    setState(1139);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
    case 1: {
      setState(1136);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1135);
        match(NaturalParser::WS);
      }
      setState(1138);
      match(NaturalParser::VARIABLE);
      break;
    }

    default:
      break;
    }
    setState(1147);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1145);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
        case 1: {
          setState(1141);
          operand();
          break;
        }

        case 2: {
          setState(1142);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        case 3: {
          setState(1143);
          match(NaturalParser::WS);
          break;
        }

        case 4: {
          setState(1144);
          match(NaturalParser::NL);
          break;
        }

        default:
          break;
        } 
      }
      setState(1149);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx);
    }
    setState(1150);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloseworkfileStatementContext ------------------------------------------------------------------

NaturalParser::CloseworkfileStatementContext::CloseworkfileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CloseworkfileStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

NaturalParser::WorkfilenumberOptionContext* NaturalParser::CloseworkfileStatementContext::workfilenumberOption() {
  return getRuleContext<NaturalParser::WorkfilenumberOptionContext>(0);
}

tree::TerminalNode* NaturalParser::CloseworkfileStatementContext::CLOSE_WORK_FILE() {
  return getToken(NaturalParser::CLOSE_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::CloseworkfileStatementContext::CLOSE_WORK() {
  return getToken(NaturalParser::CLOSE_WORK, 0);
}


size_t NaturalParser::CloseworkfileStatementContext::getRuleIndex() const {
  return NaturalParser::RuleCloseworkfileStatement;
}


std::any NaturalParser::CloseworkfileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCloseworkfileStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CloseworkfileStatementContext* NaturalParser::closeworkfileStatement() {
  CloseworkfileStatementContext *_localctx = _tracker.createInstance<CloseworkfileStatementContext>(_ctx, getState());
  enterRule(_localctx, 102, NaturalParser::RuleCloseworkfileStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1152);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::CLOSE_WORK_FILE

    || _la == NaturalParser::CLOSE_WORK)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1153);
    match(NaturalParser::WS);
    setState(1154);
    workfilenumberOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoRecordsFoundStatementContext ------------------------------------------------------------------

NaturalParser::NoRecordsFoundStatementContext::NoRecordsFoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::NoRecordsFoundStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

tree::TerminalNode* NaturalParser::NoRecordsFoundStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::NoRecordsFoundStatementContext::END_NOREC() {
  return getToken(NaturalParser::END_NOREC, 0);
}

tree::TerminalNode* NaturalParser::NoRecordsFoundStatementContext::NO_RECORDS_FOUND() {
  return getToken(NaturalParser::NO_RECORDS_FOUND, 0);
}

tree::TerminalNode* NaturalParser::NoRecordsFoundStatementContext::NO_RECORD_FOUND() {
  return getToken(NaturalParser::NO_RECORD_FOUND, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::NoRecordsFoundStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::NoRecordsFoundStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::NoRecordsFoundStatementContext::getRuleIndex() const {
  return NaturalParser::RuleNoRecordsFoundStatement;
}


std::any NaturalParser::NoRecordsFoundStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitNoRecordsFoundStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::NoRecordsFoundStatementContext* NaturalParser::noRecordsFoundStatement() {
  NoRecordsFoundStatementContext *_localctx = _tracker.createInstance<NoRecordsFoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 104, NaturalParser::RuleNoRecordsFoundStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1156);
    match(NaturalParser::IF);
    setState(1157);
    match(NaturalParser::WS);
    setState(1158);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::NO_RECORDS_FOUND

    || _la == NaturalParser::NO_RECORD_FOUND)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1162);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1159);
        statement(); 
      }
      setState(1164);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    }
    setState(1165);
    match(NaturalParser::END_NOREC);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AtStartOfDataStatementContext ------------------------------------------------------------------

NaturalParser::AtStartOfDataStatementContext::AtStartOfDataStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::AT_START_OF_DATA() {
  return getToken(NaturalParser::AT_START_OF_DATA, 0);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::END_START() {
  return getToken(NaturalParser::END_START, 0);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::DOEND() {
  return getToken(NaturalParser::DOEND, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::AtStartOfDataStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::AtStartOfDataStatementContext::DO() {
  return getToken(NaturalParser::DO, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::AtStartOfDataStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::AtStartOfDataStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::AtStartOfDataStatementContext::getRuleIndex() const {
  return NaturalParser::RuleAtStartOfDataStatement;
}


std::any NaturalParser::AtStartOfDataStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAtStartOfDataStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AtStartOfDataStatementContext* NaturalParser::atStartOfDataStatement() {
  AtStartOfDataStatementContext *_localctx = _tracker.createInstance<AtStartOfDataStatementContext>(_ctx, getState());
  enterRule(_localctx, 106, NaturalParser::RuleAtStartOfDataStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1167);
    match(NaturalParser::AT_START_OF_DATA);
    setState(1169);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      setState(1168);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1172);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(1171);
      match(NaturalParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
    setState(1175);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
    case 1: {
      setState(1174);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(1179);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
    case 1: {
      setState(1177);
      match(NaturalParser::DO);
      setState(1178);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1184);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1181);
        statement(); 
      }
      setState(1186);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx);
    }
    setState(1187);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::DOEND || _la == NaturalParser::END_START)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormatStatementContext ------------------------------------------------------------------

NaturalParser::FormatStatementContext::FormatStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::FormatOptionsContext* NaturalParser::FormatStatementContext::formatOptions() {
  return getRuleContext<NaturalParser::FormatOptionsContext>(0);
}

std::vector<NaturalParser::AssignmentStatementContext *> NaturalParser::FormatStatementContext::assignmentStatement() {
  return getRuleContexts<NaturalParser::AssignmentStatementContext>();
}

NaturalParser::AssignmentStatementContext* NaturalParser::FormatStatementContext::assignmentStatement(size_t i) {
  return getRuleContext<NaturalParser::AssignmentStatementContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::FormatStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FormatStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FormatStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::FormatStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FormatStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::FormatStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::FormatStatementContext::getRuleIndex() const {
  return NaturalParser::RuleFormatStatement;
}


std::any NaturalParser::FormatStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFormatStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FormatStatementContext* NaturalParser::formatStatement() {
  FormatStatementContext *_localctx = _tracker.createInstance<FormatStatementContext>(_ctx, getState());
  enterRule(_localctx, 108, NaturalParser::RuleFormatStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1189);
    formatOptions();
    setState(1208);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1193);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(1190);
            match(NaturalParser::WS); 
          }
          setState(1195);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx);
        }
        setState(1196);
        assignmentStatement();
        setState(1198);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
        case 1: {
          setState(1197);
          match(NaturalParser::WS);
          break;
        }

        default:
          break;
        }
        setState(1201);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
        case 1: {
          setState(1200);
          match(NaturalParser::NL);
          break;
        }

        default:
          break;
        }
        setState(1204);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
        case 1: {
          setState(1203);
          match(NaturalParser::LINE_NUMBER);
          break;
        }

        default:
          break;
        } 
      }
      setState(1210);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FormatOptionsContext ------------------------------------------------------------------

NaturalParser::FormatOptionsContext::FormatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FormatOptionsContext::FORMAT() {
  return getToken(NaturalParser::FORMAT, 0);
}

tree::TerminalNode* NaturalParser::FormatOptionsContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}

tree::TerminalNode* NaturalParser::FormatOptionsContext::WS() {
  return getToken(NaturalParser::WS, 0);
}


size_t NaturalParser::FormatOptionsContext::getRuleIndex() const {
  return NaturalParser::RuleFormatOptions;
}


std::any NaturalParser::FormatOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFormatOptions(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FormatOptionsContext* NaturalParser::formatOptions() {
  FormatOptionsContext *_localctx = _tracker.createInstance<FormatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 110, NaturalParser::RuleFormatOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1217);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 179, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1211);
      match(NaturalParser::FORMAT);
      setState(1213);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1212);
        match(NaturalParser::WS);
      }
      setState(1215);
      match(NaturalParser::LINE_REF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1216);
      match(NaturalParser::FORMAT);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentStatementContext ------------------------------------------------------------------

NaturalParser::AssignmentStatementContext::AssignmentStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::AssignmentStatementContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::AssignmentStatementContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}

NaturalParser::CompOpContext* NaturalParser::AssignmentStatementContext::compOp() {
  return getRuleContext<NaturalParser::CompOpContext>(0);
}

tree::TerminalNode* NaturalParser::AssignmentStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::AssignmentStatementContext::ON() {
  return getToken(NaturalParser::ON, 0);
}

tree::TerminalNode* NaturalParser::AssignmentStatementContext::OFF() {
  return getToken(NaturalParser::OFF, 0);
}


size_t NaturalParser::AssignmentStatementContext::getRuleIndex() const {
  return NaturalParser::RuleAssignmentStatement;
}


std::any NaturalParser::AssignmentStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAssignmentStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AssignmentStatementContext* NaturalParser::assignmentStatement() {
  AssignmentStatementContext *_localctx = _tracker.createInstance<AssignmentStatementContext>(_ctx, getState());
  enterRule(_localctx, 112, NaturalParser::RuleAssignmentStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1219);
    match(NaturalParser::IDENTIFIER);
    setState(1220);
    compOp();
    setState(1221);
    _la = _input->LA(1);
    if (!(((((_la - 218) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 218)) & 72057594037927939) != 0) || _la == NaturalParser::IDENTIFIER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IncludeStatementContext ------------------------------------------------------------------

NaturalParser::IncludeStatementContext::IncludeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::IncludeStatementContext::INCLUDE() {
  return getToken(NaturalParser::INCLUDE, 0);
}

tree::TerminalNode* NaturalParser::IncludeStatementContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IncludeStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::IncludeStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::IncludeStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::IncludeStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::IncludeStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIncludeStatement;
}


std::any NaturalParser::IncludeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIncludeStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IncludeStatementContext* NaturalParser::includeStatement() {
  IncludeStatementContext *_localctx = _tracker.createInstance<IncludeStatementContext>(_ctx, getState());
  enterRule(_localctx, 114, NaturalParser::RuleIncludeStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1223);
    match(NaturalParser::INCLUDE);

    setState(1227);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
    while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1 + 1) {
        setState(1224);
        match(NaturalParser::WS); 
      }
      setState(1229);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx);
    }
    setState(1230);
    match(NaturalParser::IDENTIFIER);
    setState(1232);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 181, _ctx)) {
    case 1: {
      setState(1231);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1235);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(1234);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(1238);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx)) {
    case 1: {
      setState(1237);
      match(NaturalParser::LINE_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RedefineStatementContext ------------------------------------------------------------------

NaturalParser::RedefineStatementContext::RedefineStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::RedefineStatementContext::REDEFINE() {
  return getToken(NaturalParser::REDEFINE, 0);
}

NaturalParser::RedefineBodyContext* NaturalParser::RedefineStatementContext::redefineBody() {
  return getRuleContext<NaturalParser::RedefineBodyContext>(0);
}

tree::TerminalNode* NaturalParser::RedefineStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}


size_t NaturalParser::RedefineStatementContext::getRuleIndex() const {
  return NaturalParser::RuleRedefineStatement;
}


std::any NaturalParser::RedefineStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitRedefineStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::RedefineStatementContext* NaturalParser::redefineStatement() {
  RedefineStatementContext *_localctx = _tracker.createInstance<RedefineStatementContext>(_ctx, getState());
  enterRule(_localctx, 116, NaturalParser::RuleRedefineStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1240);
    match(NaturalParser::REDEFINE);
    setState(1242);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      setState(1241);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1244);
    redefineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RedefineBodyContext ------------------------------------------------------------------

NaturalParser::RedefineBodyContext::RedefineBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::RedefineBodyContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::RedefineBodyContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::RedefineBodyContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::RedefineBodyContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::RedefineBodyContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::RedefineBodyContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::RedefineBodyContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::RedefineBodyContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}


size_t NaturalParser::RedefineBodyContext::getRuleIndex() const {
  return NaturalParser::RuleRedefineBody;
}


std::any NaturalParser::RedefineBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitRedefineBody(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::RedefineBodyContext* NaturalParser::redefineBody() {
  RedefineBodyContext *_localctx = _tracker.createInstance<RedefineBodyContext>(_ctx, getState());
  enterRule(_localctx, 118, NaturalParser::RuleRedefineBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1251);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1249);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::LINE_NUMBER:
          case NaturalParser::IDENTIFIER: {
            setState(1246);
            _la = _input->LA(1);
            if (!(_la == NaturalParser::LINE_NUMBER

            || _la == NaturalParser::IDENTIFIER)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          case NaturalParser::WS: {
            setState(1247);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(1248);
            match(NaturalParser::NL);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(1253);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx);
    }
    setState(1254);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetStatementContext ------------------------------------------------------------------

NaturalParser::ResetStatementContext::ResetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ResetStatementContext::RESET() {
  return getToken(NaturalParser::RESET, 0);
}

NaturalParser::RedefineBodyContext* NaturalParser::ResetStatementContext::redefineBody() {
  return getRuleContext<NaturalParser::RedefineBodyContext>(0);
}

tree::TerminalNode* NaturalParser::ResetStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}


size_t NaturalParser::ResetStatementContext::getRuleIndex() const {
  return NaturalParser::RuleResetStatement;
}


std::any NaturalParser::ResetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitResetStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ResetStatementContext* NaturalParser::resetStatement() {
  ResetStatementContext *_localctx = _tracker.createInstance<ResetStatementContext>(_ctx, getState());
  enterRule(_localctx, 120, NaturalParser::RuleResetStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1256);
    match(NaturalParser::RESET);
    setState(1258);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 187, _ctx)) {
    case 1: {
      setState(1257);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1260);
    redefineBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallnatStatementContext ------------------------------------------------------------------

NaturalParser::CallnatStatementContext::CallnatStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CallnatStatementContext::CALLNAT() {
  return getToken(NaturalParser::CALLNAT, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::CallnatStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::CallnatStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::CallnatStatementContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::CallnatStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::CallnatStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<NaturalParser::VariableContext *> NaturalParser::CallnatStatementContext::variable() {
  return getRuleContexts<NaturalParser::VariableContext>();
}

NaturalParser::VariableContext* NaturalParser::CallnatStatementContext::variable(size_t i) {
  return getRuleContext<NaturalParser::VariableContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::CallnatStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::CallnatStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::CallnatStatementContext::getRuleIndex() const {
  return NaturalParser::RuleCallnatStatement;
}


std::any NaturalParser::CallnatStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCallnatStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CallnatStatementContext* NaturalParser::callnatStatement() {
  CallnatStatementContext *_localctx = _tracker.createInstance<CallnatStatementContext>(_ctx, getState());
  enterRule(_localctx, 122, NaturalParser::RuleCallnatStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1262);
    match(NaturalParser::CALLNAT);
    setState(1264);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1263);
      match(NaturalParser::WS);
    }
    setState(1266);
    antlrcpp::downCast<CallnatStatementContext *>(_localctx)->subprogramName = match(NaturalParser::STRING);
    setState(1268);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 189, _ctx)) {
    case 1: {
      setState(1267);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1276);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1274);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::IDENTIFIER: {
            setState(1270);
            variable();
            break;
          }

          case NaturalParser::WS: {
            setState(1271);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(1272);
            match(NaturalParser::NL);
            break;
          }

          case NaturalParser::LINE_NUMBER: {
            setState(1273);
            match(NaturalParser::LINE_NUMBER);
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(1278);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 191, _ctx);
    }
    setState(1279);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetkeyStatementContext ------------------------------------------------------------------

NaturalParser::SetkeyStatementContext::SetkeyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::SetkeyStatementContext::SET_KEY() {
  return getToken(NaturalParser::SET_KEY, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::SetkeyStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::SetkeyStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}


size_t NaturalParser::SetkeyStatementContext::getRuleIndex() const {
  return NaturalParser::RuleSetkeyStatement;
}


std::any NaturalParser::SetkeyStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSetkeyStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SetkeyStatementContext* NaturalParser::setkeyStatement() {
  SetkeyStatementContext *_localctx = _tracker.createInstance<SetkeyStatementContext>(_ctx, getState());
  enterRule(_localctx, 124, NaturalParser::RuleSetkeyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1281);
    match(NaturalParser::SET_KEY);
    setState(1285);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1282);
        match(NaturalParser::WS); 
      }
      setState(1287);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PerformStatementContext ------------------------------------------------------------------

NaturalParser::PerformStatementContext::PerformStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::PerformStatementContext::PERFORM() {
  return getToken(NaturalParser::PERFORM, 0);
}

NaturalParser::SubroutineNamesContext* NaturalParser::PerformStatementContext::subroutineNames() {
  return getRuleContext<NaturalParser::SubroutineNamesContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::PerformStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::PerformStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::PerformStatementContext::USING() {
  return getToken(NaturalParser::USING, 0);
}

NaturalParser::VariableContext* NaturalParser::PerformStatementContext::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}


size_t NaturalParser::PerformStatementContext::getRuleIndex() const {
  return NaturalParser::RulePerformStatement;
}


std::any NaturalParser::PerformStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitPerformStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::PerformStatementContext* NaturalParser::performStatement() {
  PerformStatementContext *_localctx = _tracker.createInstance<PerformStatementContext>(_ctx, getState());
  enterRule(_localctx, 126, NaturalParser::RulePerformStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1288);
    match(NaturalParser::PERFORM);
    setState(1290);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1289);
      match(NaturalParser::WS);
    }
    setState(1292);
    antlrcpp::downCast<PerformStatementContext *>(_localctx)->subroutineName = subroutineNames();
    setState(1301);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
    case 1: {
      setState(1294);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1293);
        match(NaturalParser::WS);
      }
      setState(1296);
      match(NaturalParser::USING);
      setState(1298);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1297);
        match(NaturalParser::WS);
      }
      setState(1300);
      variable();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubroutineNamesContext ------------------------------------------------------------------

NaturalParser::SubroutineNamesContext::SubroutineNamesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::SubroutineNamesContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::SubroutineNamesContext::TRANSLATE() {
  return getToken(NaturalParser::TRANSLATE, 0);
}


size_t NaturalParser::SubroutineNamesContext::getRuleIndex() const {
  return NaturalParser::RuleSubroutineNames;
}


std::any NaturalParser::SubroutineNamesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSubroutineNames(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SubroutineNamesContext* NaturalParser::subroutineNames() {
  SubroutineNamesContext *_localctx = _tracker.createInstance<SubroutineNamesContext>(_ctx, getState());
  enterRule(_localctx, 128, NaturalParser::RuleSubroutineNames);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1303);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::TRANSLATE || _la == NaturalParser::IDENTIFIER)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FetchStatementContext ------------------------------------------------------------------

NaturalParser::FetchStatementContext::FetchStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FetchStatementContext::FETCH() {
  return getToken(NaturalParser::FETCH, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FetchStatementContext::STRING() {
  return getTokens(NaturalParser::STRING);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::STRING(size_t i) {
  return getToken(NaturalParser::STRING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FetchStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::REPEAT() {
  return getToken(NaturalParser::REPEAT, 0);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::RETURN() {
  return getToken(NaturalParser::RETURN, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FetchStatementContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FetchStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::FetchStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::FetchStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::FetchStatementContext::getRuleIndex() const {
  return NaturalParser::RuleFetchStatement;
}


std::any NaturalParser::FetchStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFetchStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FetchStatementContext* NaturalParser::fetchStatement() {
  FetchStatementContext *_localctx = _tracker.createInstance<FetchStatementContext>(_ctx, getState());
  enterRule(_localctx, 130, NaturalParser::RuleFetchStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1305);
    match(NaturalParser::FETCH);
    setState(1308);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(1306);
      match(NaturalParser::WS);
      setState(1307);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::RETURN

      || _la == NaturalParser::REPEAT)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1311);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1310);
      match(NaturalParser::WS);
    }
    setState(1313);
    antlrcpp::downCast<FetchStatementContext *>(_localctx)->subprogramName = match(NaturalParser::STRING);
    setState(1323);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1317);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0)) {
          setState(1314);
          _la = _input->LA(1);
          if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 274)) & 6291457) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1319);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1320);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::STRING

        || _la == NaturalParser::IDENTIFIER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(1325);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallStatementContext ------------------------------------------------------------------

NaturalParser::CallStatementContext::CallStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CallStatementContext::CALL() {
  return getToken(NaturalParser::CALL, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::CallStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::CallStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CallStatementContext::STRING() {
  return getTokens(NaturalParser::STRING);
}

tree::TerminalNode* NaturalParser::CallStatementContext::STRING(size_t i) {
  return getToken(NaturalParser::STRING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CallStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::CallStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::CallStatementContext::INTERFACE4() {
  return getToken(NaturalParser::INTERFACE4, 0);
}

tree::TerminalNode* NaturalParser::CallStatementContext::USING() {
  return getToken(NaturalParser::USING, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::CallStatementContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::CallStatementContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NaturalParser::CallStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::CallStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::CallStatementContext::getRuleIndex() const {
  return NaturalParser::RuleCallStatement;
}


std::any NaturalParser::CallStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCallStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CallStatementContext* NaturalParser::callStatement() {
  CallStatementContext *_localctx = _tracker.createInstance<CallStatementContext>(_ctx, getState());
  enterRule(_localctx, 132, NaturalParser::RuleCallStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1326);
    match(NaturalParser::CALL);
    setState(1329);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      setState(1327);
      match(NaturalParser::WS);
      setState(1328);
      match(NaturalParser::INTERFACE4);
      break;
    }

    default:
      break;
    }
    setState(1332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1331);
      match(NaturalParser::WS);
    }
    setState(1334);
    antlrcpp::downCast<CallStatementContext *>(_localctx)->subprogramName = match(NaturalParser::STRING);
    setState(1339);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
    case 1: {
      setState(1336);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1335);
        match(NaturalParser::WS);
      }
      setState(1338);
      match(NaturalParser::USING);
      break;
    }

    default:
      break;
    }
    setState(1350);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1344);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0)) {
          setState(1341);
          _la = _input->LA(1);
          if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 274)) & 6291457) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1346);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1347);
        _la = _input->LA(1);
        if (!(_la == NaturalParser::STRING

        || _la == NaturalParser::IDENTIFIER)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(1352);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    }
    setState(1354);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1353);
      match(NaturalParser::WS);
    }
    setState(1356);
    match(NaturalParser::NL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForStatementContext ------------------------------------------------------------------

NaturalParser::ForStatementContext::ForStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ForStatementContext::FOR() {
  return getToken(NaturalParser::FOR, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ForStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ForStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::ConditionContext* NaturalParser::ForStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

tree::TerminalNode* NaturalParser::ForStatementContext::TO() {
  return getToken(NaturalParser::TO, 0);
}

NaturalParser::OperandContext* NaturalParser::ForStatementContext::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

tree::TerminalNode* NaturalParser::ForStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

tree::TerminalNode* NaturalParser::ForStatementContext::END_FOR() {
  return getToken(NaturalParser::END_FOR, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::ForStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::ForStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::ForStatementContext::getRuleIndex() const {
  return NaturalParser::RuleForStatement;
}


std::any NaturalParser::ForStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitForStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ForStatementContext* NaturalParser::forStatement() {
  ForStatementContext *_localctx = _tracker.createInstance<ForStatementContext>(_ctx, getState());
  enterRule(_localctx, 134, NaturalParser::RuleForStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1358);
    match(NaturalParser::FOR);
    setState(1359);
    match(NaturalParser::WS);
    setState(1360);
    condition();
    setState(1361);
    match(NaturalParser::TO);
    setState(1362);
    match(NaturalParser::WS);
    setState(1363);
    operand();
    setState(1367);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0)) {
      setState(1364);
      statement();
      setState(1369);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1370);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::LOOP

    || _la == NaturalParser::END_FOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AcceptRejectIfStatementContext ------------------------------------------------------------------

NaturalParser::AcceptRejectIfStatementContext::AcceptRejectIfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::ConditionContext* NaturalParser::AcceptRejectIfStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

tree::TerminalNode* NaturalParser::AcceptRejectIfStatementContext::ACCEPT_IF() {
  return getToken(NaturalParser::ACCEPT_IF, 0);
}

tree::TerminalNode* NaturalParser::AcceptRejectIfStatementContext::REJECT_IF() {
  return getToken(NaturalParser::REJECT_IF, 0);
}

tree::TerminalNode* NaturalParser::AcceptRejectIfStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}


size_t NaturalParser::AcceptRejectIfStatementContext::getRuleIndex() const {
  return NaturalParser::RuleAcceptRejectIfStatement;
}


std::any NaturalParser::AcceptRejectIfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAcceptRejectIfStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AcceptRejectIfStatementContext* NaturalParser::acceptRejectIfStatement() {
  AcceptRejectIfStatementContext *_localctx = _tracker.createInstance<AcceptRejectIfStatementContext>(_ctx, getState());
  enterRule(_localctx, 136, NaturalParser::RuleAcceptRejectIfStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1372);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::ACCEPT_IF

    || _la == NaturalParser::REJECT_IF)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1374);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1373);
      match(NaturalParser::WS);
    }
    setState(1376);
    condition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecisionStatementContext ------------------------------------------------------------------

NaturalParser::DecisionStatementContext::DecisionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::DecisionStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::END_DECIDE() {
  return getToken(NaturalParser::END_DECIDE, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::DECIDE_FOR() {
  return getToken(NaturalParser::DECIDE_FOR, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::DECIDE_ON() {
  return getToken(NaturalParser::DECIDE_ON, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::FIRST() {
  return getToken(NaturalParser::FIRST, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::EVERY() {
  return getToken(NaturalParser::EVERY, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::WHEN() {
  return getToken(NaturalParser::WHEN, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::DecisionStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::DecisionStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::VALUE_OF() {
  return getToken(NaturalParser::VALUE_OF, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::VALUE() {
  return getToken(NaturalParser::VALUE, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::CONDITION() {
  return getToken(NaturalParser::CONDITION, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::DecisionStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::DecisionStatementContext::getRuleIndex() const {
  return NaturalParser::RuleDecisionStatement;
}


std::any NaturalParser::DecisionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitDecisionStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::DecisionStatementContext* NaturalParser::decisionStatement() {
  DecisionStatementContext *_localctx = _tracker.createInstance<DecisionStatementContext>(_ctx, getState());
  enterRule(_localctx, 138, NaturalParser::RuleDecisionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1378);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::DECIDE_FOR

    || _la == NaturalParser::DECIDE_ON)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1380);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1379);
      match(NaturalParser::WS);
    }
    setState(1382);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::EVERY

    || _la == NaturalParser::FIRST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1396);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      setState(1383);
      match(NaturalParser::WS);
      setState(1385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::CONDITION) {
        setState(1384);
        match(NaturalParser::CONDITION);
      }
      setState(1388);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
      case 1: {
        setState(1387);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1391);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::NL) {
        setState(1390);
        match(NaturalParser::NL);
      }
      setState(1394);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::LINE_NUMBER) {
        setState(1393);
        match(NaturalParser::LINE_NUMBER);
      }
      break;
    }

    default:
      break;
    }
    setState(1399);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::VALUE_OF

    || _la == NaturalParser::VALUE) {
      setState(1398);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::VALUE_OF

      || _la == NaturalParser::VALUE)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1402);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
    case 1: {
      setState(1401);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WHEN) {
      setState(1404);
      match(NaturalParser::WHEN);
    }
    setState(1407);
    match(NaturalParser::WS);
    setState(1408);
    match(NaturalParser::IDENTIFIER);
    setState(1412);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1409);
        statement(); 
      }
      setState(1414);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx);
    }
    setState(1415);
    match(NaturalParser::END_DECIDE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

NaturalParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::IfStructuredStatementContext* NaturalParser::IfStatementContext::ifStructuredStatement() {
  return getRuleContext<NaturalParser::IfStructuredStatementContext>(0);
}

NaturalParser::IfElseStatementContext* NaturalParser::IfStatementContext::ifElseStatement() {
  return getRuleContext<NaturalParser::IfElseStatementContext>(0);
}

NaturalParser::IfMultilinedStatementContext* NaturalParser::IfStatementContext::ifMultilinedStatement() {
  return getRuleContext<NaturalParser::IfMultilinedStatementContext>(0);
}

NaturalParser::IfSinglelinedStatementContext* NaturalParser::IfStatementContext::ifSinglelinedStatement() {
  return getRuleContext<NaturalParser::IfSinglelinedStatementContext>(0);
}

NaturalParser::AcceptRejectIfStatementContext* NaturalParser::IfStatementContext::acceptRejectIfStatement() {
  return getRuleContext<NaturalParser::AcceptRejectIfStatementContext>(0);
}


size_t NaturalParser::IfStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIfStatement;
}


std::any NaturalParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IfStatementContext* NaturalParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 140, NaturalParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1422);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1417);
      ifStructuredStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1418);
      ifElseStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1419);
      ifMultilinedStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1420);
      ifSinglelinedStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1421);
      acceptRejectIfStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStructuredStatementContext ------------------------------------------------------------------

NaturalParser::IfStructuredStatementContext::IfStructuredStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfStructuredStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::ConditionContext* NaturalParser::IfStructuredStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::END_IF() {
  return getToken(NaturalParser::END_IF, 0);
}

NaturalParser::ElseStructuredContext* NaturalParser::IfStructuredStatementContext::elseStructured() {
  return getRuleContext<NaturalParser::ElseStructuredContext>(0);
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::THEN() {
  return getToken(NaturalParser::THEN, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::IfStructuredStatementContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::IfStructuredStatementContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::IfStructuredStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::IfStructuredStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::IfStructuredStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::IfStructuredStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIfStructuredStatement;
}


std::any NaturalParser::IfStructuredStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIfStructuredStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IfStructuredStatementContext* NaturalParser::ifStructuredStatement() {
  IfStructuredStatementContext *_localctx = _tracker.createInstance<IfStructuredStatementContext>(_ctx, getState());
  enterRule(_localctx, 142, NaturalParser::RuleIfStructuredStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1424);
    match(NaturalParser::IF);
    setState(1425);
    match(NaturalParser::WS);
    setState(1426);
    condition();
    setState(1430);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1427);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(1432);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    }
    setState(1434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::THEN) {
      setState(1433);
      match(NaturalParser::THEN);
    }
    setState(1437); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1436);
      statement();
      setState(1439); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0));
    setState(1443);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::END_IF: {
        setState(1441);
        match(NaturalParser::END_IF);
        break;
      }

      case NaturalParser::ELSE: {
        setState(1442);
        elseStructured();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseStructuredContext ------------------------------------------------------------------

NaturalParser::ElseStructuredContext::ElseStructuredContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ElseStructuredContext::ELSE() {
  return getToken(NaturalParser::ELSE, 0);
}

tree::TerminalNode* NaturalParser::ElseStructuredContext::END_IF() {
  return getToken(NaturalParser::END_IF, 0);
}

std::vector<NaturalParser::StatementContext *> NaturalParser::ElseStructuredContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::ElseStructuredContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}


size_t NaturalParser::ElseStructuredContext::getRuleIndex() const {
  return NaturalParser::RuleElseStructured;
}


std::any NaturalParser::ElseStructuredContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitElseStructured(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ElseStructuredContext* NaturalParser::elseStructured() {
  ElseStructuredContext *_localctx = _tracker.createInstance<ElseStructuredContext>(_ctx, getState());
  enterRule(_localctx, 144, NaturalParser::RuleElseStructured);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1445);
    match(NaturalParser::ELSE);
    setState(1449);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -12885270530) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & -1) != 0) || ((((_la - 129) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 129)) & -1) != 0) || ((((_la - 193) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 193)) & -16385) != 0) || ((((_la - 257) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 257)) & 72057594037927935) != 0)) {
      setState(1446);
      statement();
      setState(1451);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1452);
    match(NaturalParser::END_IF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfElseStatementContext ------------------------------------------------------------------

NaturalParser::IfElseStatementContext::IfElseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::IfElseStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfElseStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::IfElseStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::ConditionContext* NaturalParser::IfElseStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

NaturalParser::DoStatementContext* NaturalParser::IfElseStatementContext::doStatement() {
  return getRuleContext<NaturalParser::DoStatementContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfElseStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::IfElseStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

NaturalParser::ElseMultilinedStatementContext* NaturalParser::IfElseStatementContext::elseMultilinedStatement() {
  return getRuleContext<NaturalParser::ElseMultilinedStatementContext>(0);
}

NaturalParser::ElseSinglelinedStatementContext* NaturalParser::IfElseStatementContext::elseSinglelinedStatement() {
  return getRuleContext<NaturalParser::ElseSinglelinedStatementContext>(0);
}

tree::TerminalNode* NaturalParser::IfElseStatementContext::THEN() {
  return getToken(NaturalParser::THEN, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfElseStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::IfElseStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::IfElseStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIfElseStatement;
}


std::any NaturalParser::IfElseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIfElseStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IfElseStatementContext* NaturalParser::ifElseStatement() {
  IfElseStatementContext *_localctx = _tracker.createInstance<IfElseStatementContext>(_ctx, getState());
  enterRule(_localctx, 146, NaturalParser::RuleIfElseStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1454);
    match(NaturalParser::IF);
    setState(1455);
    match(NaturalParser::WS);
    setState(1456);
    condition();
    setState(1463);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1457);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1458);
        match(NaturalParser::NL);
        setState(1460);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1459);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1462);
        match(NaturalParser::WS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1466);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::THEN) {
      setState(1465);
      match(NaturalParser::THEN);
    }
    setState(1474);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1468);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1469);
        match(NaturalParser::NL);
        setState(1471);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1470);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1473);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::DO: {
        break;
      }

    default:
      break;
    }
    setState(1476);
    doStatement();
    setState(1483);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1477);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1478);
        match(NaturalParser::NL);
        setState(1480);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1479);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1482);
        match(NaturalParser::WS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1487);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
    case 1: {
      setState(1485);
      elseMultilinedStatement();
      break;
    }

    case 2: {
      setState(1486);
      elseSinglelinedStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfMultilinedStatementContext ------------------------------------------------------------------

NaturalParser::IfMultilinedStatementContext::IfMultilinedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::IfMultilinedStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfMultilinedStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::IfMultilinedStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::ConditionContext* NaturalParser::IfMultilinedStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

tree::TerminalNode* NaturalParser::IfMultilinedStatementContext::THEN() {
  return getToken(NaturalParser::THEN, 0);
}

NaturalParser::DoStatementContext* NaturalParser::IfMultilinedStatementContext::doStatement() {
  return getRuleContext<NaturalParser::DoStatementContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfMultilinedStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::IfMultilinedStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::IfMultilinedStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::IfMultilinedStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

NaturalParser::ElseMultilinedStatementContext* NaturalParser::IfMultilinedStatementContext::elseMultilinedStatement() {
  return getRuleContext<NaturalParser::ElseMultilinedStatementContext>(0);
}

NaturalParser::ElseSinglelinedStatementContext* NaturalParser::IfMultilinedStatementContext::elseSinglelinedStatement() {
  return getRuleContext<NaturalParser::ElseSinglelinedStatementContext>(0);
}


size_t NaturalParser::IfMultilinedStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIfMultilinedStatement;
}


std::any NaturalParser::IfMultilinedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIfMultilinedStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IfMultilinedStatementContext* NaturalParser::ifMultilinedStatement() {
  IfMultilinedStatementContext *_localctx = _tracker.createInstance<IfMultilinedStatementContext>(_ctx, getState());
  enterRule(_localctx, 148, NaturalParser::RuleIfMultilinedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1489);
    match(NaturalParser::IF);
    setState(1490);
    match(NaturalParser::WS);
    setState(1491);
    condition();
    setState(1495);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 6291457) != 0)) {
      setState(1492);
      _la = _input->LA(1);
      if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 6291457) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1497);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1498);
    match(NaturalParser::THEN);
    setState(1502);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 6291457) != 0)) {
      setState(1499);
      _la = _input->LA(1);
      if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 6291457) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1504);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1505);
    doStatement();
    setState(1517);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
    case 1: {
      setState(1511);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
      case 1: {
        setState(1506);
        match(NaturalParser::WS);
        break;
      }

      case 2: {
        setState(1508);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1507);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1510);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1515);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
      case 1: {
        setState(1513);
        elseMultilinedStatement();
        break;
      }

      case 2: {
        setState(1514);
        elseSinglelinedStatement();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfSinglelinedStatementContext ------------------------------------------------------------------

NaturalParser::IfSinglelinedStatementContext::IfSinglelinedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::IfSinglelinedStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfSinglelinedStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::IfSinglelinedStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::ConditionContext* NaturalParser::IfSinglelinedStatementContext::condition() {
  return getRuleContext<NaturalParser::ConditionContext>(0);
}

NaturalParser::OnelinerBodyContext* NaturalParser::IfSinglelinedStatementContext::onelinerBody() {
  return getRuleContext<NaturalParser::OnelinerBodyContext>(0);
}

tree::TerminalNode* NaturalParser::IfSinglelinedStatementContext::THEN() {
  return getToken(NaturalParser::THEN, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::IfSinglelinedStatementContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::IfSinglelinedStatementContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

std::vector<tree::TerminalNode *> NaturalParser::IfSinglelinedStatementContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::IfSinglelinedStatementContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

NaturalParser::ElseMultilinedStatementContext* NaturalParser::IfSinglelinedStatementContext::elseMultilinedStatement() {
  return getRuleContext<NaturalParser::ElseMultilinedStatementContext>(0);
}

NaturalParser::ElseSinglelinedStatementContext* NaturalParser::IfSinglelinedStatementContext::elseSinglelinedStatement() {
  return getRuleContext<NaturalParser::ElseSinglelinedStatementContext>(0);
}


size_t NaturalParser::IfSinglelinedStatementContext::getRuleIndex() const {
  return NaturalParser::RuleIfSinglelinedStatement;
}


std::any NaturalParser::IfSinglelinedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitIfSinglelinedStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::IfSinglelinedStatementContext* NaturalParser::ifSinglelinedStatement() {
  IfSinglelinedStatementContext *_localctx = _tracker.createInstance<IfSinglelinedStatementContext>(_ctx, getState());
  enterRule(_localctx, 150, NaturalParser::RuleIfSinglelinedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1519);
    match(NaturalParser::IF);
    setState(1520);
    match(NaturalParser::WS);
    setState(1521);
    condition();
    setState(1525);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1522);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(1527);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx);
    }
    setState(1529);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::THEN) {
      setState(1528);
      match(NaturalParser::THEN);
    }
    setState(1534);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1531);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        } 
      }
      setState(1536);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    }
    setState(1537);
    onelinerBody();
    setState(1548);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
    case 1: {
      setState(1541);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 6291457) != 0)) {
        setState(1538);
        _la = _input->LA(1);
        if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 274)) & 6291457) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1543);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1546);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
      case 1: {
        setState(1544);
        elseMultilinedStatement();
        break;
      }

      case 2: {
        setState(1545);
        elseSinglelinedStatement();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseMultilinedStatementContext ------------------------------------------------------------------

NaturalParser::ElseMultilinedStatementContext::ElseMultilinedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ElseMultilinedStatementContext::ELSE() {
  return getToken(NaturalParser::ELSE, 0);
}

NaturalParser::DoStatementContext* NaturalParser::ElseMultilinedStatementContext::doStatement() {
  return getRuleContext<NaturalParser::DoStatementContext>(0);
}

tree::TerminalNode* NaturalParser::ElseMultilinedStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::ElseMultilinedStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::ElseMultilinedStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::ElseMultilinedStatementContext::getRuleIndex() const {
  return NaturalParser::RuleElseMultilinedStatement;
}


std::any NaturalParser::ElseMultilinedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitElseMultilinedStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ElseMultilinedStatementContext* NaturalParser::elseMultilinedStatement() {
  ElseMultilinedStatementContext *_localctx = _tracker.createInstance<ElseMultilinedStatementContext>(_ctx, getState());
  enterRule(_localctx, 152, NaturalParser::RuleElseMultilinedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1550);
    match(NaturalParser::ELSE);
    setState(1557);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1551);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1552);
        match(NaturalParser::NL);
        setState(1554);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1553);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1556);
        match(NaturalParser::WS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1559);
    doStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseSinglelinedStatementContext ------------------------------------------------------------------

NaturalParser::ElseSinglelinedStatementContext::ElseSinglelinedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ElseSinglelinedStatementContext::ELSE() {
  return getToken(NaturalParser::ELSE, 0);
}

NaturalParser::OnelinerBodyContext* NaturalParser::ElseSinglelinedStatementContext::onelinerBody() {
  return getRuleContext<NaturalParser::OnelinerBodyContext>(0);
}

tree::TerminalNode* NaturalParser::ElseSinglelinedStatementContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::ElseSinglelinedStatementContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::ElseSinglelinedStatementContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::ElseSinglelinedStatementContext::getRuleIndex() const {
  return NaturalParser::RuleElseSinglelinedStatement;
}


std::any NaturalParser::ElseSinglelinedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitElseSinglelinedStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ElseSinglelinedStatementContext* NaturalParser::elseSinglelinedStatement() {
  ElseSinglelinedStatementContext *_localctx = _tracker.createInstance<ElseSinglelinedStatementContext>(_ctx, getState());
  enterRule(_localctx, 154, NaturalParser::RuleElseSinglelinedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1561);
    match(NaturalParser::ELSE);
    setState(1568);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1562);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1563);
        match(NaturalParser::NL);
        setState(1565);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1564);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1567);
        match(NaturalParser::WS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1570);
    onelinerBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnelinerBodyContext ------------------------------------------------------------------

NaturalParser::OnelinerBodyContext::OnelinerBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::StatementContext* NaturalParser::OnelinerBodyContext::statement() {
  return getRuleContext<NaturalParser::StatementContext>(0);
}

tree::TerminalNode* NaturalParser::OnelinerBodyContext::NL() {
  return getToken(NaturalParser::NL, 0);
}

tree::TerminalNode* NaturalParser::OnelinerBodyContext::EOF() {
  return getToken(NaturalParser::EOF, 0);
}

tree::TerminalNode* NaturalParser::OnelinerBodyContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::OnelinerBodyContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}


size_t NaturalParser::OnelinerBodyContext::getRuleIndex() const {
  return NaturalParser::RuleOnelinerBody;
}


std::any NaturalParser::OnelinerBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitOnelinerBody(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::OnelinerBodyContext* NaturalParser::onelinerBody() {
  OnelinerBodyContext *_localctx = _tracker.createInstance<OnelinerBodyContext>(_ctx, getState());
  enterRule(_localctx, 156, NaturalParser::RuleOnelinerBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1588);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1576);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
      case 1: {
        setState(1573);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1572);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1575);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1578);
      statement();
      setState(1579);
      _la = _input->LA(1);
      if (!(_la == NaturalParser::EOF || _la == NaturalParser::NL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1585);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
      case 1: {
        setState(1582);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1581);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1584);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1587);
      statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionContext ------------------------------------------------------------------

NaturalParser::ConditionContext::ConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::OperandContext *> NaturalParser::ConditionContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::ConditionContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::ConditionContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ConditionContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ConditionContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ConditionContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

NaturalParser::LogicalOpContext* NaturalParser::ConditionContext::logicalOp() {
  return getRuleContext<NaturalParser::LogicalOpContext>(0);
}

NaturalParser::CompOpContext* NaturalParser::ConditionContext::compOp() {
  return getRuleContext<NaturalParser::CompOpContext>(0);
}

NaturalParser::ArithmaticOpContext* NaturalParser::ConditionContext::arithmaticOp() {
  return getRuleContext<NaturalParser::ArithmaticOpContext>(0);
}

NaturalParser::OptionalConditionContext* NaturalParser::ConditionContext::optionalCondition() {
  return getRuleContext<NaturalParser::OptionalConditionContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::ConditionContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::ConditionContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}

tree::TerminalNode* NaturalParser::ConditionContext::NOT_TEXT() {
  return getToken(NaturalParser::NOT_TEXT, 0);
}


size_t NaturalParser::ConditionContext::getRuleIndex() const {
  return NaturalParser::RuleCondition;
}


std::any NaturalParser::ConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCondition(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ConditionContext* NaturalParser::condition() {
  ConditionContext *_localctx = _tracker.createInstance<ConditionContext>(_ctx, getState());
  enterRule(_localctx, 158, NaturalParser::RuleCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1650);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 269, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1590);
      operand();
      setState(1597);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::WS: {
          setState(1591);
          match(NaturalParser::WS);
          break;
        }

        case NaturalParser::NL: {
          setState(1592);
          match(NaturalParser::NL);
          setState(1594);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == NaturalParser::LINE_NUMBER) {
            setState(1593);
            match(NaturalParser::LINE_NUMBER);
          }
          setState(1596);
          match(NaturalParser::WS);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1602);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::AND_TEXT:
        case NaturalParser::OR_TEXT:
        case NaturalParser::NOT_TEXT:
        case NaturalParser::AND_EQ:
        case NaturalParser::OR_RQ:
        case NaturalParser::OR_SRQ:
        case NaturalParser::EQUAL:
        case NaturalParser::NOTEQUAL:
        case NaturalParser::EQUAL_TO:
        case NaturalParser::LESS_THAN:
        case NaturalParser::GREATER_THAN:
        case NaturalParser::LESS_EQUAL:
        case NaturalParser::GREATER_EQUAL:
        case NaturalParser::AND:
        case NaturalParser::OR: {
          setState(1599);
          logicalOp();
          break;
        }

        case NaturalParser::GT_TEXT:
        case NaturalParser::LT_TEXT:
        case NaturalParser::GE_TEXT:
        case NaturalParser::LE_TEXT:
        case NaturalParser::EQ_TEXT:
        case NaturalParser::NE_TEXT:
        case NaturalParser::EQ:
        case NaturalParser::GT:
        case NaturalParser::LT:
        case NaturalParser::GE:
        case NaturalParser::LE:
        case NaturalParser::NE: {
          setState(1600);
          compOp();
          break;
        }

        case NaturalParser::PLUS:
        case NaturalParser::MINUS:
        case NaturalParser::MULT:
        case NaturalParser::DIV: {
          setState(1601);
          arithmaticOp();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1610);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case NaturalParser::WS: {
          setState(1604);
          match(NaturalParser::WS);
          break;
        }

        case NaturalParser::NL: {
          setState(1605);
          match(NaturalParser::NL);
          setState(1607);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == NaturalParser::LINE_NUMBER) {
            setState(1606);
            match(NaturalParser::LINE_NUMBER);
          }
          setState(1609);
          match(NaturalParser::WS);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1612);
      operand();
      setState(1622);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
      case 1: {
        setState(1619);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case NaturalParser::WS: {
            setState(1613);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::NL: {
            setState(1614);
            match(NaturalParser::NL);
            setState(1616);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == NaturalParser::LINE_NUMBER) {
              setState(1615);
              match(NaturalParser::LINE_NUMBER);
            }
            setState(1618);
            match(NaturalParser::WS);
            break;
          }

          case NaturalParser::GT_TEXT:
          case NaturalParser::LT_TEXT:
          case NaturalParser::GE_TEXT:
          case NaturalParser::LE_TEXT:
          case NaturalParser::EQ_TEXT:
          case NaturalParser::NE_TEXT:
          case NaturalParser::AND_TEXT:
          case NaturalParser::OR_TEXT:
          case NaturalParser::NOT_TEXT:
          case NaturalParser::AND_EQ:
          case NaturalParser::OR_RQ:
          case NaturalParser::OR_SRQ:
          case NaturalParser::EQUAL:
          case NaturalParser::NOTEQUAL:
          case NaturalParser::EQUAL_TO:
          case NaturalParser::LESS_THAN:
          case NaturalParser::GREATER_THAN:
          case NaturalParser::LESS_EQUAL:
          case NaturalParser::GREATER_EQUAL:
          case NaturalParser::PLUS:
          case NaturalParser::MINUS:
          case NaturalParser::MULT:
          case NaturalParser::DIV:
          case NaturalParser::EQ:
          case NaturalParser::GT:
          case NaturalParser::LT:
          case NaturalParser::GE:
          case NaturalParser::LE:
          case NaturalParser::NE:
          case NaturalParser::AND:
          case NaturalParser::OR: {
            break;
          }

        default:
          break;
        }
        setState(1621);
        optionalCondition();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1624);
      operand();
      setState(1631);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 264, _ctx)) {
      case 1: {
        setState(1625);
        match(NaturalParser::WS);
        break;
      }

      case 2: {
        setState(1626);
        match(NaturalParser::NL);
        setState(1628);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1627);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1630);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1634);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 265, _ctx)) {
      case 1: {
        setState(1633);
        optionalCondition();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1636);
      match(NaturalParser::NOT_TEXT);
      setState(1637);
      match(NaturalParser::WS);
      setState(1638);
      operand();
      setState(1645);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
      case 1: {
        setState(1639);
        match(NaturalParser::WS);
        break;
      }

      case 2: {
        setState(1640);
        match(NaturalParser::NL);
        setState(1642);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1641);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1644);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1648);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
      case 1: {
        setState(1647);
        optionalCondition();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalConditionContext ------------------------------------------------------------------

NaturalParser::OptionalConditionContext::OptionalConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::OperandContext* NaturalParser::OptionalConditionContext::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

NaturalParser::LogicalOpContext* NaturalParser::OptionalConditionContext::logicalOp() {
  return getRuleContext<NaturalParser::LogicalOpContext>(0);
}

NaturalParser::CompOpContext* NaturalParser::OptionalConditionContext::compOp() {
  return getRuleContext<NaturalParser::CompOpContext>(0);
}

NaturalParser::ArithmaticOpContext* NaturalParser::OptionalConditionContext::arithmaticOp() {
  return getRuleContext<NaturalParser::ArithmaticOpContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::OptionalConditionContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::OptionalConditionContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OptionalConditionContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::OptionalConditionContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

NaturalParser::OptionalConditionContext* NaturalParser::OptionalConditionContext::optionalCondition() {
  return getRuleContext<NaturalParser::OptionalConditionContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::OptionalConditionContext::LINE_NUMBER() {
  return getTokens(NaturalParser::LINE_NUMBER);
}

tree::TerminalNode* NaturalParser::OptionalConditionContext::LINE_NUMBER(size_t i) {
  return getToken(NaturalParser::LINE_NUMBER, i);
}


size_t NaturalParser::OptionalConditionContext::getRuleIndex() const {
  return NaturalParser::RuleOptionalCondition;
}


std::any NaturalParser::OptionalConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitOptionalCondition(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::OptionalConditionContext* NaturalParser::optionalCondition() {
  OptionalConditionContext *_localctx = _tracker.createInstance<OptionalConditionContext>(_ctx, getState());
  enterRule(_localctx, 160, NaturalParser::RuleOptionalCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::AND_TEXT:
      case NaturalParser::OR_TEXT:
      case NaturalParser::NOT_TEXT:
      case NaturalParser::AND_EQ:
      case NaturalParser::OR_RQ:
      case NaturalParser::OR_SRQ:
      case NaturalParser::EQUAL:
      case NaturalParser::NOTEQUAL:
      case NaturalParser::EQUAL_TO:
      case NaturalParser::LESS_THAN:
      case NaturalParser::GREATER_THAN:
      case NaturalParser::LESS_EQUAL:
      case NaturalParser::GREATER_EQUAL:
      case NaturalParser::AND:
      case NaturalParser::OR: {
        setState(1652);
        logicalOp();
        break;
      }

      case NaturalParser::GT_TEXT:
      case NaturalParser::LT_TEXT:
      case NaturalParser::GE_TEXT:
      case NaturalParser::LE_TEXT:
      case NaturalParser::EQ_TEXT:
      case NaturalParser::NE_TEXT:
      case NaturalParser::EQ:
      case NaturalParser::GT:
      case NaturalParser::LT:
      case NaturalParser::GE:
      case NaturalParser::LE:
      case NaturalParser::NE: {
        setState(1653);
        compOp();
        break;
      }

      case NaturalParser::PLUS:
      case NaturalParser::MINUS:
      case NaturalParser::MULT:
      case NaturalParser::DIV: {
        setState(1654);
        arithmaticOp();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1663);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::WS: {
        setState(1657);
        match(NaturalParser::WS);
        break;
      }

      case NaturalParser::NL: {
        setState(1658);
        match(NaturalParser::NL);
        setState(1660);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::LINE_NUMBER) {
          setState(1659);
          match(NaturalParser::LINE_NUMBER);
        }
        setState(1662);
        match(NaturalParser::WS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1665);
    operand();
    setState(1672);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
    case 1: {
      setState(1666);
      match(NaturalParser::WS);
      break;
    }

    case 2: {
      setState(1667);
      match(NaturalParser::NL);
      setState(1669);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::LINE_NUMBER) {
        setState(1668);
        match(NaturalParser::LINE_NUMBER);
      }
      setState(1671);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1675);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(1674);
      optionalCondition();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperandContext ------------------------------------------------------------------

NaturalParser::OperandContext::OperandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::VariableContext* NaturalParser::OperandContext::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

tree::TerminalNode* NaturalParser::OperandContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}

tree::TerminalNode* NaturalParser::OperandContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::OperandContext::FLOAT() {
  return getToken(NaturalParser::FLOAT, 0);
}

NaturalParser::NaturalKeywordsContext* NaturalParser::OperandContext::naturalKeywords() {
  return getRuleContext<NaturalParser::NaturalKeywordsContext>(0);
}

tree::TerminalNode* NaturalParser::OperandContext::LPAREN() {
  return getToken(NaturalParser::LPAREN, 0);
}

NaturalParser::OperandContext* NaturalParser::OperandContext::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

tree::TerminalNode* NaturalParser::OperandContext::RPAREN() {
  return getToken(NaturalParser::RPAREN, 0);
}

tree::TerminalNode* NaturalParser::OperandContext::DATE_CONSTANT() {
  return getToken(NaturalParser::DATE_CONSTANT, 0);
}

tree::TerminalNode* NaturalParser::OperandContext::INPUT_PARAM() {
  return getToken(NaturalParser::INPUT_PARAM, 0);
}

tree::TerminalNode* NaturalParser::OperandContext::H_CONSTANT() {
  return getToken(NaturalParser::H_CONSTANT, 0);
}


size_t NaturalParser::OperandContext::getRuleIndex() const {
  return NaturalParser::RuleOperand;
}


std::any NaturalParser::OperandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitOperand(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::OperandContext* NaturalParser::operand() {
  OperandContext *_localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 162, NaturalParser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1689);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(1677);
        variable();
        break;
      }

      case NaturalParser::STRING: {
        enterOuterAlt(_localctx, 2);
        setState(1678);
        match(NaturalParser::STRING);
        break;
      }

      case NaturalParser::LINE_NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(1679);
        match(NaturalParser::LINE_NUMBER);
        break;
      }

      case NaturalParser::FLOAT: {
        enterOuterAlt(_localctx, 4);
        setState(1680);
        match(NaturalParser::FLOAT);
        break;
      }

      case NaturalParser::POSITION: {
        enterOuterAlt(_localctx, 5);
        setState(1681);
        naturalKeywords();
        break;
      }

      case NaturalParser::LPAREN: {
        enterOuterAlt(_localctx, 6);
        setState(1682);
        match(NaturalParser::LPAREN);
        setState(1683);
        operand();
        setState(1684);
        match(NaturalParser::RPAREN);
        break;
      }

      case NaturalParser::DATE_CONSTANT: {
        enterOuterAlt(_localctx, 7);
        setState(1686);
        match(NaturalParser::DATE_CONSTANT);
        break;
      }

      case NaturalParser::INPUT_PARAM: {
        enterOuterAlt(_localctx, 8);
        setState(1687);
        match(NaturalParser::INPUT_PARAM);
        break;
      }

      case NaturalParser::H_CONSTANT: {
        enterOuterAlt(_localctx, 9);
        setState(1688);
        match(NaturalParser::H_CONSTANT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NaturalKeywordsContext ------------------------------------------------------------------

NaturalParser::NaturalKeywordsContext::NaturalKeywordsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::NaturalKeywordsContext::POSITION() {
  return getToken(NaturalParser::POSITION, 0);
}

tree::TerminalNode* NaturalParser::NaturalKeywordsContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::NaturalKeywordsContext::LINE_REF() {
  return getToken(NaturalParser::LINE_REF, 0);
}


size_t NaturalParser::NaturalKeywordsContext::getRuleIndex() const {
  return NaturalParser::RuleNaturalKeywords;
}


std::any NaturalParser::NaturalKeywordsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitNaturalKeywords(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::NaturalKeywordsContext* NaturalParser::naturalKeywords() {
  NaturalKeywordsContext *_localctx = _tracker.createInstance<NaturalKeywordsContext>(_ctx, getState());
  enterRule(_localctx, 164, NaturalParser::RuleNaturalKeywords);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1691);
    match(NaturalParser::POSITION);
    setState(1694);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      setState(1692);
      match(NaturalParser::WS);
      setState(1693);
      match(NaturalParser::LINE_REF);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalOpContext ------------------------------------------------------------------

NaturalParser::LogicalOpContext::LogicalOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::LogicalOpContext::AND_TEXT() {
  return getToken(NaturalParser::AND_TEXT, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::OR_TEXT() {
  return getToken(NaturalParser::OR_TEXT, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::AND() {
  return getToken(NaturalParser::AND, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::OR() {
  return getToken(NaturalParser::OR, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::AND_EQ() {
  return getToken(NaturalParser::AND_EQ, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::OR_RQ() {
  return getToken(NaturalParser::OR_RQ, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::OR_SRQ() {
  return getToken(NaturalParser::OR_SRQ, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::NOT_TEXT() {
  return getToken(NaturalParser::NOT_TEXT, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::EQUAL() {
  return getToken(NaturalParser::EQUAL, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::NOTEQUAL() {
  return getToken(NaturalParser::NOTEQUAL, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::EQUAL_TO() {
  return getToken(NaturalParser::EQUAL_TO, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::LESS_THAN() {
  return getToken(NaturalParser::LESS_THAN, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::GREATER_THAN() {
  return getToken(NaturalParser::GREATER_THAN, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::LESS_EQUAL() {
  return getToken(NaturalParser::LESS_EQUAL, 0);
}

tree::TerminalNode* NaturalParser::LogicalOpContext::GREATER_EQUAL() {
  return getToken(NaturalParser::GREATER_EQUAL, 0);
}


size_t NaturalParser::LogicalOpContext::getRuleIndex() const {
  return NaturalParser::RuleLogicalOp;
}


std::any NaturalParser::LogicalOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitLogicalOp(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::LogicalOpContext* NaturalParser::logicalOp() {
  LogicalOpContext *_localctx = _tracker.createInstance<LogicalOpContext>(_ctx, getState());
  enterRule(_localctx, 166, NaturalParser::RuleLogicalOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1696);
    _la = _input->LA(1);
    if (!(((((_la - 259) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 259)) & 13194139541503) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubroutineContext ------------------------------------------------------------------

NaturalParser::SubroutineContext::SubroutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::SubroutineContext::DEFINE_SUBROUTINE() {
  return getToken(NaturalParser::DEFINE_SUBROUTINE, 0);
}

NaturalParser::SubroutineNamesContext* NaturalParser::SubroutineContext::subroutineNames() {
  return getRuleContext<NaturalParser::SubroutineNamesContext>(0);
}

NaturalParser::BlockContentSubroutineContext* NaturalParser::SubroutineContext::blockContentSubroutine() {
  return getRuleContext<NaturalParser::BlockContentSubroutineContext>(0);
}

tree::TerminalNode* NaturalParser::SubroutineContext::END_SUBROUTINE() {
  return getToken(NaturalParser::END_SUBROUTINE, 0);
}

tree::TerminalNode* NaturalParser::SubroutineContext::RETURN() {
  return getToken(NaturalParser::RETURN, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::SubroutineContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::SubroutineContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}


size_t NaturalParser::SubroutineContext::getRuleIndex() const {
  return NaturalParser::RuleSubroutine;
}


std::any NaturalParser::SubroutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSubroutine(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SubroutineContext* NaturalParser::subroutine() {
  SubroutineContext *_localctx = _tracker.createInstance<SubroutineContext>(_ctx, getState());
  enterRule(_localctx, 168, NaturalParser::RuleSubroutine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1698);
    match(NaturalParser::DEFINE_SUBROUTINE);
    setState(1700);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1699);
      match(NaturalParser::WS);
    }
    setState(1702);
    antlrcpp::downCast<SubroutineContext *>(_localctx)->subroutineName = subroutineNames();
    setState(1704);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      setState(1703);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1706);
    antlrcpp::downCast<SubroutineContext *>(_localctx)->subroutineBody = blockContentSubroutine();
    setState(1707);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::RETURN

    || _la == NaturalParser::END_SUBROUTINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContentSubroutineContext ------------------------------------------------------------------

NaturalParser::BlockContentSubroutineContext::BlockContentSubroutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::SubroutineStatementContext *> NaturalParser::BlockContentSubroutineContext::subroutineStatement() {
  return getRuleContexts<NaturalParser::SubroutineStatementContext>();
}

NaturalParser::SubroutineStatementContext* NaturalParser::BlockContentSubroutineContext::subroutineStatement(size_t i) {
  return getRuleContext<NaturalParser::SubroutineStatementContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::BlockContentSubroutineContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::BlockContentSubroutineContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::BlockContentSubroutineContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::BlockContentSubroutineContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::BlockContentSubroutineContext::TRAILING_COMMENT() {
  return getToken(NaturalParser::TRAILING_COMMENT, 0);
}


size_t NaturalParser::BlockContentSubroutineContext::getRuleIndex() const {
  return NaturalParser::RuleBlockContentSubroutine;
}


std::any NaturalParser::BlockContentSubroutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitBlockContentSubroutine(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::BlockContentSubroutineContext* NaturalParser::blockContentSubroutine() {
  BlockContentSubroutineContext *_localctx = _tracker.createInstance<BlockContentSubroutineContext>(_ctx, getState());
  enterRule(_localctx, 170, NaturalParser::RuleBlockContentSubroutine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1714);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1712);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
        case 1: {
          setState(1709);
          subroutineStatement();
          break;
        }

        case 2: {
          setState(1710);
          match(NaturalParser::WS);
          break;
        }

        case 3: {
          setState(1711);
          match(NaturalParser::NL);
          break;
        }

        default:
          break;
        } 
      }
      setState(1716);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx);
    }
    setState(1718);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::TRAILING_COMMENT) {
      setState(1717);
      match(NaturalParser::TRAILING_COMMENT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubroutineStatementContext ------------------------------------------------------------------

NaturalParser::SubroutineStatementContext::SubroutineStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::DataDefinitionContext* NaturalParser::SubroutineStatementContext::dataDefinition() {
  return getRuleContext<NaturalParser::DataDefinitionContext>(0);
}

NaturalParser::SubroutineContext* NaturalParser::SubroutineStatementContext::subroutine() {
  return getRuleContext<NaturalParser::SubroutineContext>(0);
}

NaturalParser::FunctionDefinitionContext* NaturalParser::SubroutineStatementContext::functionDefinition() {
  return getRuleContext<NaturalParser::FunctionDefinitionContext>(0);
}

NaturalParser::ValueAssignmentContext* NaturalParser::SubroutineStatementContext::valueAssignment() {
  return getRuleContext<NaturalParser::ValueAssignmentContext>(0);
}

NaturalParser::ForStatementContext* NaturalParser::SubroutineStatementContext::forStatement() {
  return getRuleContext<NaturalParser::ForStatementContext>(0);
}

NaturalParser::IfStatementContext* NaturalParser::SubroutineStatementContext::ifStatement() {
  return getRuleContext<NaturalParser::IfStatementContext>(0);
}

NaturalParser::PerformStatementContext* NaturalParser::SubroutineStatementContext::performStatement() {
  return getRuleContext<NaturalParser::PerformStatementContext>(0);
}

NaturalParser::CallnatStatementContext* NaturalParser::SubroutineStatementContext::callnatStatement() {
  return getRuleContext<NaturalParser::CallnatStatementContext>(0);
}

NaturalParser::RedefineStatementContext* NaturalParser::SubroutineStatementContext::redefineStatement() {
  return getRuleContext<NaturalParser::RedefineStatementContext>(0);
}

NaturalParser::ResetStatementContext* NaturalParser::SubroutineStatementContext::resetStatement() {
  return getRuleContext<NaturalParser::ResetStatementContext>(0);
}

NaturalParser::ExamineStatementContext* NaturalParser::SubroutineStatementContext::examineStatement() {
  return getRuleContext<NaturalParser::ExamineStatementContext>(0);
}

NaturalParser::MoveStatementContext* NaturalParser::SubroutineStatementContext::moveStatement() {
  return getRuleContext<NaturalParser::MoveStatementContext>(0);
}

NaturalParser::FindStatementContext* NaturalParser::SubroutineStatementContext::findStatement() {
  return getRuleContext<NaturalParser::FindStatementContext>(0);
}

NaturalParser::ReadStatementContext* NaturalParser::SubroutineStatementContext::readStatement() {
  return getRuleContext<NaturalParser::ReadStatementContext>(0);
}

NaturalParser::StoreStatementContext* NaturalParser::SubroutineStatementContext::storeStatement() {
  return getRuleContext<NaturalParser::StoreStatementContext>(0);
}

NaturalParser::UpdateStatementContext* NaturalParser::SubroutineStatementContext::updateStatement() {
  return getRuleContext<NaturalParser::UpdateStatementContext>(0);
}

NaturalParser::DeleteStatementContext* NaturalParser::SubroutineStatementContext::deleteStatement() {
  return getRuleContext<NaturalParser::DeleteStatementContext>(0);
}

NaturalParser::GetStatementsContext* NaturalParser::SubroutineStatementContext::getStatements() {
  return getRuleContext<NaturalParser::GetStatementsContext>(0);
}

NaturalParser::HistogramStatementContext* NaturalParser::SubroutineStatementContext::histogramStatement() {
  return getRuleContext<NaturalParser::HistogramStatementContext>(0);
}

NaturalParser::EndTransactionContext* NaturalParser::SubroutineStatementContext::endTransaction() {
  return getRuleContext<NaturalParser::EndTransactionContext>(0);
}

NaturalParser::BackoutTransactionContext* NaturalParser::SubroutineStatementContext::backoutTransaction() {
  return getRuleContext<NaturalParser::BackoutTransactionContext>(0);
}

NaturalParser::ReadworkfileStatementContext* NaturalParser::SubroutineStatementContext::readworkfileStatement() {
  return getRuleContext<NaturalParser::ReadworkfileStatementContext>(0);
}

NaturalParser::WriteworkfileStatementContext* NaturalParser::SubroutineStatementContext::writeworkfileStatement() {
  return getRuleContext<NaturalParser::WriteworkfileStatementContext>(0);
}

NaturalParser::CloseworkfileStatementContext* NaturalParser::SubroutineStatementContext::closeworkfileStatement() {
  return getRuleContext<NaturalParser::CloseworkfileStatementContext>(0);
}

NaturalParser::InputStatementContext* NaturalParser::SubroutineStatementContext::inputStatement() {
  return getRuleContext<NaturalParser::InputStatementContext>(0);
}

NaturalParser::ReinputStatementContext* NaturalParser::SubroutineStatementContext::reinputStatement() {
  return getRuleContext<NaturalParser::ReinputStatementContext>(0);
}

NaturalParser::CalculationsContext* NaturalParser::SubroutineStatementContext::calculations() {
  return getRuleContext<NaturalParser::CalculationsContext>(0);
}

NaturalParser::AssignStatementContext* NaturalParser::SubroutineStatementContext::assignStatement() {
  return getRuleContext<NaturalParser::AssignStatementContext>(0);
}

NaturalParser::SortStatementContext* NaturalParser::SubroutineStatementContext::sortStatement() {
  return getRuleContext<NaturalParser::SortStatementContext>(0);
}

NaturalParser::CompressStatementContext* NaturalParser::SubroutineStatementContext::compressStatement() {
  return getRuleContext<NaturalParser::CompressStatementContext>(0);
}

NaturalParser::DoStatementContext* NaturalParser::SubroutineStatementContext::doStatement() {
  return getRuleContext<NaturalParser::DoStatementContext>(0);
}

NaturalParser::RepeatStatementContext* NaturalParser::SubroutineStatementContext::repeatStatement() {
  return getRuleContext<NaturalParser::RepeatStatementContext>(0);
}

NaturalParser::AtStartOfDataStatementContext* NaturalParser::SubroutineStatementContext::atStartOfDataStatement() {
  return getRuleContext<NaturalParser::AtStartOfDataStatementContext>(0);
}

NaturalParser::FormatStatementContext* NaturalParser::SubroutineStatementContext::formatStatement() {
  return getRuleContext<NaturalParser::FormatStatementContext>(0);
}

NaturalParser::AssignmentStatementContext* NaturalParser::SubroutineStatementContext::assignmentStatement() {
  return getRuleContext<NaturalParser::AssignmentStatementContext>(0);
}

NaturalParser::IncludeStatementContext* NaturalParser::SubroutineStatementContext::includeStatement() {
  return getRuleContext<NaturalParser::IncludeStatementContext>(0);
}

NaturalParser::FetchStatementContext* NaturalParser::SubroutineStatementContext::fetchStatement() {
  return getRuleContext<NaturalParser::FetchStatementContext>(0);
}

NaturalParser::CallStatementContext* NaturalParser::SubroutineStatementContext::callStatement() {
  return getRuleContext<NaturalParser::CallStatementContext>(0);
}

NaturalParser::OtherStatementContext* NaturalParser::SubroutineStatementContext::otherStatement() {
  return getRuleContext<NaturalParser::OtherStatementContext>(0);
}


size_t NaturalParser::SubroutineStatementContext::getRuleIndex() const {
  return NaturalParser::RuleSubroutineStatement;
}


std::any NaturalParser::SubroutineStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSubroutineStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SubroutineStatementContext* NaturalParser::subroutineStatement() {
  SubroutineStatementContext *_localctx = _tracker.createInstance<SubroutineStatementContext>(_ctx, getState());
  enterRule(_localctx, 172, NaturalParser::RuleSubroutineStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1759);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
    case 1: {
      setState(1720);
      dataDefinition();
      break;
    }

    case 2: {
      setState(1721);
      subroutine();
      break;
    }

    case 3: {
      setState(1722);
      functionDefinition();
      break;
    }

    case 4: {
      setState(1723);
      valueAssignment();
      break;
    }

    case 5: {
      setState(1724);
      forStatement();
      break;
    }

    case 6: {
      setState(1725);
      ifStatement();
      break;
    }

    case 7: {
      setState(1726);
      performStatement();
      break;
    }

    case 8: {
      setState(1727);
      callnatStatement();
      break;
    }

    case 9: {
      setState(1728);
      redefineStatement();
      break;
    }

    case 10: {
      setState(1729);
      resetStatement();
      break;
    }

    case 11: {
      setState(1730);
      examineStatement();
      break;
    }

    case 12: {
      setState(1731);
      moveStatement();
      break;
    }

    case 13: {
      setState(1732);
      findStatement();
      break;
    }

    case 14: {
      setState(1733);
      readStatement();
      break;
    }

    case 15: {
      setState(1734);
      storeStatement();
      break;
    }

    case 16: {
      setState(1735);
      updateStatement();
      break;
    }

    case 17: {
      setState(1736);
      deleteStatement();
      break;
    }

    case 18: {
      setState(1737);
      getStatements();
      break;
    }

    case 19: {
      setState(1738);
      histogramStatement();
      break;
    }

    case 20: {
      setState(1739);
      endTransaction();
      break;
    }

    case 21: {
      setState(1740);
      backoutTransaction();
      break;
    }

    case 22: {
      setState(1741);
      readworkfileStatement();
      break;
    }

    case 23: {
      setState(1742);
      writeworkfileStatement();
      break;
    }

    case 24: {
      setState(1743);
      closeworkfileStatement();
      break;
    }

    case 25: {
      setState(1744);
      inputStatement();
      break;
    }

    case 26: {
      setState(1745);
      reinputStatement();
      break;
    }

    case 27: {
      setState(1746);
      calculations();
      break;
    }

    case 28: {
      setState(1747);
      assignStatement();
      break;
    }

    case 29: {
      setState(1748);
      sortStatement();
      break;
    }

    case 30: {
      setState(1749);
      compressStatement();
      break;
    }

    case 31: {
      setState(1750);
      doStatement();
      break;
    }

    case 32: {
      setState(1751);
      repeatStatement();
      break;
    }

    case 33: {
      setState(1752);
      atStartOfDataStatement();
      break;
    }

    case 34: {
      setState(1753);
      formatStatement();
      break;
    }

    case 35: {
      setState(1754);
      assignmentStatement();
      break;
    }

    case 36: {
      setState(1755);
      includeStatement();
      break;
    }

    case 37: {
      setState(1756);
      fetchStatement();
      break;
    }

    case 38: {
      setState(1757);
      callStatement();
      break;
    }

    case 39: {
      setState(1758);
      otherStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

NaturalParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::FunctionDefinitionContext::DEFINE_FUNCTION() {
  return getToken(NaturalParser::DEFINE_FUNCTION, 0);
}

tree::TerminalNode* NaturalParser::FunctionDefinitionContext::RETURNS() {
  return getToken(NaturalParser::RETURNS, 0);
}

tree::TerminalNode* NaturalParser::FunctionDefinitionContext::END_FUNCTION() {
  return getToken(NaturalParser::END_FUNCTION, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::FunctionDefinitionContext::IDENTIFIER() {
  return getTokens(NaturalParser::IDENTIFIER);
}

tree::TerminalNode* NaturalParser::FunctionDefinitionContext::IDENTIFIER(size_t i) {
  return getToken(NaturalParser::IDENTIFIER, i);
}

NaturalParser::BlockContentContext* NaturalParser::FunctionDefinitionContext::blockContent() {
  return getRuleContext<NaturalParser::BlockContentContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::FunctionDefinitionContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::FunctionDefinitionContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}


size_t NaturalParser::FunctionDefinitionContext::getRuleIndex() const {
  return NaturalParser::RuleFunctionDefinition;
}


std::any NaturalParser::FunctionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitFunctionDefinition(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::FunctionDefinitionContext* NaturalParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 174, NaturalParser::RuleFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1761);
    match(NaturalParser::DEFINE_FUNCTION);
    setState(1763);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1762);
      match(NaturalParser::WS);
    }
    setState(1765);
    antlrcpp::downCast<FunctionDefinitionContext *>(_localctx)->functionName = match(NaturalParser::IDENTIFIER);
    setState(1767);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1766);
      match(NaturalParser::WS);
    }
    setState(1769);
    match(NaturalParser::RETURNS);
    setState(1771);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1770);
      match(NaturalParser::WS);
    }
    setState(1773);
    antlrcpp::downCast<FunctionDefinitionContext *>(_localctx)->returnType = match(NaturalParser::IDENTIFIER);
    setState(1775);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx)) {
    case 1: {
      setState(1774);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1777);
    antlrcpp::downCast<FunctionDefinitionContext *>(_localctx)->functionBody = blockContent();
    setState(1779);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1778);
      match(NaturalParser::WS);
    }
    setState(1781);
    match(NaturalParser::END_FUNCTION);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockContentContext ------------------------------------------------------------------

NaturalParser::BlockContentContext::BlockContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NaturalParser::StatementContext *> NaturalParser::BlockContentContext::statement() {
  return getRuleContexts<NaturalParser::StatementContext>();
}

NaturalParser::StatementContext* NaturalParser::BlockContentContext::statement(size_t i) {
  return getRuleContext<NaturalParser::StatementContext>(i);
}

std::vector<tree::TerminalNode *> NaturalParser::BlockContentContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::BlockContentContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::BlockContentContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::BlockContentContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::BlockContentContext::TRAILING_COMMENT() {
  return getToken(NaturalParser::TRAILING_COMMENT, 0);
}


size_t NaturalParser::BlockContentContext::getRuleIndex() const {
  return NaturalParser::RuleBlockContent;
}


std::any NaturalParser::BlockContentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitBlockContent(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::BlockContentContext* NaturalParser::blockContent() {
  BlockContentContext *_localctx = _tracker.createInstance<BlockContentContext>(_ctx, getState());
  enterRule(_localctx, 176, NaturalParser::RuleBlockContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1788);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1786);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, _ctx)) {
        case 1: {
          setState(1783);
          statement();
          break;
        }

        case 2: {
          setState(1784);
          match(NaturalParser::WS);
          break;
        }

        case 3: {
          setState(1785);
          match(NaturalParser::NL);
          break;
        }

        default:
          break;
        } 
      }
      setState(1790);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx);
    }
    setState(1792);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::TRAILING_COMMENT) {
      setState(1791);
      match(NaturalParser::TRAILING_COMMENT);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueAssignmentContext ------------------------------------------------------------------

NaturalParser::ValueAssignmentContext::ValueAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::VALUE() {
  return getToken(NaturalParser::VALUE, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ValueAssignmentContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ValueAssignmentContext::STRING() {
  return getTokens(NaturalParser::STRING);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::STRING(size_t i) {
  return getToken(NaturalParser::STRING, i);
}

std::vector<tree::TerminalNode *> NaturalParser::ValueAssignmentContext::COMMA() {
  return getTokens(NaturalParser::COMMA);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::COMMA(size_t i) {
  return getToken(NaturalParser::COMMA, i);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::ESCAPE_BOTTOM() {
  return getToken(NaturalParser::ESCAPE_BOTTOM, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::ValueAssignmentContext::NL() {
  return getTokens(NaturalParser::NL);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::NL(size_t i) {
  return getToken(NaturalParser::NL, i);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::NONE() {
  return getToken(NaturalParser::NONE, 0);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::COLON() {
  return getToken(NaturalParser::COLON, 0);
}

tree::TerminalNode* NaturalParser::ValueAssignmentContext::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

NaturalParser::ValueAssignmentContext* NaturalParser::ValueAssignmentContext::valueAssignment() {
  return getRuleContext<NaturalParser::ValueAssignmentContext>(0);
}


size_t NaturalParser::ValueAssignmentContext::getRuleIndex() const {
  return NaturalParser::RuleValueAssignment;
}


std::any NaturalParser::ValueAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitValueAssignment(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ValueAssignmentContext* NaturalParser::valueAssignment() {
  ValueAssignmentContext *_localctx = _tracker.createInstance<ValueAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 178, NaturalParser::RuleValueAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1794);
    match(NaturalParser::VALUE);
    setState(1796);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
    case 1: {
      setState(1795);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1799);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
    case 1: {
      setState(1798);
      match(NaturalParser::STRING);
      break;
    }

    default:
      break;
    }
    setState(1802);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
    case 1: {
      setState(1801);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1814);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1805);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(1804);
          match(NaturalParser::WS);
        }
        setState(1807);
        match(NaturalParser::COMMA);
        setState(1809);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == NaturalParser::WS) {
          setState(1808);
          match(NaturalParser::WS);
        }
        setState(1811);
        match(NaturalParser::STRING); 
      }
      setState(1816);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx);
    }
    setState(1818);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
    case 1: {
      setState(1817);
      match(NaturalParser::ESCAPE_BOTTOM);
      break;
    }

    default:
      break;
    }
    setState(1821);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(1820);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(1824);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(1823);
      match(NaturalParser::LINE_NUMBER);
      break;
    }

    default:
      break;
    }
    setState(1827);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      setState(1826);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      setState(1829);
      match(NaturalParser::NONE);
      break;
    }

    default:
      break;
    }
    setState(1833);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      setState(1832);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1836);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      setState(1835);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
    setState(1839);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx)) {
    case 1: {
      setState(1838);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1842);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      setState(1841);
      match(NaturalParser::IDENTIFIER);
      break;
    }

    default:
      break;
    }
    setState(1845);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
    case 1: {
      setState(1844);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1848);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
    case 1: {
      setState(1847);
      match(NaturalParser::COLON);
      break;
    }

    default:
      break;
    }
    setState(1851);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
    case 1: {
      setState(1850);
      match(NaturalParser::EQ);
      break;
    }

    default:
      break;
    }
    setState(1854);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      setState(1853);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1857);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
    case 1: {
      setState(1856);
      match(NaturalParser::STRING);
      break;
    }

    default:
      break;
    }
    setState(1860);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx)) {
    case 1: {
      setState(1859);
      valueAssignment();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignStatementContext ------------------------------------------------------------------

NaturalParser::AssignStatementContext::AssignStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::AssignStatementContext::ASSIGN() {
  return getToken(NaturalParser::ASSIGN, 0);
}

NaturalParser::VariableContext* NaturalParser::AssignStatementContext::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

tree::TerminalNode* NaturalParser::AssignStatementContext::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

std::vector<tree::TerminalNode *> NaturalParser::AssignStatementContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::AssignStatementContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::AssignStatementContext::ROUNDED() {
  return getToken(NaturalParser::ROUNDED, 0);
}

tree::TerminalNode* NaturalParser::AssignStatementContext::COLON() {
  return getToken(NaturalParser::COLON, 0);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::AssignStatementContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::AssignStatementContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}


size_t NaturalParser::AssignStatementContext::getRuleIndex() const {
  return NaturalParser::RuleAssignStatement;
}


std::any NaturalParser::AssignStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAssignStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AssignStatementContext* NaturalParser::assignStatement() {
  AssignStatementContext *_localctx = _tracker.createInstance<AssignStatementContext>(_ctx, getState());
  enterRule(_localctx, 180, NaturalParser::RuleAssignStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1862);
    match(NaturalParser::ASSIGN);
    setState(1864);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      setState(1863);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(1867);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::ROUNDED) {
      setState(1866);
      match(NaturalParser::ROUNDED);
    }
    setState(1870);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1869);
      match(NaturalParser::WS);
    }
    setState(1872);
    variable();
    setState(1874);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1873);
      match(NaturalParser::WS);
    }
    setState(1877);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::COLON) {
      setState(1876);
      match(NaturalParser::COLON);
    }
    setState(1879);
    match(NaturalParser::EQ);
    setState(1882); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1882);
              _errHandler->sync(this);
              switch (_input->LA(1)) {
                case NaturalParser::POSITION:
                case NaturalParser::STRING:
                case NaturalParser::LINE_NUMBER:
                case NaturalParser::FLOAT:
                case NaturalParser::INPUT_PARAM:
                case NaturalParser::DATE_CONSTANT:
                case NaturalParser::H_CONSTANT:
                case NaturalParser::LPAREN:
                case NaturalParser::IDENTIFIER: {
                  setState(1880);
                  operand();
                  break;
                }

                case NaturalParser::WS: {
                  setState(1881);
                  match(NaturalParser::WS);
                  break;
                }

              default:
                throw NoViableAltException(this);
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1884); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddOperationContext ------------------------------------------------------------------

NaturalParser::AddOperationContext::AddOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::AddOperationContext::ADD() {
  return getToken(NaturalParser::ADD, 0);
}

std::vector<NaturalParser::AddContentContext *> NaturalParser::AddOperationContext::addContent() {
  return getRuleContexts<NaturalParser::AddContentContext>();
}

NaturalParser::AddContentContext* NaturalParser::AddOperationContext::addContent(size_t i) {
  return getRuleContext<NaturalParser::AddContentContext>(i);
}

tree::TerminalNode* NaturalParser::AddOperationContext::NL() {
  return getToken(NaturalParser::NL, 0);
}


size_t NaturalParser::AddOperationContext::getRuleIndex() const {
  return NaturalParser::RuleAddOperation;
}


std::any NaturalParser::AddOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAddOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AddOperationContext* NaturalParser::addOperation() {
  AddOperationContext *_localctx = _tracker.createInstance<AddOperationContext>(_ctx, getState());
  enterRule(_localctx, 182, NaturalParser::RuleAddOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1886);
    match(NaturalParser::ADD);
    setState(1890);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1887);
        addContent(); 
      }
      setState(1892);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx);
    }
    setState(1894);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      setState(1893);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplyOperationContext ------------------------------------------------------------------

NaturalParser::MultiplyOperationContext::MultiplyOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::MultiplyOperationContext::MULTIPLY() {
  return getToken(NaturalParser::MULTIPLY, 0);
}

std::vector<NaturalParser::AddContentContext *> NaturalParser::MultiplyOperationContext::addContent() {
  return getRuleContexts<NaturalParser::AddContentContext>();
}

NaturalParser::AddContentContext* NaturalParser::MultiplyOperationContext::addContent(size_t i) {
  return getRuleContext<NaturalParser::AddContentContext>(i);
}

tree::TerminalNode* NaturalParser::MultiplyOperationContext::NL() {
  return getToken(NaturalParser::NL, 0);
}


size_t NaturalParser::MultiplyOperationContext::getRuleIndex() const {
  return NaturalParser::RuleMultiplyOperation;
}


std::any NaturalParser::MultiplyOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitMultiplyOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::MultiplyOperationContext* NaturalParser::multiplyOperation() {
  MultiplyOperationContext *_localctx = _tracker.createInstance<MultiplyOperationContext>(_ctx, getState());
  enterRule(_localctx, 184, NaturalParser::RuleMultiplyOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1896);
    match(NaturalParser::MULTIPLY);
    setState(1900);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1897);
        addContent(); 
      }
      setState(1902);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx);
    }
    setState(1904);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
    case 1: {
      setState(1903);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubtractOperationContext ------------------------------------------------------------------

NaturalParser::SubtractOperationContext::SubtractOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::SubtractOperationContext::SUBTRACT() {
  return getToken(NaturalParser::SUBTRACT, 0);
}

std::vector<NaturalParser::AddContentContext *> NaturalParser::SubtractOperationContext::addContent() {
  return getRuleContexts<NaturalParser::AddContentContext>();
}

NaturalParser::AddContentContext* NaturalParser::SubtractOperationContext::addContent(size_t i) {
  return getRuleContext<NaturalParser::AddContentContext>(i);
}

tree::TerminalNode* NaturalParser::SubtractOperationContext::NL() {
  return getToken(NaturalParser::NL, 0);
}


size_t NaturalParser::SubtractOperationContext::getRuleIndex() const {
  return NaturalParser::RuleSubtractOperation;
}


std::any NaturalParser::SubtractOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitSubtractOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::SubtractOperationContext* NaturalParser::subtractOperation() {
  SubtractOperationContext *_localctx = _tracker.createInstance<SubtractOperationContext>(_ctx, getState());
  enterRule(_localctx, 186, NaturalParser::RuleSubtractOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1906);
    match(NaturalParser::SUBTRACT);
    setState(1910);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1907);
        addContent(); 
      }
      setState(1912);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx);
    }
    setState(1914);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx)) {
    case 1: {
      setState(1913);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DivideOperationContext ------------------------------------------------------------------

NaturalParser::DivideOperationContext::DivideOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::DivideOperationContext::DIVIDE() {
  return getToken(NaturalParser::DIVIDE, 0);
}

std::vector<NaturalParser::AddContentContext *> NaturalParser::DivideOperationContext::addContent() {
  return getRuleContexts<NaturalParser::AddContentContext>();
}

NaturalParser::AddContentContext* NaturalParser::DivideOperationContext::addContent(size_t i) {
  return getRuleContext<NaturalParser::AddContentContext>(i);
}

tree::TerminalNode* NaturalParser::DivideOperationContext::NL() {
  return getToken(NaturalParser::NL, 0);
}


size_t NaturalParser::DivideOperationContext::getRuleIndex() const {
  return NaturalParser::RuleDivideOperation;
}


std::any NaturalParser::DivideOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitDivideOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::DivideOperationContext* NaturalParser::divideOperation() {
  DivideOperationContext *_localctx = _tracker.createInstance<DivideOperationContext>(_ctx, getState());
  enterRule(_localctx, 188, NaturalParser::RuleDivideOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1916);
    match(NaturalParser::DIVIDE);
    setState(1920);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1917);
        addContent(); 
      }
      setState(1922);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx);
    }
    setState(1924);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 327, _ctx)) {
    case 1: {
      setState(1923);
      match(NaturalParser::NL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComputeOperationContext ------------------------------------------------------------------

NaturalParser::ComputeOperationContext::ComputeOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ComputeOperationContext::COMPUTE() {
  return getToken(NaturalParser::COMPUTE, 0);
}

NaturalParser::VariableContext* NaturalParser::ComputeOperationContext::variable() {
  return getRuleContext<NaturalParser::VariableContext>(0);
}

tree::TerminalNode* NaturalParser::ComputeOperationContext::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::ComputeOperationContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::ComputeOperationContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

NaturalParser::ArithmaticOpContext* NaturalParser::ComputeOperationContext::arithmaticOp() {
  return getRuleContext<NaturalParser::ArithmaticOpContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::ComputeOperationContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ComputeOperationContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::ComputeOperationContext::ROUNDED() {
  return getToken(NaturalParser::ROUNDED, 0);
}

tree::TerminalNode* NaturalParser::ComputeOperationContext::COLON() {
  return getToken(NaturalParser::COLON, 0);
}

NaturalParser::OptionalComputeContext* NaturalParser::ComputeOperationContext::optionalCompute() {
  return getRuleContext<NaturalParser::OptionalComputeContext>(0);
}


size_t NaturalParser::ComputeOperationContext::getRuleIndex() const {
  return NaturalParser::RuleComputeOperation;
}


std::any NaturalParser::ComputeOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitComputeOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ComputeOperationContext* NaturalParser::computeOperation() {
  ComputeOperationContext *_localctx = _tracker.createInstance<ComputeOperationContext>(_ctx, getState());
  enterRule(_localctx, 190, NaturalParser::RuleComputeOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1985);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1926);
      match(NaturalParser::COMPUTE);
      setState(1928);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
      case 1: {
        setState(1927);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1931);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::ROUNDED) {
        setState(1930);
        match(NaturalParser::ROUNDED);
      }
      setState(1934);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1933);
        match(NaturalParser::WS);
      }
      setState(1936);
      variable();
      setState(1938);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1937);
        match(NaturalParser::WS);
      }
      setState(1941);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::COLON) {
        setState(1940);
        match(NaturalParser::COLON);
      }
      setState(1943);
      match(NaturalParser::EQ);
      setState(1945);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1944);
        match(NaturalParser::WS);
      }
      setState(1947);
      operand();
      setState(1949);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1948);
        match(NaturalParser::WS);
      }
      setState(1951);
      arithmaticOp();
      setState(1953);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1952);
        match(NaturalParser::WS);
      }
      setState(1955);
      operand();
      setState(1957);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
      case 1: {
        setState(1956);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1960);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
      case 1: {
        setState(1959);
        optionalCompute();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1962);
      match(NaturalParser::COMPUTE);
      setState(1964);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
      case 1: {
        setState(1963);
        match(NaturalParser::WS);
        break;
      }

      default:
        break;
      }
      setState(1967);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::ROUNDED) {
        setState(1966);
        match(NaturalParser::ROUNDED);
      }
      setState(1970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1969);
        match(NaturalParser::WS);
      }
      setState(1972);
      variable();
      setState(1974);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1973);
        match(NaturalParser::WS);
      }
      setState(1977);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::COLON) {
        setState(1976);
        match(NaturalParser::COLON);
      }
      setState(1979);
      match(NaturalParser::EQ);
      setState(1981);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == NaturalParser::WS) {
        setState(1980);
        match(NaturalParser::WS);
      }
      setState(1983);
      operand();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArithmaticOperationContext ------------------------------------------------------------------

NaturalParser::ArithmaticOperationContext::ArithmaticOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ArithmaticOperationContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::ArithmaticOperationContext::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

std::vector<NaturalParser::OperandContext *> NaturalParser::ArithmaticOperationContext::operand() {
  return getRuleContexts<NaturalParser::OperandContext>();
}

NaturalParser::OperandContext* NaturalParser::ArithmaticOperationContext::operand(size_t i) {
  return getRuleContext<NaturalParser::OperandContext>(i);
}

NaturalParser::ArithmaticOpContext* NaturalParser::ArithmaticOperationContext::arithmaticOp() {
  return getRuleContext<NaturalParser::ArithmaticOpContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::ArithmaticOperationContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::ArithmaticOperationContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

tree::TerminalNode* NaturalParser::ArithmaticOperationContext::COLON() {
  return getToken(NaturalParser::COLON, 0);
}

NaturalParser::OptionalComputeContext* NaturalParser::ArithmaticOperationContext::optionalCompute() {
  return getRuleContext<NaturalParser::OptionalComputeContext>(0);
}


size_t NaturalParser::ArithmaticOperationContext::getRuleIndex() const {
  return NaturalParser::RuleArithmaticOperation;
}


std::any NaturalParser::ArithmaticOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitArithmaticOperation(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ArithmaticOperationContext* NaturalParser::arithmaticOperation() {
  ArithmaticOperationContext *_localctx = _tracker.createInstance<ArithmaticOperationContext>(_ctx, getState());
  enterRule(_localctx, 192, NaturalParser::RuleArithmaticOperation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1987);
    match(NaturalParser::IDENTIFIER);
    setState(1989);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1988);
      match(NaturalParser::WS);
    }
    setState(1992);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::COLON) {
      setState(1991);
      match(NaturalParser::COLON);
    }
    setState(1994);
    match(NaturalParser::EQ);
    setState(1996);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1995);
      match(NaturalParser::WS);
    }
    setState(1998);
    operand();
    setState(2000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(1999);
      match(NaturalParser::WS);
    }
    setState(2002);
    arithmaticOp();
    setState(2004);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(2003);
      match(NaturalParser::WS);
    }
    setState(2006);
    operand();
    setState(2008);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx)) {
    case 1: {
      setState(2007);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2011);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 351, _ctx)) {
    case 1: {
      setState(2010);
      optionalCompute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalComputeContext ------------------------------------------------------------------

NaturalParser::OptionalComputeContext::OptionalComputeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::ArithmaticOpContext* NaturalParser::OptionalComputeContext::arithmaticOp() {
  return getRuleContext<NaturalParser::ArithmaticOpContext>(0);
}

NaturalParser::OperandContext* NaturalParser::OptionalComputeContext::operand() {
  return getRuleContext<NaturalParser::OperandContext>(0);
}

std::vector<tree::TerminalNode *> NaturalParser::OptionalComputeContext::WS() {
  return getTokens(NaturalParser::WS);
}

tree::TerminalNode* NaturalParser::OptionalComputeContext::WS(size_t i) {
  return getToken(NaturalParser::WS, i);
}

NaturalParser::OptionalComputeContext* NaturalParser::OptionalComputeContext::optionalCompute() {
  return getRuleContext<NaturalParser::OptionalComputeContext>(0);
}


size_t NaturalParser::OptionalComputeContext::getRuleIndex() const {
  return NaturalParser::RuleOptionalCompute;
}


std::any NaturalParser::OptionalComputeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitOptionalCompute(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::OptionalComputeContext* NaturalParser::optionalCompute() {
  OptionalComputeContext *_localctx = _tracker.createInstance<OptionalComputeContext>(_ctx, getState());
  enterRule(_localctx, 194, NaturalParser::RuleOptionalCompute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2013);
    arithmaticOp();
    setState(2015);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NaturalParser::WS) {
      setState(2014);
      match(NaturalParser::WS);
    }
    setState(2017);
    operand();
    setState(2019);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
    case 1: {
      setState(2018);
      match(NaturalParser::WS);
      break;
    }

    default:
      break;
    }
    setState(2022);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      setState(2021);
      optionalCompute();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CalculationsContext ------------------------------------------------------------------

NaturalParser::CalculationsContext::CalculationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NaturalParser::AddOperationContext* NaturalParser::CalculationsContext::addOperation() {
  return getRuleContext<NaturalParser::AddOperationContext>(0);
}

NaturalParser::SubtractOperationContext* NaturalParser::CalculationsContext::subtractOperation() {
  return getRuleContext<NaturalParser::SubtractOperationContext>(0);
}

NaturalParser::MultiplyOperationContext* NaturalParser::CalculationsContext::multiplyOperation() {
  return getRuleContext<NaturalParser::MultiplyOperationContext>(0);
}

NaturalParser::DivideOperationContext* NaturalParser::CalculationsContext::divideOperation() {
  return getRuleContext<NaturalParser::DivideOperationContext>(0);
}

NaturalParser::ComputeOperationContext* NaturalParser::CalculationsContext::computeOperation() {
  return getRuleContext<NaturalParser::ComputeOperationContext>(0);
}

NaturalParser::ArithmaticOperationContext* NaturalParser::CalculationsContext::arithmaticOperation() {
  return getRuleContext<NaturalParser::ArithmaticOperationContext>(0);
}


size_t NaturalParser::CalculationsContext::getRuleIndex() const {
  return NaturalParser::RuleCalculations;
}


std::any NaturalParser::CalculationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCalculations(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CalculationsContext* NaturalParser::calculations() {
  CalculationsContext *_localctx = _tracker.createInstance<CalculationsContext>(_ctx, getState());
  enterRule(_localctx, 196, NaturalParser::RuleCalculations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2030);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NaturalParser::ADD: {
        enterOuterAlt(_localctx, 1);
        setState(2024);
        addOperation();
        break;
      }

      case NaturalParser::SUBTRACT: {
        enterOuterAlt(_localctx, 2);
        setState(2025);
        subtractOperation();
        break;
      }

      case NaturalParser::MULTIPLY: {
        enterOuterAlt(_localctx, 3);
        setState(2026);
        multiplyOperation();
        break;
      }

      case NaturalParser::DIVIDE: {
        enterOuterAlt(_localctx, 4);
        setState(2027);
        divideOperation();
        break;
      }

      case NaturalParser::COMPUTE: {
        enterOuterAlt(_localctx, 5);
        setState(2028);
        computeOperation();
        break;
      }

      case NaturalParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 6);
        setState(2029);
        arithmaticOperation();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AddContentContext ------------------------------------------------------------------

NaturalParser::AddContentContext::AddContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::AddContentContext::IDENTIFIER() {
  return getToken(NaturalParser::IDENTIFIER, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::LITERAL() {
  return getToken(NaturalParser::LITERAL, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::FLOAT() {
  return getToken(NaturalParser::FLOAT, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::LINE_NUMBER() {
  return getToken(NaturalParser::LINE_NUMBER, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::TO() {
  return getToken(NaturalParser::TO, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::GIVING() {
  return getToken(NaturalParser::GIVING, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::ROUNDED() {
  return getToken(NaturalParser::ROUNDED, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::WS() {
  return getToken(NaturalParser::WS, 0);
}

tree::TerminalNode* NaturalParser::AddContentContext::STRING() {
  return getToken(NaturalParser::STRING, 0);
}


size_t NaturalParser::AddContentContext::getRuleIndex() const {
  return NaturalParser::RuleAddContent;
}


std::any NaturalParser::AddContentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitAddContent(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::AddContentContext* NaturalParser::addContent() {
  AddContentContext *_localctx = _tracker.createInstance<AddContentContext>(_ctx, getState());
  enterRule(_localctx, 198, NaturalParser::RuleAddContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2032);
    _la = _input->LA(1);
    if (!(_la == NaturalParser::TO || _la == NaturalParser::GIVING

    || _la == NaturalParser::ROUNDED || ((((_la - 272) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 272)) & 10485789) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompOpContext ------------------------------------------------------------------

NaturalParser::CompOpContext::CompOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::CompOpContext::GT_TEXT() {
  return getToken(NaturalParser::GT_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::LT_TEXT() {
  return getToken(NaturalParser::LT_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::GE_TEXT() {
  return getToken(NaturalParser::GE_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::LE_TEXT() {
  return getToken(NaturalParser::LE_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::EQ_TEXT() {
  return getToken(NaturalParser::EQ_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::NE_TEXT() {
  return getToken(NaturalParser::NE_TEXT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::GT() {
  return getToken(NaturalParser::GT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::LT() {
  return getToken(NaturalParser::LT, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::GE() {
  return getToken(NaturalParser::GE, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::LE() {
  return getToken(NaturalParser::LE, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::EQ() {
  return getToken(NaturalParser::EQ, 0);
}

tree::TerminalNode* NaturalParser::CompOpContext::NE() {
  return getToken(NaturalParser::NE, 0);
}


size_t NaturalParser::CompOpContext::getRuleIndex() const {
  return NaturalParser::RuleCompOp;
}


std::any NaturalParser::CompOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitCompOp(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::CompOpContext* NaturalParser::compOp() {
  CompOpContext *_localctx = _tracker.createInstance<CompOpContext>(_ctx, getState());
  enterRule(_localctx, 200, NaturalParser::RuleCompOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2034);
    _la = _input->LA(1);
    if (!(((((_la - 253) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 253)) & 270582939711) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArithmaticOpContext ------------------------------------------------------------------

NaturalParser::ArithmaticOpContext::ArithmaticOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::ArithmaticOpContext::PLUS() {
  return getToken(NaturalParser::PLUS, 0);
}

tree::TerminalNode* NaturalParser::ArithmaticOpContext::MINUS() {
  return getToken(NaturalParser::MINUS, 0);
}

tree::TerminalNode* NaturalParser::ArithmaticOpContext::MULT() {
  return getToken(NaturalParser::MULT, 0);
}

tree::TerminalNode* NaturalParser::ArithmaticOpContext::DIV() {
  return getToken(NaturalParser::DIV, 0);
}


size_t NaturalParser::ArithmaticOpContext::getRuleIndex() const {
  return NaturalParser::RuleArithmaticOp;
}


std::any NaturalParser::ArithmaticOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitArithmaticOp(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::ArithmaticOpContext* NaturalParser::arithmaticOp() {
  ArithmaticOpContext *_localctx = _tracker.createInstance<ArithmaticOpContext>(_ctx, getState());
  enterRule(_localctx, 202, NaturalParser::RuleArithmaticOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2036);
    _la = _input->LA(1);
    if (!(((((_la - 281) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 281)) & 15) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EndStatementContext ------------------------------------------------------------------

NaturalParser::EndStatementContext::EndStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NaturalParser::EndStatementContext::READ() {
  return getToken(NaturalParser::READ, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::FIND() {
  return getToken(NaturalParser::FIND, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::HISTOGRAM() {
  return getToken(NaturalParser::HISTOGRAM, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::GET() {
  return getToken(NaturalParser::GET, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::GET_SAME() {
  return getToken(NaturalParser::GET_SAME, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PASSW() {
  return getToken(NaturalParser::PASSW, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::LIMIT() {
  return getToken(NaturalParser::LIMIT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::STORE() {
  return getToken(NaturalParser::STORE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::UPDATE() {
  return getToken(NaturalParser::UPDATE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DELETE() {
  return getToken(NaturalParser::DELETE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::END_TRANSACTION() {
  return getToken(NaturalParser::END_TRANSACTION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::BACKOUT_TRANSACTION() {
  return getToken(NaturalParser::BACKOUT_TRANSACTION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::GET_TRANSACTION_DATA() {
  return getToken(NaturalParser::GET_TRANSACTION_DATA, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::RETRY() {
  return getToken(NaturalParser::RETRY, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::AT_START_OF_DATA() {
  return getToken(NaturalParser::AT_START_OF_DATA, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::AT_END_OF_DATA() {
  return getToken(NaturalParser::AT_END_OF_DATA, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::AT_BREAK() {
  return getToken(NaturalParser::AT_BREAK, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::BEFORE_BREAK_PROCESSING() {
  return getToken(NaturalParser::BEFORE_BREAK_PROCESSING, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PERFORM_BREAK_PROCESSING() {
  return getToken(NaturalParser::PERFORM_BREAK_PROCESSING, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CALLDBPROC() {
  return getToken(NaturalParser::CALLDBPROC, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::COMMIT() {
  return getToken(NaturalParser::COMMIT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::INSERT() {
  return getToken(NaturalParser::INSERT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_SQL() {
  return getToken(NaturalParser::PROCESS_SQL, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::READ_RESULT_SET() {
  return getToken(NaturalParser::READ_RESULT_SET, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::ROLLBACK() {
  return getToken(NaturalParser::ROLLBACK, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SELECT() {
  return getToken(NaturalParser::SELECT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::COMPUTE() {
  return getToken(NaturalParser::COMPUTE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::ADD() {
  return getToken(NaturalParser::ADD, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SUBTRACT() {
  return getToken(NaturalParser::SUBTRACT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::MULTIPLY() {
  return getToken(NaturalParser::MULTIPLY, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DIVIDE() {
  return getToken(NaturalParser::DIVIDE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::MOVE() {
  return getToken(NaturalParser::MOVE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::COMPRESS() {
  return getToken(NaturalParser::COMPRESS, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SEPARATE() {
  return getToken(NaturalParser::SEPARATE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::EXAMINE() {
  return getToken(NaturalParser::EXAMINE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::RESET() {
  return getToken(NaturalParser::RESET, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::ESCAPE() {
  return getToken(NaturalParser::ESCAPE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::FOR() {
  return getToken(NaturalParser::FOR, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::REPEAT() {
  return getToken(NaturalParser::REPEAT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SORT() {
  return getToken(NaturalParser::SORT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::FORMAT() {
  return getToken(NaturalParser::FORMAT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DISPLAY() {
  return getToken(NaturalParser::DISPLAY, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::WRITE() {
  return getToken(NaturalParser::WRITE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::WRITE_TITLE() {
  return getToken(NaturalParser::WRITE_TITLE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::WRITE_TRAILER() {
  return getToken(NaturalParser::WRITE_TRAILER, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::AT_TOP_OF_PAGE() {
  return getToken(NaturalParser::AT_TOP_OF_PAGE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::AT_END_OF_PAGE() {
  return getToken(NaturalParser::AT_END_OF_PAGE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::EJECT() {
  return getToken(NaturalParser::EJECT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::NEWPAGE() {
  return getToken(NaturalParser::NEWPAGE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SUSPEND_IDENTICAL_SUPPRESS() {
  return getToken(NaturalParser::SUSPEND_IDENTICAL_SUPPRESS, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_PRINTER() {
  return getToken(NaturalParser::DEFINE_PRINTER, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CLOSE_PRINTER() {
  return getToken(NaturalParser::CLOSE_PRINTER, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::INPUT() {
  return getToken(NaturalParser::INPUT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::REINPUT() {
  return getToken(NaturalParser::REINPUT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_WINDOW() {
  return getToken(NaturalParser::DEFINE_WINDOW, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SET_WINDOW() {
  return getToken(NaturalParser::SET_WINDOW, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_PAGE() {
  return getToken(NaturalParser::PROCESS_PAGE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_PAGE_USING() {
  return getToken(NaturalParser::PROCESS_PAGE_USING, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_PAGE_UPDATE() {
  return getToken(NaturalParser::PROCESS_PAGE_UPDATE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_PAGE_MODAL() {
  return getToken(NaturalParser::PROCESS_PAGE_MODAL, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::IF() {
  return getToken(NaturalParser::IF, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::IF_SELECTION() {
  return getToken(NaturalParser::IF_SELECTION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DECIDE_FOR() {
  return getToken(NaturalParser::DECIDE_FOR, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DECIDE_ON() {
  return getToken(NaturalParser::DECIDE_ON, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CALL() {
  return getToken(NaturalParser::CALL, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CALLNAT() {
  return getToken(NaturalParser::CALLNAT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CALL_FILE() {
  return getToken(NaturalParser::CALL_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CALL_LOOP() {
  return getToken(NaturalParser::CALL_LOOP, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_SUBROUTINE() {
  return getToken(NaturalParser::DEFINE_SUBROUTINE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::FETCH() {
  return getToken(NaturalParser::FETCH, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PERFORM() {
  return getToken(NaturalParser::PERFORM, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROCESS_COMMAND() {
  return getToken(NaturalParser::PROCESS_COMMAND, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::RUN() {
  return getToken(NaturalParser::RUN, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_FUNCTION() {
  return getToken(NaturalParser::DEFINE_FUNCTION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_PROTOTYPE() {
  return getToken(NaturalParser::DEFINE_PROTOTYPE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::FUNCTION_CALL() {
  return getToken(NaturalParser::FUNCTION_CALL, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::STOP() {
  return getToken(NaturalParser::STOP, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::TERMINATE() {
  return getToken(NaturalParser::TERMINATE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::WRITE_WORK_FILE() {
  return getToken(NaturalParser::WRITE_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DOWNLOAD_PC_FILE() {
  return getToken(NaturalParser::DOWNLOAD_PC_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::READ_WORK_FILE() {
  return getToken(NaturalParser::READ_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::UPLOAD_PC_FILE() {
  return getToken(NaturalParser::UPLOAD_PC_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CLOSE_WORK_FILE() {
  return getToken(NaturalParser::CLOSE_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CLOSE_PC_FILE() {
  return getToken(NaturalParser::CLOSE_PC_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_WORK_FILE() {
  return getToken(NaturalParser::DEFINE_WORK_FILE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_CLASS() {
  return getToken(NaturalParser::DEFINE_CLASS, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CREATE_OBJECT() {
  return getToken(NaturalParser::CREATE_OBJECT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SEND_METHOD() {
  return getToken(NaturalParser::SEND_METHOD, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::INTERFACE() {
  return getToken(NaturalParser::INTERFACE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::METHOD() {
  return getToken(NaturalParser::METHOD, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PROPERTY() {
  return getToken(NaturalParser::PROPERTY, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::EXPAND() {
  return getToken(NaturalParser::EXPAND, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::REDUCE() {
  return getToken(NaturalParser::REDUCE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::RESIZE() {
  return getToken(NaturalParser::RESIZE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::OPEN_CONVERSATION() {
  return getToken(NaturalParser::OPEN_CONVERSATION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::CLOSE_CONVERSATION() {
  return getToken(NaturalParser::CLOSE_CONVERSATION, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_DATA_CONTEXT() {
  return getToken(NaturalParser::DEFINE_DATA_CONTEXT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::PARSE() {
  return getToken(NaturalParser::PARSE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::REQUEST_DOCUMENT() {
  return getToken(NaturalParser::REQUEST_DOCUMENT, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DEFINE_DATA() {
  return getToken(NaturalParser::DEFINE_DATA, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::END() {
  return getToken(NaturalParser::END, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::INCLUDE() {
  return getToken(NaturalParser::INCLUDE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::ON_ERROR() {
  return getToken(NaturalParser::ON_ERROR, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::RELEASE() {
  return getToken(NaturalParser::RELEASE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SET_CONTROL() {
  return getToken(NaturalParser::SET_CONTROL, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SET_KEY() {
  return getToken(NaturalParser::SET_KEY, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SET_GLOBALS() {
  return getToken(NaturalParser::SET_GLOBALS, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::SET_TIME() {
  return getToken(NaturalParser::SET_TIME, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::STACK() {
  return getToken(NaturalParser::STACK, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::LOOP() {
  return getToken(NaturalParser::LOOP, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DO() {
  return getToken(NaturalParser::DO, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::DOEND() {
  return getToken(NaturalParser::DOEND, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::OBTAIN() {
  return getToken(NaturalParser::OBTAIN, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::REDEFINE() {
  return getToken(NaturalParser::REDEFINE, 0);
}

tree::TerminalNode* NaturalParser::EndStatementContext::END_START() {
  return getToken(NaturalParser::END_START, 0);
}


size_t NaturalParser::EndStatementContext::getRuleIndex() const {
  return NaturalParser::RuleEndStatement;
}


std::any NaturalParser::EndStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitEndStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::EndStatementContext* NaturalParser::endStatement() {
  EndStatementContext *_localctx = _tracker.createInstance<EndStatementContext>(_ctx, getState());
  enterRule(_localctx, 204, NaturalParser::RuleEndStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2038);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 3498452474803539712) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 6919640090553618905) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & -2305843019011588099) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & 33585661) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherStatementContext ------------------------------------------------------------------

NaturalParser::OtherStatementContext::OtherStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::IF() {
  return getTokens(NaturalParser::IF);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::IF(size_t i) {
  return getToken(NaturalParser::IF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::ELSE() {
  return getTokens(NaturalParser::ELSE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::ELSE(size_t i) {
  return getToken(NaturalParser::ELSE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DECIDE_FOR() {
  return getTokens(NaturalParser::DECIDE_FOR);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DECIDE_FOR(size_t i) {
  return getToken(NaturalParser::DECIDE_FOR, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DECIDE_ON() {
  return getTokens(NaturalParser::DECIDE_ON);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DECIDE_ON(size_t i) {
  return getToken(NaturalParser::DECIDE_ON, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DEFINE_SUBROUTINE() {
  return getTokens(NaturalParser::DEFINE_SUBROUTINE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DEFINE_SUBROUTINE(size_t i) {
  return getToken(NaturalParser::DEFINE_SUBROUTINE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DEFINE_FUNCTION() {
  return getTokens(NaturalParser::DEFINE_FUNCTION);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DEFINE_FUNCTION(size_t i) {
  return getToken(NaturalParser::DEFINE_FUNCTION, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::RETURN() {
  return getTokens(NaturalParser::RETURN);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::RETURN(size_t i) {
  return getToken(NaturalParser::RETURN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::VALUE() {
  return getTokens(NaturalParser::VALUE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::VALUE(size_t i) {
  return getToken(NaturalParser::VALUE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::CALLNAT() {
  return getTokens(NaturalParser::CALLNAT);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::CALLNAT(size_t i) {
  return getToken(NaturalParser::CALLNAT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::PERFORM() {
  return getTokens(NaturalParser::PERFORM);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::PERFORM(size_t i) {
  return getToken(NaturalParser::PERFORM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::FIND() {
  return getTokens(NaturalParser::FIND);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::FIND(size_t i) {
  return getToken(NaturalParser::FIND, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::STORE() {
  return getTokens(NaturalParser::STORE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::STORE(size_t i) {
  return getToken(NaturalParser::STORE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::INPUT() {
  return getTokens(NaturalParser::INPUT);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::INPUT(size_t i) {
  return getToken(NaturalParser::INPUT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::REINPUT() {
  return getTokens(NaturalParser::REINPUT);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::REINPUT(size_t i) {
  return getToken(NaturalParser::REINPUT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DOEND() {
  return getTokens(NaturalParser::DOEND);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DOEND(size_t i) {
  return getToken(NaturalParser::DOEND, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::END_IF() {
  return getTokens(NaturalParser::END_IF);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::END_IF(size_t i) {
  return getToken(NaturalParser::END_IF, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::END_FOR() {
  return getTokens(NaturalParser::END_FOR);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::END_FOR(size_t i) {
  return getToken(NaturalParser::END_FOR, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::LOOP() {
  return getTokens(NaturalParser::LOOP);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::LOOP(size_t i) {
  return getToken(NaturalParser::LOOP, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::DO() {
  return getTokens(NaturalParser::DO);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::DO(size_t i) {
  return getToken(NaturalParser::DO, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::THEN() {
  return getTokens(NaturalParser::THEN);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::THEN(size_t i) {
  return getToken(NaturalParser::THEN, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::RESET() {
  return getTokens(NaturalParser::RESET);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::RESET(size_t i) {
  return getToken(NaturalParser::RESET, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::REDEFINE() {
  return getTokens(NaturalParser::REDEFINE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::REDEFINE(size_t i) {
  return getToken(NaturalParser::REDEFINE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::GET() {
  return getTokens(NaturalParser::GET);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::GET(size_t i) {
  return getToken(NaturalParser::GET, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::UPDATE() {
  return getTokens(NaturalParser::UPDATE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::UPDATE(size_t i) {
  return getToken(NaturalParser::UPDATE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::READ() {
  return getTokens(NaturalParser::READ);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::READ(size_t i) {
  return getToken(NaturalParser::READ, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::MOVE() {
  return getTokens(NaturalParser::MOVE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::MOVE(size_t i) {
  return getToken(NaturalParser::MOVE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::AT_START_OF_DATA() {
  return getTokens(NaturalParser::AT_START_OF_DATA);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::AT_START_OF_DATA(size_t i) {
  return getToken(NaturalParser::AT_START_OF_DATA, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::FORMAT() {
  return getTokens(NaturalParser::FORMAT);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::FORMAT(size_t i) {
  return getToken(NaturalParser::FORMAT, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::INCLUDE() {
  return getTokens(NaturalParser::INCLUDE);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::INCLUDE(size_t i) {
  return getToken(NaturalParser::INCLUDE, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::HISTOGRAM() {
  return getTokens(NaturalParser::HISTOGRAM);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::HISTOGRAM(size_t i) {
  return getToken(NaturalParser::HISTOGRAM, i);
}

std::vector<tree::TerminalNode *> NaturalParser::OtherStatementContext::END_HISTOGRAM() {
  return getTokens(NaturalParser::END_HISTOGRAM);
}

tree::TerminalNode* NaturalParser::OtherStatementContext::END_HISTOGRAM(size_t i) {
  return getToken(NaturalParser::END_HISTOGRAM, i);
}


size_t NaturalParser::OtherStatementContext::getRuleIndex() const {
  return NaturalParser::RuleOtherStatement;
}


std::any NaturalParser::OtherStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<NaturalParserVisitor*>(visitor))
    return parserVisitor->visitOtherStatement(this);
  else
    return visitor->visitChildren(this);
}

NaturalParser::OtherStatementContext* NaturalParser::otherStatement() {
  OtherStatementContext *_localctx = _tracker.createInstance<OtherStatementContext>(_ctx, getState());
  enterRule(_localctx, 206, NaturalParser::RuleOtherStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2041); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(2040);
              _la = _input->LA(1);
              if (_la == 0 || _la == Token::EOF || ((((_la & ~ 0x3fULL) == 0) &&
                ((1ULL << _la) & -9183821663005448448) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 64)) & 4177) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 128)) & 2251799813734401) != 0) || ((((_la - 194) & ~ 0x3fULL) == 0) &&
                ((1ULL << (_la - 194)) & 12289) != 0))) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2043); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void NaturalParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  naturalparserParserInitialize();
#else
  ::antlr4::internal::call_once(naturalparserParserOnceFlag, naturalparserParserInitialize);
#endif
}
