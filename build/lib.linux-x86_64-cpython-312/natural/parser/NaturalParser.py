# Generated from NaturalParser.g4 by ANTLR 4.11.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,303,1805,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,1,0,1,0,1,0,1,0,4,0,197,
        8,0,11,0,12,0,198,1,1,1,1,3,1,203,8,1,1,1,1,1,1,2,3,2,208,8,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,252,8,2,1,3,1,3,1,4,1,
        4,4,4,258,8,4,11,4,12,4,259,1,4,1,4,1,5,1,5,5,5,266,8,5,10,5,12,
        5,269,9,5,1,5,1,5,1,5,4,5,274,8,5,11,5,12,5,275,1,5,1,5,5,5,280,
        8,5,10,5,12,5,283,9,5,1,5,1,5,5,5,287,8,5,10,5,12,5,290,9,5,1,5,
        3,5,293,8,5,1,6,1,6,1,6,1,6,3,6,299,8,6,1,6,3,6,302,8,6,1,6,1,6,
        3,6,306,8,6,1,6,3,6,309,8,6,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
        1,7,1,7,4,7,322,8,7,11,7,12,7,323,1,7,3,7,327,8,7,1,8,1,8,1,9,5,
        9,332,8,9,10,9,12,9,335,9,9,1,9,3,9,338,8,9,1,9,3,9,341,8,9,1,9,
        1,9,3,9,345,8,9,1,9,1,9,1,10,1,10,3,10,351,8,10,1,10,3,10,354,8,
        10,1,10,1,10,1,10,3,10,359,8,10,1,11,1,11,1,11,3,11,364,8,11,1,11,
        1,11,3,11,368,8,11,1,11,1,11,1,11,5,11,373,8,11,10,11,12,11,376,
        9,11,1,11,1,11,3,11,380,8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,
        1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,396,8,12,1,13,1,13,5,13,
        400,8,13,10,13,12,13,403,9,13,1,13,1,13,1,14,1,14,1,14,1,14,1,14,
        1,14,1,14,1,14,4,14,415,8,14,11,14,12,14,416,1,14,1,14,1,15,1,15,
        1,16,1,16,3,16,425,8,16,1,16,1,16,1,16,4,16,430,8,16,11,16,12,16,
        431,1,16,3,16,435,8,16,1,16,1,16,1,16,4,16,440,8,16,11,16,12,16,
        441,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
        1,17,1,17,1,17,1,17,1,17,3,17,461,8,17,1,18,1,18,5,18,465,8,18,10,
        18,12,18,468,9,18,1,18,1,18,1,19,1,19,5,19,474,8,19,10,19,12,19,
        477,9,19,1,19,1,19,1,20,1,20,3,20,483,8,20,1,20,1,20,3,20,487,8,
        20,1,20,3,20,490,8,20,1,20,3,20,493,8,20,1,20,3,20,496,8,20,1,20,
        5,20,499,8,20,10,20,12,20,502,9,20,1,20,1,20,3,20,506,8,20,1,20,
        1,20,3,20,510,8,20,1,20,3,20,513,8,20,1,20,3,20,516,8,20,1,20,1,
        20,3,20,520,8,20,1,20,3,20,523,8,20,1,20,3,20,526,8,20,1,20,3,20,
        529,8,20,1,20,5,20,532,8,20,10,20,12,20,535,9,20,3,20,537,8,20,1,
        21,1,21,3,21,541,8,21,1,21,1,21,3,21,545,8,21,1,21,3,21,548,8,21,
        1,21,1,21,3,21,552,8,21,1,21,1,21,5,21,556,8,21,10,21,12,21,559,
        9,21,1,21,1,21,1,22,1,22,3,22,565,8,22,1,22,1,22,3,22,569,8,22,1,
        22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,3,22,581,8,22,1,
        22,1,22,3,22,585,8,22,1,23,1,23,1,23,1,23,1,23,1,23,3,23,593,8,23,
        1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
        1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,1,24,
        5,24,621,8,24,10,24,12,24,624,9,24,1,25,1,25,3,25,628,8,25,1,25,
        1,25,3,25,632,8,25,1,25,1,25,1,25,1,26,1,26,4,26,639,8,26,11,26,
        12,26,640,1,26,3,26,644,8,26,1,26,1,26,1,26,1,26,1,26,3,26,651,8,
        26,1,26,3,26,654,8,26,1,26,1,26,3,26,658,8,26,1,26,1,26,1,26,4,26,
        663,8,26,11,26,12,26,664,1,26,3,26,668,8,26,1,26,1,26,1,26,1,26,
        1,26,1,26,1,26,1,26,1,26,1,26,3,26,680,8,26,1,26,1,26,1,26,1,26,
        3,26,686,8,26,1,26,1,26,3,26,690,8,26,1,27,1,27,3,27,694,8,27,1,
        27,3,27,697,8,27,1,27,3,27,700,8,27,1,27,3,27,703,8,27,1,27,3,27,
        706,8,27,1,27,3,27,709,8,27,1,27,3,27,712,8,27,1,27,3,27,715,8,27,
        1,28,1,28,3,28,719,8,28,1,28,3,28,722,8,28,1,29,1,29,1,29,3,29,727,
        8,29,1,30,1,30,1,30,1,30,1,30,5,30,734,8,30,10,30,12,30,737,9,30,
        1,30,1,30,3,30,741,8,30,1,30,1,30,1,31,1,31,1,32,1,32,4,32,749,8,
        32,11,32,12,32,750,1,32,1,32,1,33,1,33,3,33,757,8,33,1,33,3,33,760,
        8,33,1,33,5,33,763,8,33,10,33,12,33,766,9,33,1,33,1,33,1,34,1,34,
        1,34,5,34,773,8,34,10,34,12,34,776,9,34,1,34,1,34,1,35,1,35,1,35,
        1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,
        1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,5,35,
        808,8,35,10,35,12,35,811,9,35,1,35,1,35,1,36,1,36,1,37,1,37,1,38,
        1,38,1,38,1,38,3,38,823,8,38,1,38,3,38,826,8,38,1,38,1,38,1,38,1,
        38,1,38,1,38,1,38,3,38,835,8,38,1,38,3,38,838,8,38,1,38,1,38,4,38,
        842,8,38,11,38,12,38,843,1,38,1,38,1,38,1,38,1,38,1,38,3,38,852,
        8,38,1,38,3,38,855,8,38,1,38,1,38,4,38,859,8,38,11,38,12,38,860,
        1,38,1,38,3,38,865,8,38,1,39,1,39,1,40,1,40,1,40,1,40,1,40,1,40,
        1,40,1,40,1,40,1,40,1,40,1,40,5,40,881,8,40,10,40,12,40,884,9,40,
        1,41,1,41,5,41,888,8,41,10,41,12,41,891,9,41,1,41,1,41,1,42,1,42,
        1,42,1,42,3,42,899,8,42,1,42,3,42,902,8,42,1,42,1,42,1,42,1,42,5,
        42,908,8,42,10,42,12,42,911,9,42,1,42,1,42,1,43,1,43,1,43,1,43,1,
        44,1,44,1,44,1,44,5,44,923,8,44,10,44,12,44,926,9,44,1,44,1,44,1,
        45,1,45,3,45,932,8,45,1,45,3,45,935,8,45,1,45,3,45,938,8,45,1,45,
        1,45,3,45,942,8,45,1,45,5,45,945,8,45,10,45,12,45,948,9,45,1,45,
        1,45,1,46,1,46,5,46,954,8,46,10,46,12,46,957,9,46,1,46,1,46,3,46,
        961,8,46,1,46,3,46,964,8,46,1,46,3,46,967,8,46,5,46,969,8,46,10,
        46,12,46,972,9,46,1,47,1,47,3,47,976,8,47,1,47,1,47,3,47,980,8,47,
        1,48,1,48,1,48,1,48,1,49,1,49,5,49,988,8,49,10,49,12,49,991,9,49,
        1,49,1,49,3,49,995,8,49,1,49,3,49,998,8,49,1,49,3,49,1001,8,49,1,
        50,1,50,3,50,1005,8,50,1,50,1,50,1,51,1,51,1,51,5,51,1012,8,51,10,
        51,12,51,1015,9,51,1,51,1,51,1,52,1,52,3,52,1021,8,52,1,52,1,52,
        1,53,1,53,3,53,1027,8,53,1,53,1,53,3,53,1031,8,53,1,53,1,53,1,53,
        1,53,5,53,1037,8,53,10,53,12,53,1040,9,53,1,53,1,53,1,54,1,54,5,
        54,1046,8,54,10,54,12,54,1049,9,54,1,55,1,55,3,55,1053,8,55,1,55,
        1,55,3,55,1057,8,55,1,55,1,55,3,55,1061,8,55,1,55,3,55,1064,8,55,
        1,56,1,56,1,57,1,57,1,57,3,57,1071,8,57,1,57,3,57,1074,8,57,1,57,
        1,57,5,57,1078,8,57,10,57,12,57,1081,9,57,1,57,5,57,1084,8,57,10,
        57,12,57,1087,9,57,1,58,1,58,1,58,3,58,1092,8,58,1,58,3,58,1095,
        8,58,1,58,1,58,3,58,1099,8,58,1,58,3,58,1102,8,58,1,58,5,58,1105,
        8,58,10,58,12,58,1108,9,58,1,58,5,58,1111,8,58,10,58,12,58,1114,
        9,58,1,58,1,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,1125,8,59,
        10,59,12,59,1128,9,59,1,59,1,59,1,60,1,60,3,60,1134,8,60,1,60,1,
        60,1,61,1,61,3,61,1140,8,61,1,61,1,61,1,61,3,61,1145,8,61,1,61,3,
        61,1148,8,61,1,61,3,61,1151,8,61,1,61,3,61,1154,8,61,3,61,1156,8,
        61,1,61,3,61,1159,8,61,1,61,3,61,1162,8,61,1,61,3,61,1165,8,61,1,
        61,1,61,1,61,5,61,1170,8,61,10,61,12,61,1173,9,61,1,61,1,61,1,62,
        1,62,1,62,1,62,1,62,3,62,1182,8,62,1,63,1,63,1,63,1,63,5,63,1188,
        8,63,10,63,12,63,1191,9,63,1,63,3,63,1194,8,63,1,63,4,63,1197,8,
        63,11,63,12,63,1198,1,63,1,63,3,63,1203,8,63,1,64,1,64,5,64,1207,
        8,64,10,64,12,64,1210,9,64,1,64,1,64,1,65,1,65,1,65,1,65,1,65,1,
        65,3,65,1220,8,65,1,65,3,65,1223,8,65,1,65,3,65,1226,8,65,1,65,1,
        65,1,65,3,65,1231,8,65,1,65,3,65,1234,8,65,1,65,1,65,1,65,1,65,3,
        65,1240,8,65,1,65,3,65,1243,8,65,1,65,1,65,3,65,1247,8,65,1,66,1,
        66,1,66,1,66,5,66,1253,8,66,10,66,12,66,1256,9,66,1,66,1,66,5,66,
        1260,8,66,10,66,12,66,1263,9,66,1,66,1,66,1,66,3,66,1268,8,66,1,
        66,3,66,1271,8,66,1,66,1,66,3,66,1275,8,66,3,66,1277,8,66,1,67,1,
        67,1,67,1,67,5,67,1283,8,67,10,67,12,67,1286,9,67,1,67,3,67,1289,
        8,67,1,67,5,67,1292,8,67,10,67,12,67,1295,9,67,1,67,1,67,5,67,1299,
        8,67,10,67,12,67,1302,9,67,1,67,1,67,3,67,1306,8,67,3,67,1308,8,
        67,1,68,1,68,1,68,1,68,3,68,1314,8,68,1,68,3,68,1317,8,68,1,68,1,
        68,1,69,1,69,1,69,1,69,3,69,1325,8,69,1,69,3,69,1328,8,69,1,69,1,
        69,1,70,3,70,1333,8,70,1,70,3,70,1336,8,70,1,70,1,70,1,70,1,70,3,
        70,1342,8,70,1,70,3,70,1345,8,70,1,70,3,70,1348,8,70,1,71,1,71,1,
        71,1,71,3,71,1354,8,71,1,71,3,71,1357,8,71,1,71,1,71,1,71,3,71,1362,
        8,71,1,71,1,71,1,71,3,71,1367,8,71,1,71,3,71,1370,8,71,1,71,1,71,
        1,71,1,71,3,71,1376,8,71,1,71,3,71,1379,8,71,1,71,3,71,1382,8,71,
        1,71,1,71,1,71,1,71,3,71,1388,8,71,1,71,3,71,1391,8,71,1,71,3,71,
        1394,8,71,1,71,1,71,1,71,1,71,1,71,1,71,3,71,1402,8,71,1,71,3,71,
        1405,8,71,1,71,3,71,1408,8,71,3,71,1410,8,71,1,72,1,72,1,72,3,72,
        1415,8,72,1,72,1,72,1,72,3,72,1420,8,72,1,72,3,72,1423,8,72,1,72,
        1,72,1,72,1,72,3,72,1429,8,72,1,72,3,72,1432,8,72,1,72,3,72,1435,
        8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
        3,73,1449,8,73,1,74,1,74,1,74,3,74,1454,8,74,1,75,1,75,1,76,1,76,
        3,76,1460,8,76,1,76,1,76,3,76,1464,8,76,1,76,1,76,1,76,1,77,1,77,
        1,77,5,77,1472,8,77,10,77,12,77,1475,9,77,1,77,3,77,1478,8,77,1,
        78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,
        78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,
        78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,3,
        78,1519,8,78,1,79,1,79,3,79,1523,8,79,1,79,1,79,3,79,1527,8,79,1,
        79,1,79,3,79,1531,8,79,1,79,1,79,3,79,1535,8,79,1,79,1,79,3,79,1539,
        8,79,1,79,1,79,1,80,1,80,1,80,5,80,1546,8,80,10,80,12,80,1549,9,
        80,1,80,3,80,1552,8,80,1,81,1,81,3,81,1556,8,81,1,81,3,81,1559,8,
        81,1,81,3,81,1562,8,81,1,81,3,81,1565,8,81,1,81,1,81,3,81,1569,8,
        81,1,81,5,81,1572,8,81,10,81,12,81,1575,9,81,1,81,3,81,1578,8,81,
        1,81,3,81,1581,8,81,1,81,3,81,1584,8,81,1,81,3,81,1587,8,81,1,81,
        3,81,1590,8,81,1,81,3,81,1593,8,81,1,81,3,81,1596,8,81,1,81,3,81,
        1599,8,81,1,81,3,81,1602,8,81,1,81,3,81,1605,8,81,1,81,3,81,1608,
        8,81,1,81,3,81,1611,8,81,1,81,3,81,1614,8,81,1,81,3,81,1617,8,81,
        1,81,3,81,1620,8,81,1,82,1,82,3,82,1624,8,82,1,82,3,82,1627,8,82,
        1,82,3,82,1630,8,82,1,82,1,82,3,82,1634,8,82,1,82,3,82,1637,8,82,
        1,82,1,82,1,82,4,82,1642,8,82,11,82,12,82,1643,1,83,1,83,5,83,1648,
        8,83,10,83,12,83,1651,9,83,1,83,3,83,1654,8,83,1,84,1,84,5,84,1658,
        8,84,10,84,12,84,1661,9,84,1,84,3,84,1664,8,84,1,85,1,85,5,85,1668,
        8,85,10,85,12,85,1671,9,85,1,85,3,85,1674,8,85,1,86,1,86,5,86,1678,
        8,86,10,86,12,86,1681,9,86,1,86,3,86,1684,8,86,1,87,1,87,3,87,1688,
        8,87,1,87,3,87,1691,8,87,1,87,3,87,1694,8,87,1,87,1,87,3,87,1698,
        8,87,1,87,3,87,1701,8,87,1,87,1,87,3,87,1705,8,87,1,87,1,87,3,87,
        1709,8,87,1,87,1,87,3,87,1713,8,87,1,87,1,87,3,87,1717,8,87,1,87,
        3,87,1720,8,87,1,87,1,87,3,87,1724,8,87,1,87,3,87,1727,8,87,1,87,
        3,87,1730,8,87,1,87,1,87,3,87,1734,8,87,1,87,3,87,1737,8,87,1,87,
        1,87,3,87,1741,8,87,1,87,1,87,3,87,1745,8,87,1,88,1,88,3,88,1749,
        8,88,1,88,3,88,1752,8,88,1,88,1,88,3,88,1756,8,88,1,88,1,88,3,88,
        1760,8,88,1,88,1,88,3,88,1764,8,88,1,88,1,88,3,88,1768,8,88,1,88,
        3,88,1771,8,88,1,89,1,89,3,89,1775,8,89,1,89,1,89,3,89,1779,8,89,
        1,89,3,89,1782,8,89,1,90,1,90,1,90,1,90,1,90,1,90,3,90,1790,8,90,
        1,91,1,91,1,92,1,92,1,93,1,93,1,94,1,94,1,95,4,95,1801,8,95,11,95,
        12,95,1802,1,95,3,955,989,1802,0,96,0,2,4,6,8,10,12,14,16,18,20,
        22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
        66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
        108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,
        140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,
        172,174,176,178,180,182,184,186,188,190,0,37,3,0,79,79,214,214,286,
        286,2,0,265,265,286,287,3,0,77,77,80,81,115,115,2,0,268,268,284,
        284,9,0,22,22,40,40,48,48,66,66,79,81,90,90,94,108,110,110,250,250,
        2,0,263,263,284,284,2,0,32,32,58,58,2,0,32,32,57,57,1,0,286,287,
        2,0,86,86,90,90,1,0,83,84,3,0,265,265,284,284,286,287,2,0,284,284,
        286,286,2,0,32,32,207,207,1,0,157,158,2,0,32,32,238,238,1,0,154,
        155,1,0,160,161,1,0,73,74,2,0,64,64,217,217,3,0,218,219,265,265,
        284,284,2,0,265,265,284,284,2,0,102,102,284,284,2,0,13,13,31,31,
        1,0,32,33,1,0,91,92,1,0,142,143,1,0,24,25,2,0,48,48,63,63,1,1,287,
        287,2,0,250,262,292,293,2,0,13,13,52,52,7,0,49,49,96,96,124,124,
        263,263,265,267,284,284,286,286,2,0,244,249,276,281,1,0,272,275,
        25,0,8,11,14,14,22,22,31,32,34,47,50,51,55,55,60,61,64,64,67,68,
        70,72,76,76,88,89,93,93,111,114,125,126,128,128,130,154,156,157,
        159,160,162,188,190,192,194,200,203,206,217,217,19,0,8,10,13,16,
        18,18,32,33,35,36,38,39,41,41,47,47,50,51,55,55,63,64,68,68,70,70,
        76,76,128,128,142,143,179,179,194,194,206,207,2227,0,196,1,0,0,0,
        2,200,1,0,0,0,4,207,1,0,0,0,6,253,1,0,0,0,8,255,1,0,0,0,10,263,1,
        0,0,0,12,308,1,0,0,0,14,326,1,0,0,0,16,328,1,0,0,0,18,333,1,0,0,
        0,20,358,1,0,0,0,22,360,1,0,0,0,24,395,1,0,0,0,26,397,1,0,0,0,28,
        406,1,0,0,0,30,420,1,0,0,0,32,422,1,0,0,0,34,460,1,0,0,0,36,462,
        1,0,0,0,38,471,1,0,0,0,40,536,1,0,0,0,42,540,1,0,0,0,44,584,1,0,
        0,0,46,592,1,0,0,0,48,622,1,0,0,0,50,625,1,0,0,0,52,689,1,0,0,0,
        54,691,1,0,0,0,56,716,1,0,0,0,58,726,1,0,0,0,60,728,1,0,0,0,62,744,
        1,0,0,0,64,746,1,0,0,0,66,754,1,0,0,0,68,769,1,0,0,0,70,809,1,0,
        0,0,72,814,1,0,0,0,74,816,1,0,0,0,76,864,1,0,0,0,78,866,1,0,0,0,
        80,882,1,0,0,0,82,885,1,0,0,0,84,894,1,0,0,0,86,914,1,0,0,0,88,918,
        1,0,0,0,90,929,1,0,0,0,92,951,1,0,0,0,94,979,1,0,0,0,96,981,1,0,
        0,0,98,985,1,0,0,0,100,1002,1,0,0,0,102,1013,1,0,0,0,104,1018,1,
        0,0,0,106,1024,1,0,0,0,108,1043,1,0,0,0,110,1050,1,0,0,0,112,1065,
        1,0,0,0,114,1067,1,0,0,0,116,1088,1,0,0,0,118,1117,1,0,0,0,120,1131,
        1,0,0,0,122,1137,1,0,0,0,124,1181,1,0,0,0,126,1183,1,0,0,0,128,1204,
        1,0,0,0,130,1213,1,0,0,0,132,1248,1,0,0,0,134,1278,1,0,0,0,136,1309,
        1,0,0,0,138,1320,1,0,0,0,140,1347,1,0,0,0,142,1409,1,0,0,0,144,1414,
        1,0,0,0,146,1448,1,0,0,0,148,1450,1,0,0,0,150,1455,1,0,0,0,152,1457,
        1,0,0,0,154,1473,1,0,0,0,156,1518,1,0,0,0,158,1520,1,0,0,0,160,1547,
        1,0,0,0,162,1553,1,0,0,0,164,1621,1,0,0,0,166,1645,1,0,0,0,168,1655,
        1,0,0,0,170,1665,1,0,0,0,172,1675,1,0,0,0,174,1744,1,0,0,0,176,1746,
        1,0,0,0,178,1772,1,0,0,0,180,1789,1,0,0,0,182,1791,1,0,0,0,184,1793,
        1,0,0,0,186,1795,1,0,0,0,188,1797,1,0,0,0,190,1800,1,0,0,0,192,197,
        3,2,1,0,193,197,3,4,2,0,194,197,5,286,0,0,195,197,5,287,0,0,196,
        192,1,0,0,0,196,193,1,0,0,0,196,194,1,0,0,0,196,195,1,0,0,0,197,
        198,1,0,0,0,198,196,1,0,0,0,198,199,1,0,0,0,199,1,1,0,0,0,200,202,
        5,265,0,0,201,203,5,286,0,0,202,201,1,0,0,0,202,203,1,0,0,0,203,
        204,1,0,0,0,204,205,3,4,2,0,205,3,1,0,0,0,206,208,3,6,3,0,207,206,
        1,0,0,0,207,208,1,0,0,0,208,251,1,0,0,0,209,252,3,8,4,0,210,252,
        3,152,76,0,211,252,3,158,79,0,212,252,3,88,44,0,213,252,3,122,61,
        0,214,252,3,162,81,0,215,252,3,118,59,0,216,252,3,124,62,0,217,252,
        3,110,55,0,218,252,3,106,53,0,219,252,3,28,14,0,220,252,3,32,16,
        0,221,252,3,44,22,0,222,252,3,50,25,0,223,252,3,40,20,0,224,252,
        3,52,26,0,225,252,3,56,28,0,226,252,3,58,29,0,227,252,3,68,34,0,
        228,252,3,72,36,0,229,252,3,74,37,0,230,252,3,76,38,0,231,252,3,
        84,42,0,232,252,3,86,43,0,233,252,3,14,7,0,234,252,3,22,11,0,235,
        252,3,180,90,0,236,252,3,164,82,0,237,252,3,108,54,0,238,252,3,100,
        50,0,239,252,3,104,52,0,240,252,3,26,13,0,241,252,3,10,5,0,242,252,
        3,38,19,0,243,252,3,36,18,0,244,252,3,90,45,0,245,252,3,92,46,0,
        246,252,3,96,48,0,247,252,3,98,49,0,248,252,3,114,57,0,249,252,3,
        116,58,0,250,252,3,190,95,0,251,209,1,0,0,0,251,210,1,0,0,0,251,
        211,1,0,0,0,251,212,1,0,0,0,251,213,1,0,0,0,251,214,1,0,0,0,251,
        215,1,0,0,0,251,216,1,0,0,0,251,217,1,0,0,0,251,218,1,0,0,0,251,
        219,1,0,0,0,251,220,1,0,0,0,251,221,1,0,0,0,251,222,1,0,0,0,251,
        223,1,0,0,0,251,224,1,0,0,0,251,225,1,0,0,0,251,226,1,0,0,0,251,
        227,1,0,0,0,251,228,1,0,0,0,251,229,1,0,0,0,251,230,1,0,0,0,251,
        231,1,0,0,0,251,232,1,0,0,0,251,233,1,0,0,0,251,234,1,0,0,0,251,
        235,1,0,0,0,251,236,1,0,0,0,251,237,1,0,0,0,251,238,1,0,0,0,251,
        239,1,0,0,0,251,240,1,0,0,0,251,241,1,0,0,0,251,242,1,0,0,0,251,
        243,1,0,0,0,251,244,1,0,0,0,251,245,1,0,0,0,251,246,1,0,0,0,251,
        247,1,0,0,0,251,248,1,0,0,0,251,249,1,0,0,0,251,250,1,0,0,0,252,
        5,1,0,0,0,253,254,5,303,0,0,254,7,1,0,0,0,255,257,5,192,0,0,256,
        258,3,4,2,0,257,256,1,0,0,0,258,259,1,0,0,0,259,257,1,0,0,0,259,
        260,1,0,0,0,260,261,1,0,0,0,261,262,5,193,0,0,262,9,1,0,0,0,263,
        267,5,72,0,0,264,266,7,0,0,0,265,264,1,0,0,0,266,269,1,0,0,0,267,
        265,1,0,0,0,267,268,1,0,0,0,268,273,1,0,0,0,269,267,1,0,0,0,270,
        274,3,146,73,0,271,274,5,286,0,0,272,274,5,287,0,0,273,270,1,0,0,
        0,273,271,1,0,0,0,273,272,1,0,0,0,274,275,1,0,0,0,275,273,1,0,0,
        0,275,276,1,0,0,0,276,277,1,0,0,0,277,281,5,106,0,0,278,280,7,1,
        0,0,279,278,1,0,0,0,280,283,1,0,0,0,281,279,1,0,0,0,281,282,1,0,
        0,0,282,284,1,0,0,0,283,281,1,0,0,0,284,292,3,146,73,0,285,287,7,
        1,0,0,286,285,1,0,0,0,287,290,1,0,0,0,288,286,1,0,0,0,288,289,1,
        0,0,0,289,291,1,0,0,0,290,288,1,0,0,0,291,293,3,12,6,0,292,288,1,
        0,0,0,292,293,1,0,0,0,293,11,1,0,0,0,294,309,5,215,0,0,295,309,5,
        216,0,0,296,301,5,90,0,0,297,299,5,286,0,0,298,297,1,0,0,0,298,299,
        1,0,0,0,299,300,1,0,0,0,300,302,5,29,0,0,301,298,1,0,0,0,301,302,
        1,0,0,0,302,303,1,0,0,0,303,305,5,103,0,0,304,306,5,286,0,0,305,
        304,1,0,0,0,305,306,1,0,0,0,306,307,1,0,0,0,307,309,5,263,0,0,308,
        294,1,0,0,0,308,295,1,0,0,0,308,296,1,0,0,0,309,13,1,0,0,0,310,311,
        5,68,0,0,311,312,5,286,0,0,312,327,3,18,9,0,313,321,5,68,0,0,314,
        322,5,263,0,0,315,322,3,20,10,0,316,322,3,16,8,0,317,322,5,275,0,
        0,318,322,5,286,0,0,319,322,5,265,0,0,320,322,5,287,0,0,321,314,
        1,0,0,0,321,315,1,0,0,0,321,316,1,0,0,0,321,317,1,0,0,0,321,318,
        1,0,0,0,321,319,1,0,0,0,321,320,1,0,0,0,322,323,1,0,0,0,323,321,
        1,0,0,0,323,324,1,0,0,0,324,325,1,0,0,0,325,327,5,287,0,0,326,310,
        1,0,0,0,326,313,1,0,0,0,327,15,1,0,0,0,328,329,7,2,0,0,329,17,1,
        0,0,0,330,332,3,4,2,0,331,330,1,0,0,0,332,335,1,0,0,0,333,331,1,
        0,0,0,333,334,1,0,0,0,334,337,1,0,0,0,335,333,1,0,0,0,336,338,5,
        66,0,0,337,336,1,0,0,0,337,338,1,0,0,0,338,340,1,0,0,0,339,341,5,
        286,0,0,340,339,1,0,0,0,340,341,1,0,0,0,341,342,1,0,0,0,342,344,
        5,69,0,0,343,345,5,286,0,0,344,343,1,0,0,0,344,345,1,0,0,0,345,346,
        1,0,0,0,346,347,5,263,0,0,347,19,1,0,0,0,348,353,5,284,0,0,349,351,
        5,286,0,0,350,349,1,0,0,0,350,351,1,0,0,0,351,352,1,0,0,0,352,354,
        7,3,0,0,353,350,1,0,0,0,353,354,1,0,0,0,354,359,1,0,0,0,355,356,
        5,284,0,0,356,357,5,298,0,0,357,359,5,284,0,0,358,348,1,0,0,0,358,
        355,1,0,0,0,359,21,1,0,0,0,360,363,5,76,0,0,361,362,5,286,0,0,362,
        364,5,79,0,0,363,361,1,0,0,0,363,364,1,0,0,0,364,374,1,0,0,0,365,
        366,5,265,0,0,366,368,5,286,0,0,367,365,1,0,0,0,367,368,1,0,0,0,
        368,369,1,0,0,0,369,373,3,24,12,0,370,373,5,286,0,0,371,373,5,287,
        0,0,372,367,1,0,0,0,372,370,1,0,0,0,372,371,1,0,0,0,373,376,1,0,
        0,0,374,372,1,0,0,0,374,375,1,0,0,0,375,379,1,0,0,0,376,374,1,0,
        0,0,377,378,5,286,0,0,378,380,5,82,0,0,379,377,1,0,0,0,379,380,1,
        0,0,0,380,23,1,0,0,0,381,396,5,77,0,0,382,396,5,284,0,0,383,396,
        5,78,0,0,384,385,5,77,0,0,385,386,5,286,0,0,386,387,5,80,0,0,387,
        388,5,286,0,0,388,389,5,265,0,0,389,390,5,286,0,0,390,391,5,81,0,
        0,391,392,5,286,0,0,392,396,5,284,0,0,393,396,5,65,0,0,394,396,5,
        263,0,0,395,381,1,0,0,0,395,382,1,0,0,0,395,383,1,0,0,0,395,384,
        1,0,0,0,395,393,1,0,0,0,395,394,1,0,0,0,396,25,1,0,0,0,397,401,5,
        126,0,0,398,400,3,4,2,0,399,398,1,0,0,0,400,403,1,0,0,0,401,399,
        1,0,0,0,401,402,1,0,0,0,402,404,1,0,0,0,403,401,1,0,0,0,404,405,
        5,127,0,0,405,27,1,0,0,0,406,407,5,93,0,0,407,414,5,286,0,0,408,
        415,3,20,10,0,409,415,5,263,0,0,410,415,3,30,15,0,411,415,5,265,
        0,0,412,415,5,286,0,0,413,415,5,287,0,0,414,408,1,0,0,0,414,409,
        1,0,0,0,414,410,1,0,0,0,414,411,1,0,0,0,414,412,1,0,0,0,414,413,
        1,0,0,0,415,416,1,0,0,0,416,414,1,0,0,0,416,417,1,0,0,0,417,418,
        1,0,0,0,418,419,5,287,0,0,419,29,1,0,0,0,420,421,7,4,0,0,421,31,
        1,0,0,0,422,424,5,47,0,0,423,425,5,286,0,0,424,423,1,0,0,0,424,425,
        1,0,0,0,425,429,1,0,0,0,426,430,3,34,17,0,427,430,5,286,0,0,428,
        430,5,287,0,0,429,426,1,0,0,0,429,427,1,0,0,0,429,428,1,0,0,0,430,
        431,1,0,0,0,431,429,1,0,0,0,431,432,1,0,0,0,432,434,1,0,0,0,433,
        435,5,49,0,0,434,433,1,0,0,0,434,435,1,0,0,0,435,439,1,0,0,0,436,
        440,3,34,17,0,437,440,5,286,0,0,438,440,5,287,0,0,439,436,1,0,0,
        0,439,437,1,0,0,0,439,438,1,0,0,0,440,441,1,0,0,0,441,439,1,0,0,
        0,441,442,1,0,0,0,442,33,1,0,0,0,443,461,3,146,73,0,444,445,5,278,
        0,0,445,446,3,146,73,0,446,447,5,277,0,0,447,461,1,0,0,0,448,461,
        5,124,0,0,449,461,5,94,0,0,450,461,5,116,0,0,451,461,5,117,0,0,452,
        461,5,118,0,0,453,461,5,119,0,0,454,461,5,120,0,0,455,461,5,121,
        0,0,456,461,5,122,0,0,457,461,5,123,0,0,458,461,5,29,0,0,459,461,
        5,109,0,0,460,443,1,0,0,0,460,444,1,0,0,0,460,448,1,0,0,0,460,449,
        1,0,0,0,460,450,1,0,0,0,460,451,1,0,0,0,460,452,1,0,0,0,460,453,
        1,0,0,0,460,454,1,0,0,0,460,455,1,0,0,0,460,456,1,0,0,0,460,457,
        1,0,0,0,460,458,1,0,0,0,460,459,1,0,0,0,461,35,1,0,0,0,462,466,5,
        31,0,0,463,465,3,4,2,0,464,463,1,0,0,0,465,468,1,0,0,0,466,464,1,
        0,0,0,466,467,1,0,0,0,467,469,1,0,0,0,468,466,1,0,0,0,469,470,5,
        32,0,0,470,37,1,0,0,0,471,475,5,50,0,0,472,474,3,4,2,0,473,472,1,
        0,0,0,474,477,1,0,0,0,475,473,1,0,0,0,475,476,1,0,0,0,476,478,1,
        0,0,0,477,475,1,0,0,0,478,479,5,64,0,0,479,39,1,0,0,0,480,482,5,
        39,0,0,481,483,5,286,0,0,482,481,1,0,0,0,482,483,1,0,0,0,483,484,
        1,0,0,0,484,486,5,284,0,0,485,487,5,286,0,0,486,485,1,0,0,0,486,
        487,1,0,0,0,487,489,1,0,0,0,488,490,5,90,0,0,489,488,1,0,0,0,489,
        490,1,0,0,0,490,492,1,0,0,0,491,493,5,286,0,0,492,491,1,0,0,0,492,
        493,1,0,0,0,493,495,1,0,0,0,494,496,5,287,0,0,495,494,1,0,0,0,495,
        496,1,0,0,0,496,500,1,0,0,0,497,499,3,42,21,0,498,497,1,0,0,0,499,
        502,1,0,0,0,500,498,1,0,0,0,500,501,1,0,0,0,501,537,1,0,0,0,502,
        500,1,0,0,0,503,505,5,39,0,0,504,506,5,286,0,0,505,504,1,0,0,0,505,
        506,1,0,0,0,506,507,1,0,0,0,507,509,5,83,0,0,508,510,5,286,0,0,509,
        508,1,0,0,0,509,510,1,0,0,0,510,512,1,0,0,0,511,513,5,81,0,0,512,
        511,1,0,0,0,512,513,1,0,0,0,513,515,1,0,0,0,514,516,5,286,0,0,515,
        514,1,0,0,0,515,516,1,0,0,0,516,517,1,0,0,0,517,519,5,284,0,0,518,
        520,5,286,0,0,519,518,1,0,0,0,519,520,1,0,0,0,520,522,1,0,0,0,521,
        523,5,90,0,0,522,521,1,0,0,0,522,523,1,0,0,0,523,525,1,0,0,0,524,
        526,5,286,0,0,525,524,1,0,0,0,525,526,1,0,0,0,526,528,1,0,0,0,527,
        529,5,287,0,0,528,527,1,0,0,0,528,529,1,0,0,0,529,533,1,0,0,0,530,
        532,3,42,21,0,531,530,1,0,0,0,532,535,1,0,0,0,533,531,1,0,0,0,533,
        534,1,0,0,0,534,537,1,0,0,0,535,533,1,0,0,0,536,480,1,0,0,0,536,
        503,1,0,0,0,537,41,1,0,0,0,538,539,5,265,0,0,539,541,5,286,0,0,540,
        538,1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,544,3,190,95,0,543,
        545,5,286,0,0,544,543,1,0,0,0,544,545,1,0,0,0,545,547,1,0,0,0,546,
        548,5,264,0,0,547,546,1,0,0,0,547,548,1,0,0,0,548,549,1,0,0,0,549,
        551,5,276,0,0,550,552,5,286,0,0,551,550,1,0,0,0,551,552,1,0,0,0,
        552,553,1,0,0,0,553,557,7,5,0,0,554,556,5,286,0,0,555,554,1,0,0,
        0,556,559,1,0,0,0,557,555,1,0,0,0,557,558,1,0,0,0,558,560,1,0,0,
        0,559,557,1,0,0,0,560,561,5,287,0,0,561,43,1,0,0,0,562,564,5,36,
        0,0,563,565,5,286,0,0,564,563,1,0,0,0,564,565,1,0,0,0,565,566,1,
        0,0,0,566,568,3,46,23,0,567,569,5,286,0,0,568,567,1,0,0,0,568,569,
        1,0,0,0,569,570,1,0,0,0,570,571,3,160,80,0,571,572,7,6,0,0,572,585,
        1,0,0,0,573,574,5,36,0,0,574,575,5,286,0,0,575,576,5,101,0,0,576,
        577,5,286,0,0,577,578,3,48,24,0,578,580,3,146,73,0,579,581,5,286,
        0,0,580,579,1,0,0,0,580,581,1,0,0,0,581,582,1,0,0,0,582,583,5,287,
        0,0,583,585,1,0,0,0,584,562,1,0,0,0,584,573,1,0,0,0,585,45,1,0,0,
        0,586,593,5,25,0,0,587,593,5,30,0,0,588,593,5,29,0,0,589,593,5,284,
        0,0,590,593,5,268,0,0,591,593,3,20,10,0,592,586,1,0,0,0,592,587,
        1,0,0,0,592,588,1,0,0,0,592,589,1,0,0,0,592,590,1,0,0,0,592,591,
        1,0,0,0,593,47,1,0,0,0,594,621,3,146,73,0,595,621,5,286,0,0,596,
        621,5,265,0,0,597,621,5,287,0,0,598,621,5,223,0,0,599,621,5,90,0,
        0,600,621,5,224,0,0,601,621,5,225,0,0,602,621,5,228,0,0,603,621,
        5,220,0,0,604,621,5,222,0,0,605,621,5,232,0,0,606,621,5,226,0,0,
        607,621,5,23,0,0,608,621,5,230,0,0,609,621,5,292,0,0,610,621,5,49,
        0,0,611,621,5,211,0,0,612,621,5,231,0,0,613,621,5,218,0,0,614,621,
        5,219,0,0,615,621,5,116,0,0,616,621,5,117,0,0,617,621,5,227,0,0,
        618,621,3,184,92,0,619,621,3,150,75,0,620,594,1,0,0,0,620,595,1,
        0,0,0,620,596,1,0,0,0,620,597,1,0,0,0,620,598,1,0,0,0,620,599,1,
        0,0,0,620,600,1,0,0,0,620,601,1,0,0,0,620,602,1,0,0,0,620,603,1,
        0,0,0,620,604,1,0,0,0,620,605,1,0,0,0,620,606,1,0,0,0,620,607,1,
        0,0,0,620,608,1,0,0,0,620,609,1,0,0,0,620,610,1,0,0,0,620,611,1,
        0,0,0,620,612,1,0,0,0,620,613,1,0,0,0,620,614,1,0,0,0,620,615,1,
        0,0,0,620,616,1,0,0,0,620,617,1,0,0,0,620,618,1,0,0,0,620,619,1,
        0,0,0,621,624,1,0,0,0,622,620,1,0,0,0,622,623,1,0,0,0,623,49,1,0,
        0,0,624,622,1,0,0,0,625,627,5,35,0,0,626,628,5,286,0,0,627,626,1,
        0,0,0,627,628,1,0,0,0,628,629,1,0,0,0,629,631,7,3,0,0,630,632,5,
        286,0,0,631,630,1,0,0,0,631,632,1,0,0,0,632,633,1,0,0,0,633,634,
        3,160,80,0,634,635,7,7,0,0,635,51,1,0,0,0,636,638,3,54,27,0,637,
        639,7,8,0,0,638,637,1,0,0,0,639,640,1,0,0,0,640,638,1,0,0,0,640,
        641,1,0,0,0,641,643,1,0,0,0,642,644,7,9,0,0,643,642,1,0,0,0,643,
        644,1,0,0,0,644,662,1,0,0,0,645,663,5,286,0,0,646,663,5,287,0,0,
        647,663,5,265,0,0,648,650,3,146,73,0,649,651,5,286,0,0,650,649,1,
        0,0,0,650,651,1,0,0,0,651,653,1,0,0,0,652,654,5,264,0,0,653,652,
        1,0,0,0,653,654,1,0,0,0,654,655,1,0,0,0,655,657,5,276,0,0,656,658,
        5,286,0,0,657,656,1,0,0,0,657,658,1,0,0,0,658,659,1,0,0,0,659,660,
        3,146,73,0,660,663,1,0,0,0,661,663,3,180,90,0,662,645,1,0,0,0,662,
        646,1,0,0,0,662,647,1,0,0,0,662,648,1,0,0,0,662,661,1,0,0,0,663,
        664,1,0,0,0,664,662,1,0,0,0,664,665,1,0,0,0,665,667,1,0,0,0,666,
        668,5,286,0,0,667,666,1,0,0,0,667,668,1,0,0,0,668,669,1,0,0,0,669,
        670,5,287,0,0,670,690,1,0,0,0,671,672,3,54,27,0,672,673,5,286,0,
        0,673,674,5,66,0,0,674,675,5,286,0,0,675,676,5,87,0,0,676,677,5,
        286,0,0,677,679,5,83,0,0,678,680,5,286,0,0,679,678,1,0,0,0,679,680,
        1,0,0,0,680,681,1,0,0,0,681,682,5,287,0,0,682,690,1,0,0,0,683,685,
        3,54,27,0,684,686,5,286,0,0,685,684,1,0,0,0,685,686,1,0,0,0,686,
        687,1,0,0,0,687,688,5,287,0,0,688,690,1,0,0,0,689,636,1,0,0,0,689,
        671,1,0,0,0,689,683,1,0,0,0,690,53,1,0,0,0,691,693,5,38,0,0,692,
        694,5,286,0,0,693,692,1,0,0,0,693,694,1,0,0,0,694,696,1,0,0,0,695,
        697,5,83,0,0,696,695,1,0,0,0,696,697,1,0,0,0,697,699,1,0,0,0,698,
        700,5,286,0,0,699,698,1,0,0,0,699,700,1,0,0,0,700,702,1,0,0,0,701,
        703,5,81,0,0,702,701,1,0,0,0,702,703,1,0,0,0,703,705,1,0,0,0,704,
        706,5,286,0,0,705,704,1,0,0,0,705,706,1,0,0,0,706,708,1,0,0,0,707,
        709,5,85,0,0,708,707,1,0,0,0,708,709,1,0,0,0,709,711,1,0,0,0,710,
        712,5,286,0,0,711,710,1,0,0,0,711,712,1,0,0,0,712,714,1,0,0,0,713,
        715,7,3,0,0,714,713,1,0,0,0,714,715,1,0,0,0,715,55,1,0,0,0,716,718,
        5,40,0,0,717,719,5,286,0,0,718,717,1,0,0,0,718,719,1,0,0,0,719,721,
        1,0,0,0,720,722,5,268,0,0,721,720,1,0,0,0,721,722,1,0,0,0,722,57,
        1,0,0,0,723,727,3,60,30,0,724,727,3,64,32,0,725,727,3,66,33,0,726,
        723,1,0,0,0,726,724,1,0,0,0,726,725,1,0,0,0,727,59,1,0,0,0,728,729,
        5,41,0,0,729,730,5,286,0,0,730,735,5,284,0,0,731,734,3,62,31,0,732,
        734,5,286,0,0,733,731,1,0,0,0,733,732,1,0,0,0,734,737,1,0,0,0,735,
        733,1,0,0,0,735,736,1,0,0,0,736,738,1,0,0,0,737,735,1,0,0,0,738,
        740,3,20,10,0,739,741,5,286,0,0,740,739,1,0,0,0,740,741,1,0,0,0,
        741,742,1,0,0,0,742,743,5,287,0,0,743,61,1,0,0,0,744,745,7,10,0,
        0,745,63,1,0,0,0,746,748,5,88,0,0,747,749,7,11,0,0,748,747,1,0,0,
        0,749,750,1,0,0,0,750,748,1,0,0,0,750,751,1,0,0,0,751,752,1,0,0,
        0,752,753,5,287,0,0,753,65,1,0,0,0,754,759,5,89,0,0,755,757,5,286,
        0,0,756,755,1,0,0,0,756,757,1,0,0,0,757,758,1,0,0,0,758,760,5,268,
        0,0,759,756,1,0,0,0,759,760,1,0,0,0,760,764,1,0,0,0,761,763,7,12,
        0,0,762,761,1,0,0,0,763,766,1,0,0,0,764,762,1,0,0,0,764,765,1,0,
        0,0,765,767,1,0,0,0,766,764,1,0,0,0,767,768,5,287,0,0,768,67,1,0,
        0,0,769,770,5,206,0,0,770,774,3,70,35,0,771,773,3,4,2,0,772,771,
        1,0,0,0,773,776,1,0,0,0,774,772,1,0,0,0,774,775,1,0,0,0,775,777,
        1,0,0,0,776,774,1,0,0,0,777,778,7,13,0,0,778,69,1,0,0,0,779,808,
        3,146,73,0,780,808,5,268,0,0,781,808,5,286,0,0,782,808,5,265,0,0,
        783,808,5,287,0,0,784,808,5,29,0,0,785,808,5,211,0,0,786,808,5,90,
        0,0,787,808,5,23,0,0,788,808,5,81,0,0,789,808,5,63,0,0,790,808,5,
        22,0,0,791,808,5,115,0,0,792,808,5,218,0,0,793,808,5,219,0,0,794,
        808,5,231,0,0,795,808,5,229,0,0,796,808,5,230,0,0,797,808,5,235,
        0,0,798,808,5,236,0,0,799,808,5,237,0,0,800,808,5,224,0,0,801,808,
        5,233,0,0,802,808,5,234,0,0,803,808,5,232,0,0,804,808,5,223,0,0,
        805,808,3,184,92,0,806,808,3,150,75,0,807,779,1,0,0,0,807,780,1,
        0,0,0,807,781,1,0,0,0,807,782,1,0,0,0,807,783,1,0,0,0,807,784,1,
        0,0,0,807,785,1,0,0,0,807,786,1,0,0,0,807,787,1,0,0,0,807,788,1,
        0,0,0,807,789,1,0,0,0,807,790,1,0,0,0,807,791,1,0,0,0,807,792,1,
        0,0,0,807,793,1,0,0,0,807,794,1,0,0,0,807,795,1,0,0,0,807,796,1,
        0,0,0,807,797,1,0,0,0,807,798,1,0,0,0,807,799,1,0,0,0,807,800,1,
        0,0,0,807,801,1,0,0,0,807,802,1,0,0,0,807,803,1,0,0,0,807,804,1,
        0,0,0,807,805,1,0,0,0,807,806,1,0,0,0,808,811,1,0,0,0,809,807,1,
        0,0,0,809,810,1,0,0,0,810,812,1,0,0,0,811,809,1,0,0,0,812,813,3,
        146,73,0,813,71,1,0,0,0,814,815,5,60,0,0,815,73,1,0,0,0,816,817,
        5,61,0,0,817,75,1,0,0,0,818,819,7,14,0,0,819,820,5,286,0,0,820,825,
        3,78,39,0,821,823,5,286,0,0,822,821,1,0,0,0,822,823,1,0,0,0,823,
        824,1,0,0,0,824,826,5,241,0,0,825,822,1,0,0,0,825,826,1,0,0,0,826,
        827,1,0,0,0,827,828,3,80,40,0,828,829,3,82,41,0,829,865,1,0,0,0,
        830,831,7,14,0,0,831,832,5,286,0,0,832,837,3,78,39,0,833,835,5,286,
        0,0,834,833,1,0,0,0,834,835,1,0,0,0,835,836,1,0,0,0,836,838,5,241,
        0,0,837,834,1,0,0,0,837,838,1,0,0,0,838,839,1,0,0,0,839,841,3,80,
        40,0,840,842,3,4,2,0,841,840,1,0,0,0,842,843,1,0,0,0,843,841,1,0,
        0,0,843,844,1,0,0,0,844,845,1,0,0,0,845,846,5,62,0,0,846,865,1,0,
        0,0,847,848,7,14,0,0,848,849,5,286,0,0,849,854,3,78,39,0,850,852,
        5,286,0,0,851,850,1,0,0,0,851,852,1,0,0,0,852,853,1,0,0,0,853,855,
        5,241,0,0,854,851,1,0,0,0,854,855,1,0,0,0,855,856,1,0,0,0,856,858,
        3,80,40,0,857,859,3,4,2,0,858,857,1,0,0,0,859,860,1,0,0,0,860,858,
        1,0,0,0,860,861,1,0,0,0,861,862,1,0,0,0,862,863,7,15,0,0,863,865,
        1,0,0,0,864,818,1,0,0,0,864,830,1,0,0,0,864,847,1,0,0,0,865,77,1,
        0,0,0,866,867,5,265,0,0,867,79,1,0,0,0,868,881,3,146,73,0,869,881,
        5,268,0,0,870,881,5,286,0,0,871,881,5,265,0,0,872,881,5,287,0,0,
        873,881,5,83,0,0,874,881,5,240,0,0,875,881,5,239,0,0,876,881,5,292,
        0,0,877,881,5,37,0,0,878,881,5,96,0,0,879,881,5,100,0,0,880,868,
        1,0,0,0,880,869,1,0,0,0,880,870,1,0,0,0,880,871,1,0,0,0,880,872,
        1,0,0,0,880,873,1,0,0,0,880,874,1,0,0,0,880,875,1,0,0,0,880,876,
        1,0,0,0,880,877,1,0,0,0,880,878,1,0,0,0,880,879,1,0,0,0,881,884,
        1,0,0,0,882,880,1,0,0,0,882,883,1,0,0,0,883,81,1,0,0,0,884,882,1,
        0,0,0,885,889,5,242,0,0,886,888,3,4,2,0,887,886,1,0,0,0,888,891,
        1,0,0,0,889,887,1,0,0,0,889,890,1,0,0,0,890,892,1,0,0,0,891,889,
        1,0,0,0,892,893,5,243,0,0,893,83,1,0,0,0,894,895,7,16,0,0,895,896,
        5,286,0,0,896,901,3,78,39,0,897,899,5,286,0,0,898,897,1,0,0,0,898,
        899,1,0,0,0,899,900,1,0,0,0,900,902,5,235,0,0,901,898,1,0,0,0,901,
        902,1,0,0,0,902,909,1,0,0,0,903,908,3,146,73,0,904,908,5,265,0,0,
        905,908,5,286,0,0,906,908,5,287,0,0,907,903,1,0,0,0,907,904,1,0,
        0,0,907,905,1,0,0,0,907,906,1,0,0,0,908,911,1,0,0,0,909,907,1,0,
        0,0,909,910,1,0,0,0,910,912,1,0,0,0,911,909,1,0,0,0,912,913,5,287,
        0,0,913,85,1,0,0,0,914,915,7,17,0,0,915,916,5,286,0,0,916,917,3,
        78,39,0,917,87,1,0,0,0,918,919,5,14,0,0,919,920,5,286,0,0,920,924,
        7,18,0,0,921,923,3,4,2,0,922,921,1,0,0,0,923,926,1,0,0,0,924,922,
        1,0,0,0,924,925,1,0,0,0,925,927,1,0,0,0,926,924,1,0,0,0,927,928,
        5,75,0,0,928,89,1,0,0,0,929,931,5,179,0,0,930,932,5,286,0,0,931,
        930,1,0,0,0,931,932,1,0,0,0,932,934,1,0,0,0,933,935,5,284,0,0,934,
        933,1,0,0,0,934,935,1,0,0,0,935,937,1,0,0,0,936,938,5,287,0,0,937,
        936,1,0,0,0,937,938,1,0,0,0,938,941,1,0,0,0,939,940,5,50,0,0,940,
        942,5,286,0,0,941,939,1,0,0,0,941,942,1,0,0,0,942,946,1,0,0,0,943,
        945,3,4,2,0,944,943,1,0,0,0,945,948,1,0,0,0,946,944,1,0,0,0,946,
        947,1,0,0,0,947,949,1,0,0,0,948,946,1,0,0,0,949,950,7,19,0,0,950,
        91,1,0,0,0,951,970,3,94,47,0,952,954,5,286,0,0,953,952,1,0,0,0,954,
        957,1,0,0,0,955,956,1,0,0,0,955,953,1,0,0,0,956,958,1,0,0,0,957,
        955,1,0,0,0,958,960,3,96,48,0,959,961,5,286,0,0,960,959,1,0,0,0,
        960,961,1,0,0,0,961,963,1,0,0,0,962,964,5,287,0,0,963,962,1,0,0,
        0,963,964,1,0,0,0,964,966,1,0,0,0,965,967,5,265,0,0,966,965,1,0,
        0,0,966,967,1,0,0,0,967,969,1,0,0,0,968,955,1,0,0,0,969,972,1,0,
        0,0,970,968,1,0,0,0,970,971,1,0,0,0,971,93,1,0,0,0,972,970,1,0,0,
        0,973,975,5,128,0,0,974,976,5,286,0,0,975,974,1,0,0,0,975,976,1,
        0,0,0,976,977,1,0,0,0,977,980,5,268,0,0,978,980,5,128,0,0,979,973,
        1,0,0,0,979,978,1,0,0,0,980,95,1,0,0,0,981,982,5,284,0,0,982,983,
        3,184,92,0,983,984,7,20,0,0,984,97,1,0,0,0,985,989,5,194,0,0,986,
        988,5,286,0,0,987,986,1,0,0,0,988,991,1,0,0,0,989,990,1,0,0,0,989,
        987,1,0,0,0,990,992,1,0,0,0,991,989,1,0,0,0,992,994,5,284,0,0,993,
        995,5,286,0,0,994,993,1,0,0,0,994,995,1,0,0,0,995,997,1,0,0,0,996,
        998,5,287,0,0,997,996,1,0,0,0,997,998,1,0,0,0,998,1000,1,0,0,0,999,
        1001,5,265,0,0,1000,999,1,0,0,0,1000,1001,1,0,0,0,1001,99,1,0,0,
        0,1002,1004,5,8,0,0,1003,1005,5,286,0,0,1004,1003,1,0,0,0,1004,1005,
        1,0,0,0,1005,1006,1,0,0,0,1006,1007,3,102,51,0,1007,101,1,0,0,0,
        1008,1012,7,21,0,0,1009,1012,5,286,0,0,1010,1012,5,287,0,0,1011,
        1008,1,0,0,0,1011,1009,1,0,0,0,1011,1010,1,0,0,0,1012,1015,1,0,0,
        0,1013,1011,1,0,0,0,1013,1014,1,0,0,0,1014,1016,1,0,0,0,1015,1013,
        1,0,0,0,1016,1017,5,287,0,0,1017,103,1,0,0,0,1018,1020,5,70,0,0,
        1019,1021,5,286,0,0,1020,1019,1,0,0,0,1020,1021,1,0,0,0,1021,1022,
        1,0,0,0,1022,1023,3,102,51,0,1023,105,1,0,0,0,1024,1026,5,10,0,0,
        1025,1027,5,286,0,0,1026,1025,1,0,0,0,1026,1027,1,0,0,0,1027,1028,
        1,0,0,0,1028,1030,5,263,0,0,1029,1031,5,286,0,0,1030,1029,1,0,0,
        0,1030,1031,1,0,0,0,1031,1038,1,0,0,0,1032,1037,3,20,10,0,1033,1037,
        5,286,0,0,1034,1037,5,287,0,0,1035,1037,5,265,0,0,1036,1032,1,0,
        0,0,1036,1033,1,0,0,0,1036,1034,1,0,0,0,1036,1035,1,0,0,0,1037,1040,
        1,0,0,0,1038,1036,1,0,0,0,1038,1039,1,0,0,0,1039,1041,1,0,0,0,1040,
        1038,1,0,0,0,1041,1042,5,287,0,0,1042,107,1,0,0,0,1043,1047,5,71,
        0,0,1044,1046,5,286,0,0,1045,1044,1,0,0,0,1046,1049,1,0,0,0,1047,
        1045,1,0,0,0,1047,1048,1,0,0,0,1048,109,1,0,0,0,1049,1047,1,0,0,
        0,1050,1052,5,9,0,0,1051,1053,5,286,0,0,1052,1051,1,0,0,0,1052,1053,
        1,0,0,0,1053,1054,1,0,0,0,1054,1063,3,112,56,0,1055,1057,5,286,0,
        0,1056,1055,1,0,0,0,1056,1057,1,0,0,0,1057,1058,1,0,0,0,1058,1060,
        5,66,0,0,1059,1061,5,286,0,0,1060,1059,1,0,0,0,1060,1061,1,0,0,0,
        1061,1062,1,0,0,0,1062,1064,3,20,10,0,1063,1056,1,0,0,0,1063,1064,
        1,0,0,0,1064,111,1,0,0,0,1065,1066,7,22,0,0,1066,113,1,0,0,0,1067,
        1070,5,147,0,0,1068,1069,5,286,0,0,1069,1071,7,23,0,0,1070,1068,
        1,0,0,0,1070,1071,1,0,0,0,1071,1073,1,0,0,0,1072,1074,5,286,0,0,
        1073,1072,1,0,0,0,1073,1074,1,0,0,0,1074,1075,1,0,0,0,1075,1085,
        5,263,0,0,1076,1078,7,1,0,0,1077,1076,1,0,0,0,1078,1081,1,0,0,0,
        1079,1077,1,0,0,0,1079,1080,1,0,0,0,1080,1082,1,0,0,0,1081,1079,
        1,0,0,0,1082,1084,7,5,0,0,1083,1079,1,0,0,0,1084,1087,1,0,0,0,1085,
        1083,1,0,0,0,1085,1086,1,0,0,0,1086,115,1,0,0,0,1087,1085,1,0,0,
        0,1088,1091,5,144,0,0,1089,1090,5,286,0,0,1090,1092,5,221,0,0,1091,
        1089,1,0,0,0,1091,1092,1,0,0,0,1092,1094,1,0,0,0,1093,1095,5,286,
        0,0,1094,1093,1,0,0,0,1094,1095,1,0,0,0,1095,1096,1,0,0,0,1096,1101,
        5,263,0,0,1097,1099,5,286,0,0,1098,1097,1,0,0,0,1098,1099,1,0,0,
        0,1099,1100,1,0,0,0,1100,1102,5,66,0,0,1101,1098,1,0,0,0,1101,1102,
        1,0,0,0,1102,1112,1,0,0,0,1103,1105,7,1,0,0,1104,1103,1,0,0,0,1105,
        1108,1,0,0,0,1106,1104,1,0,0,0,1106,1107,1,0,0,0,1107,1109,1,0,0,
        0,1108,1106,1,0,0,0,1109,1111,7,5,0,0,1110,1106,1,0,0,0,1111,1114,
        1,0,0,0,1112,1110,1,0,0,0,1112,1113,1,0,0,0,1113,1115,1,0,0,0,1114,
        1112,1,0,0,0,1115,1116,5,287,0,0,1116,117,1,0,0,0,1117,1118,5,22,
        0,0,1118,1119,5,286,0,0,1119,1120,3,142,71,0,1120,1121,5,49,0,0,
        1121,1122,5,286,0,0,1122,1126,3,146,73,0,1123,1125,3,4,2,0,1124,
        1123,1,0,0,0,1125,1128,1,0,0,0,1126,1124,1,0,0,0,1126,1127,1,0,0,
        0,1127,1129,1,0,0,0,1128,1126,1,0,0,0,1129,1130,7,24,0,0,1130,119,
        1,0,0,0,1131,1133,7,25,0,0,1132,1134,5,286,0,0,1133,1132,1,0,0,0,
        1133,1134,1,0,0,0,1134,1135,1,0,0,0,1135,1136,3,142,71,0,1136,121,
        1,0,0,0,1137,1139,7,26,0,0,1138,1140,5,286,0,0,1139,1138,1,0,0,0,
        1139,1140,1,0,0,0,1140,1141,1,0,0,0,1141,1155,7,27,0,0,1142,1144,
        5,286,0,0,1143,1145,5,26,0,0,1144,1143,1,0,0,0,1144,1145,1,0,0,0,
        1145,1147,1,0,0,0,1146,1148,5,286,0,0,1147,1146,1,0,0,0,1147,1148,
        1,0,0,0,1148,1150,1,0,0,0,1149,1151,5,287,0,0,1150,1149,1,0,0,0,
        1150,1151,1,0,0,0,1151,1153,1,0,0,0,1152,1154,5,265,0,0,1153,1152,
        1,0,0,0,1153,1154,1,0,0,0,1154,1156,1,0,0,0,1155,1142,1,0,0,0,1155,
        1156,1,0,0,0,1156,1158,1,0,0,0,1157,1159,7,28,0,0,1158,1157,1,0,
        0,0,1158,1159,1,0,0,0,1159,1161,1,0,0,0,1160,1162,5,286,0,0,1161,
        1160,1,0,0,0,1161,1162,1,0,0,0,1162,1164,1,0,0,0,1163,1165,5,21,
        0,0,1164,1163,1,0,0,0,1164,1165,1,0,0,0,1165,1166,1,0,0,0,1166,1167,
        5,286,0,0,1167,1171,5,284,0,0,1168,1170,3,4,2,0,1169,1168,1,0,0,
        0,1170,1173,1,0,0,0,1171,1169,1,0,0,0,1171,1172,1,0,0,0,1172,1174,
        1,0,0,0,1173,1171,1,0,0,0,1174,1175,5,20,0,0,1175,123,1,0,0,0,1176,
        1182,3,126,63,0,1177,1182,3,130,65,0,1178,1182,3,132,66,0,1179,1182,
        3,134,67,0,1180,1182,3,120,60,0,1181,1176,1,0,0,0,1181,1177,1,0,
        0,0,1181,1178,1,0,0,0,1181,1179,1,0,0,0,1181,1180,1,0,0,0,1182,125,
        1,0,0,0,1183,1184,5,14,0,0,1184,1185,5,286,0,0,1185,1189,3,142,71,
        0,1186,1188,7,1,0,0,1187,1186,1,0,0,0,1188,1191,1,0,0,0,1189,1187,
        1,0,0,0,1189,1190,1,0,0,0,1190,1193,1,0,0,0,1191,1189,1,0,0,0,1192,
        1194,5,15,0,0,1193,1192,1,0,0,0,1193,1194,1,0,0,0,1194,1196,1,0,
        0,0,1195,1197,3,4,2,0,1196,1195,1,0,0,0,1197,1198,1,0,0,0,1198,1196,
        1,0,0,0,1198,1199,1,0,0,0,1199,1202,1,0,0,0,1200,1203,5,18,0,0,1201,
        1203,3,128,64,0,1202,1200,1,0,0,0,1202,1201,1,0,0,0,1203,127,1,0,
        0,0,1204,1208,5,16,0,0,1205,1207,3,4,2,0,1206,1205,1,0,0,0,1207,
        1210,1,0,0,0,1208,1206,1,0,0,0,1208,1209,1,0,0,0,1209,1211,1,0,0,
        0,1210,1208,1,0,0,0,1211,1212,5,18,0,0,1212,129,1,0,0,0,1213,1214,
        5,14,0,0,1214,1215,5,286,0,0,1215,1222,3,142,71,0,1216,1223,5,286,
        0,0,1217,1219,5,287,0,0,1218,1220,5,265,0,0,1219,1218,1,0,0,0,1219,
        1220,1,0,0,0,1220,1221,1,0,0,0,1221,1223,5,286,0,0,1222,1216,1,0,
        0,0,1222,1217,1,0,0,0,1223,1225,1,0,0,0,1224,1226,5,15,0,0,1225,
        1224,1,0,0,0,1225,1226,1,0,0,0,1226,1233,1,0,0,0,1227,1234,5,286,
        0,0,1228,1230,5,287,0,0,1229,1231,5,265,0,0,1230,1229,1,0,0,0,1230,
        1231,1,0,0,0,1231,1232,1,0,0,0,1232,1234,5,286,0,0,1233,1227,1,0,
        0,0,1233,1228,1,0,0,0,1233,1234,1,0,0,0,1234,1235,1,0,0,0,1235,1242,
        3,38,19,0,1236,1243,5,286,0,0,1237,1239,5,287,0,0,1238,1240,5,265,
        0,0,1239,1238,1,0,0,0,1239,1240,1,0,0,0,1240,1241,1,0,0,0,1241,1243,
        5,286,0,0,1242,1236,1,0,0,0,1242,1237,1,0,0,0,1243,1246,1,0,0,0,
        1244,1247,3,136,68,0,1245,1247,3,138,69,0,1246,1244,1,0,0,0,1246,
        1245,1,0,0,0,1247,131,1,0,0,0,1248,1249,5,14,0,0,1249,1250,5,286,
        0,0,1250,1254,3,142,71,0,1251,1253,7,1,0,0,1252,1251,1,0,0,0,1253,
        1256,1,0,0,0,1254,1252,1,0,0,0,1254,1255,1,0,0,0,1255,1257,1,0,0,
        0,1256,1254,1,0,0,0,1257,1261,5,15,0,0,1258,1260,7,1,0,0,1259,1258,
        1,0,0,0,1260,1263,1,0,0,0,1261,1259,1,0,0,0,1261,1262,1,0,0,0,1262,
        1264,1,0,0,0,1263,1261,1,0,0,0,1264,1276,3,38,19,0,1265,1271,5,286,
        0,0,1266,1268,5,265,0,0,1267,1266,1,0,0,0,1267,1268,1,0,0,0,1268,
        1269,1,0,0,0,1269,1271,5,286,0,0,1270,1265,1,0,0,0,1270,1267,1,0,
        0,0,1271,1274,1,0,0,0,1272,1275,3,136,68,0,1273,1275,3,138,69,0,
        1274,1272,1,0,0,0,1274,1273,1,0,0,0,1275,1277,1,0,0,0,1276,1270,
        1,0,0,0,1276,1277,1,0,0,0,1277,133,1,0,0,0,1278,1279,5,14,0,0,1279,
        1280,5,286,0,0,1280,1284,3,142,71,0,1281,1283,7,1,0,0,1282,1281,
        1,0,0,0,1283,1286,1,0,0,0,1284,1282,1,0,0,0,1284,1285,1,0,0,0,1285,
        1288,1,0,0,0,1286,1284,1,0,0,0,1287,1289,5,15,0,0,1288,1287,1,0,
        0,0,1288,1289,1,0,0,0,1289,1293,1,0,0,0,1290,1292,7,1,0,0,1291,1290,
        1,0,0,0,1292,1295,1,0,0,0,1293,1291,1,0,0,0,1293,1294,1,0,0,0,1294,
        1296,1,0,0,0,1295,1293,1,0,0,0,1296,1307,3,140,70,0,1297,1299,7,
        1,0,0,1298,1297,1,0,0,0,1299,1302,1,0,0,0,1300,1298,1,0,0,0,1300,
        1301,1,0,0,0,1301,1305,1,0,0,0,1302,1300,1,0,0,0,1303,1306,3,136,
        68,0,1304,1306,3,138,69,0,1305,1303,1,0,0,0,1305,1304,1,0,0,0,1306,
        1308,1,0,0,0,1307,1300,1,0,0,0,1307,1308,1,0,0,0,1308,135,1,0,0,
        0,1309,1316,5,16,0,0,1310,1317,5,286,0,0,1311,1313,5,287,0,0,1312,
        1314,5,265,0,0,1313,1312,1,0,0,0,1313,1314,1,0,0,0,1314,1315,1,0,
        0,0,1315,1317,5,286,0,0,1316,1310,1,0,0,0,1316,1311,1,0,0,0,1317,
        1318,1,0,0,0,1318,1319,3,38,19,0,1319,137,1,0,0,0,1320,1327,5,16,
        0,0,1321,1328,5,286,0,0,1322,1324,5,287,0,0,1323,1325,5,265,0,0,
        1324,1323,1,0,0,0,1324,1325,1,0,0,0,1325,1326,1,0,0,0,1326,1328,
        5,286,0,0,1327,1321,1,0,0,0,1327,1322,1,0,0,0,1328,1329,1,0,0,0,
        1329,1330,3,140,70,0,1330,139,1,0,0,0,1331,1333,5,265,0,0,1332,1331,
        1,0,0,0,1332,1333,1,0,0,0,1333,1334,1,0,0,0,1334,1336,5,286,0,0,
        1335,1332,1,0,0,0,1335,1336,1,0,0,0,1336,1337,1,0,0,0,1337,1338,
        3,4,2,0,1338,1339,7,29,0,0,1339,1348,1,0,0,0,1340,1342,5,265,0,0,
        1341,1340,1,0,0,0,1341,1342,1,0,0,0,1342,1343,1,0,0,0,1343,1345,
        5,286,0,0,1344,1341,1,0,0,0,1344,1345,1,0,0,0,1345,1346,1,0,0,0,
        1346,1348,3,4,2,0,1347,1335,1,0,0,0,1347,1344,1,0,0,0,1348,141,1,
        0,0,0,1349,1356,3,146,73,0,1350,1357,5,286,0,0,1351,1353,5,287,0,
        0,1352,1354,5,265,0,0,1353,1352,1,0,0,0,1353,1354,1,0,0,0,1354,1355,
        1,0,0,0,1355,1357,5,286,0,0,1356,1350,1,0,0,0,1356,1351,1,0,0,0,
        1357,1361,1,0,0,0,1358,1362,3,150,75,0,1359,1362,3,184,92,0,1360,
        1362,3,186,93,0,1361,1358,1,0,0,0,1361,1359,1,0,0,0,1361,1360,1,
        0,0,0,1362,1369,1,0,0,0,1363,1370,5,286,0,0,1364,1366,5,287,0,0,
        1365,1367,5,265,0,0,1366,1365,1,0,0,0,1366,1367,1,0,0,0,1367,1368,
        1,0,0,0,1368,1370,5,286,0,0,1369,1363,1,0,0,0,1369,1364,1,0,0,0,
        1370,1371,1,0,0,0,1371,1381,3,146,73,0,1372,1379,5,286,0,0,1373,
        1375,5,287,0,0,1374,1376,5,265,0,0,1375,1374,1,0,0,0,1375,1376,1,
        0,0,0,1376,1377,1,0,0,0,1377,1379,5,286,0,0,1378,1372,1,0,0,0,1378,
        1373,1,0,0,0,1378,1379,1,0,0,0,1379,1380,1,0,0,0,1380,1382,3,144,
        72,0,1381,1378,1,0,0,0,1381,1382,1,0,0,0,1382,1410,1,0,0,0,1383,
        1390,3,146,73,0,1384,1391,5,286,0,0,1385,1387,5,287,0,0,1386,1388,
        5,265,0,0,1387,1386,1,0,0,0,1387,1388,1,0,0,0,1388,1389,1,0,0,0,
        1389,1391,5,286,0,0,1390,1384,1,0,0,0,1390,1385,1,0,0,0,1390,1391,
        1,0,0,0,1391,1393,1,0,0,0,1392,1394,3,144,72,0,1393,1392,1,0,0,0,
        1393,1394,1,0,0,0,1394,1410,1,0,0,0,1395,1396,5,252,0,0,1396,1397,
        5,286,0,0,1397,1404,3,146,73,0,1398,1405,5,286,0,0,1399,1401,5,287,
        0,0,1400,1402,5,265,0,0,1401,1400,1,0,0,0,1401,1402,1,0,0,0,1402,
        1403,1,0,0,0,1403,1405,5,286,0,0,1404,1398,1,0,0,0,1404,1399,1,0,
        0,0,1404,1405,1,0,0,0,1405,1407,1,0,0,0,1406,1408,3,144,72,0,1407,
        1406,1,0,0,0,1407,1408,1,0,0,0,1408,1410,1,0,0,0,1409,1349,1,0,0,
        0,1409,1383,1,0,0,0,1409,1395,1,0,0,0,1410,143,1,0,0,0,1411,1415,
        3,150,75,0,1412,1415,3,184,92,0,1413,1415,3,186,93,0,1414,1411,1,
        0,0,0,1414,1412,1,0,0,0,1414,1413,1,0,0,0,1415,1422,1,0,0,0,1416,
        1423,5,286,0,0,1417,1419,5,287,0,0,1418,1420,5,265,0,0,1419,1418,
        1,0,0,0,1419,1420,1,0,0,0,1420,1421,1,0,0,0,1421,1423,5,286,0,0,
        1422,1416,1,0,0,0,1422,1417,1,0,0,0,1423,1424,1,0,0,0,1424,1431,
        3,146,73,0,1425,1432,5,286,0,0,1426,1428,5,287,0,0,1427,1429,5,265,
        0,0,1428,1427,1,0,0,0,1428,1429,1,0,0,0,1429,1430,1,0,0,0,1430,1432,
        5,286,0,0,1431,1425,1,0,0,0,1431,1426,1,0,0,0,1431,1432,1,0,0,0,
        1432,1434,1,0,0,0,1433,1435,3,144,72,0,1434,1433,1,0,0,0,1434,1435,
        1,0,0,0,1435,145,1,0,0,0,1436,1449,3,20,10,0,1437,1449,5,263,0,0,
        1438,1449,5,265,0,0,1439,1449,5,266,0,0,1440,1449,3,148,74,0,1441,
        1442,5,282,0,0,1442,1443,3,146,73,0,1443,1444,5,283,0,0,1444,1449,
        1,0,0,0,1445,1449,5,270,0,0,1446,1449,5,269,0,0,1447,1449,5,271,
        0,0,1448,1436,1,0,0,0,1448,1437,1,0,0,0,1448,1438,1,0,0,0,1448,1439,
        1,0,0,0,1448,1440,1,0,0,0,1448,1441,1,0,0,0,1448,1445,1,0,0,0,1448,
        1446,1,0,0,0,1448,1447,1,0,0,0,1449,147,1,0,0,0,1450,1453,5,80,0,
        0,1451,1452,5,286,0,0,1452,1454,5,268,0,0,1453,1451,1,0,0,0,1453,
        1454,1,0,0,0,1454,149,1,0,0,0,1455,1456,7,30,0,0,1456,151,1,0,0,
        0,1457,1459,5,51,0,0,1458,1460,5,286,0,0,1459,1458,1,0,0,0,1459,
        1460,1,0,0,0,1460,1461,1,0,0,0,1461,1463,3,112,56,0,1462,1464,5,
        286,0,0,1463,1462,1,0,0,0,1463,1464,1,0,0,0,1464,1465,1,0,0,0,1465,
        1466,3,154,77,0,1466,1467,7,31,0,0,1467,153,1,0,0,0,1468,1472,3,
        156,78,0,1469,1472,5,286,0,0,1470,1472,5,287,0,0,1471,1468,1,0,0,
        0,1471,1469,1,0,0,0,1471,1470,1,0,0,0,1472,1475,1,0,0,0,1473,1471,
        1,0,0,0,1473,1474,1,0,0,0,1474,1477,1,0,0,0,1475,1473,1,0,0,0,1476,
        1478,5,285,0,0,1477,1476,1,0,0,0,1477,1478,1,0,0,0,1478,155,1,0,
        0,0,1479,1519,3,8,4,0,1480,1519,3,152,76,0,1481,1519,3,158,79,0,
        1482,1519,3,162,81,0,1483,1519,3,118,59,0,1484,1519,3,124,62,0,1485,
        1519,3,110,55,0,1486,1519,3,106,53,0,1487,1519,3,100,50,0,1488,1519,
        3,104,52,0,1489,1519,3,28,14,0,1490,1519,3,32,16,0,1491,1519,3,44,
        22,0,1492,1519,3,50,25,0,1493,1519,3,40,20,0,1494,1519,3,52,26,0,
        1495,1519,3,56,28,0,1496,1519,3,58,29,0,1497,1519,3,68,34,0,1498,
        1519,3,72,36,0,1499,1519,3,74,37,0,1500,1519,3,76,38,0,1501,1519,
        3,84,42,0,1502,1519,3,86,43,0,1503,1519,3,14,7,0,1504,1519,3,22,
        11,0,1505,1519,3,180,90,0,1506,1519,3,164,82,0,1507,1519,3,26,13,
        0,1508,1519,3,10,5,0,1509,1519,3,38,19,0,1510,1519,3,36,18,0,1511,
        1519,3,90,45,0,1512,1519,3,92,46,0,1513,1519,3,96,48,0,1514,1519,
        3,98,49,0,1515,1519,3,114,57,0,1516,1519,3,116,58,0,1517,1519,3,
        190,95,0,1518,1479,1,0,0,0,1518,1480,1,0,0,0,1518,1481,1,0,0,0,1518,
        1482,1,0,0,0,1518,1483,1,0,0,0,1518,1484,1,0,0,0,1518,1485,1,0,0,
        0,1518,1486,1,0,0,0,1518,1487,1,0,0,0,1518,1488,1,0,0,0,1518,1489,
        1,0,0,0,1518,1490,1,0,0,0,1518,1491,1,0,0,0,1518,1492,1,0,0,0,1518,
        1493,1,0,0,0,1518,1494,1,0,0,0,1518,1495,1,0,0,0,1518,1496,1,0,0,
        0,1518,1497,1,0,0,0,1518,1498,1,0,0,0,1518,1499,1,0,0,0,1518,1500,
        1,0,0,0,1518,1501,1,0,0,0,1518,1502,1,0,0,0,1518,1503,1,0,0,0,1518,
        1504,1,0,0,0,1518,1505,1,0,0,0,1518,1506,1,0,0,0,1518,1507,1,0,0,
        0,1518,1508,1,0,0,0,1518,1509,1,0,0,0,1518,1510,1,0,0,0,1518,1511,
        1,0,0,0,1518,1512,1,0,0,0,1518,1513,1,0,0,0,1518,1514,1,0,0,0,1518,
        1515,1,0,0,0,1518,1516,1,0,0,0,1518,1517,1,0,0,0,1519,157,1,0,0,
        0,1520,1522,5,55,0,0,1521,1523,5,286,0,0,1522,1521,1,0,0,0,1522,
        1523,1,0,0,0,1523,1524,1,0,0,0,1524,1526,5,284,0,0,1525,1527,5,286,
        0,0,1526,1525,1,0,0,0,1526,1527,1,0,0,0,1527,1528,1,0,0,0,1528,1530,
        5,3,0,0,1529,1531,5,286,0,0,1530,1529,1,0,0,0,1530,1531,1,0,0,0,
        1531,1532,1,0,0,0,1532,1534,5,284,0,0,1533,1535,5,286,0,0,1534,1533,
        1,0,0,0,1534,1535,1,0,0,0,1535,1536,1,0,0,0,1536,1538,3,160,80,0,
        1537,1539,5,286,0,0,1538,1537,1,0,0,0,1538,1539,1,0,0,0,1539,1540,
        1,0,0,0,1540,1541,5,56,0,0,1541,159,1,0,0,0,1542,1546,3,4,2,0,1543,
        1546,5,286,0,0,1544,1546,5,287,0,0,1545,1542,1,0,0,0,1545,1543,1,
        0,0,0,1545,1544,1,0,0,0,1546,1549,1,0,0,0,1547,1545,1,0,0,0,1547,
        1548,1,0,0,0,1548,1551,1,0,0,0,1549,1547,1,0,0,0,1550,1552,5,285,
        0,0,1551,1550,1,0,0,0,1551,1552,1,0,0,0,1552,161,1,0,0,0,1553,1555,
        5,63,0,0,1554,1556,5,286,0,0,1555,1554,1,0,0,0,1555,1556,1,0,0,0,
        1556,1558,1,0,0,0,1557,1559,5,263,0,0,1558,1557,1,0,0,0,1558,1559,
        1,0,0,0,1559,1561,1,0,0,0,1560,1562,5,286,0,0,1561,1560,1,0,0,0,
        1561,1562,1,0,0,0,1562,1573,1,0,0,0,1563,1565,5,286,0,0,1564,1563,
        1,0,0,0,1564,1565,1,0,0,0,1565,1566,1,0,0,0,1566,1568,5,290,0,0,
        1567,1569,5,286,0,0,1568,1567,1,0,0,0,1568,1569,1,0,0,0,1569,1570,
        1,0,0,0,1570,1572,5,263,0,0,1571,1564,1,0,0,0,1572,1575,1,0,0,0,
        1573,1571,1,0,0,0,1573,1574,1,0,0,0,1574,1577,1,0,0,0,1575,1573,
        1,0,0,0,1576,1578,5,12,0,0,1577,1576,1,0,0,0,1577,1578,1,0,0,0,1578,
        1580,1,0,0,0,1579,1581,5,287,0,0,1580,1579,1,0,0,0,1580,1581,1,0,
        0,0,1581,1583,1,0,0,0,1582,1584,5,265,0,0,1583,1582,1,0,0,0,1583,
        1584,1,0,0,0,1584,1586,1,0,0,0,1585,1587,5,286,0,0,1586,1585,1,0,
        0,0,1586,1587,1,0,0,0,1587,1589,1,0,0,0,1588,1590,5,28,0,0,1589,
        1588,1,0,0,0,1589,1590,1,0,0,0,1590,1592,1,0,0,0,1591,1593,5,286,
        0,0,1592,1591,1,0,0,0,1592,1593,1,0,0,0,1593,1595,1,0,0,0,1594,1596,
        5,287,0,0,1595,1594,1,0,0,0,1595,1596,1,0,0,0,1596,1598,1,0,0,0,
        1597,1599,5,286,0,0,1598,1597,1,0,0,0,1598,1599,1,0,0,0,1599,1601,
        1,0,0,0,1600,1602,5,284,0,0,1601,1600,1,0,0,0,1601,1602,1,0,0,0,
        1602,1604,1,0,0,0,1603,1605,5,286,0,0,1604,1603,1,0,0,0,1604,1605,
        1,0,0,0,1605,1607,1,0,0,0,1606,1608,5,264,0,0,1607,1606,1,0,0,0,
        1607,1608,1,0,0,0,1608,1610,1,0,0,0,1609,1611,5,276,0,0,1610,1609,
        1,0,0,0,1610,1611,1,0,0,0,1611,1613,1,0,0,0,1612,1614,5,286,0,0,
        1613,1612,1,0,0,0,1613,1614,1,0,0,0,1614,1616,1,0,0,0,1615,1617,
        5,263,0,0,1616,1615,1,0,0,0,1616,1617,1,0,0,0,1617,1619,1,0,0,0,
        1618,1620,3,162,81,0,1619,1618,1,0,0,0,1619,1620,1,0,0,0,1620,163,
        1,0,0,0,1621,1623,5,213,0,0,1622,1624,5,286,0,0,1623,1622,1,0,0,
        0,1623,1624,1,0,0,0,1624,1626,1,0,0,0,1625,1627,5,124,0,0,1626,1625,
        1,0,0,0,1626,1627,1,0,0,0,1627,1629,1,0,0,0,1628,1630,5,286,0,0,
        1629,1628,1,0,0,0,1629,1630,1,0,0,0,1630,1631,1,0,0,0,1631,1633,
        3,20,10,0,1632,1634,5,286,0,0,1633,1632,1,0,0,0,1633,1634,1,0,0,
        0,1634,1636,1,0,0,0,1635,1637,5,264,0,0,1636,1635,1,0,0,0,1636,1637,
        1,0,0,0,1637,1638,1,0,0,0,1638,1641,5,276,0,0,1639,1642,3,146,73,
        0,1640,1642,5,286,0,0,1641,1639,1,0,0,0,1641,1640,1,0,0,0,1642,1643,
        1,0,0,0,1643,1641,1,0,0,0,1643,1644,1,0,0,0,1644,165,1,0,0,0,1645,
        1649,5,43,0,0,1646,1648,3,182,91,0,1647,1646,1,0,0,0,1648,1651,1,
        0,0,0,1649,1647,1,0,0,0,1649,1650,1,0,0,0,1650,1653,1,0,0,0,1651,
        1649,1,0,0,0,1652,1654,5,287,0,0,1653,1652,1,0,0,0,1653,1654,1,0,
        0,0,1654,167,1,0,0,0,1655,1659,5,45,0,0,1656,1658,3,182,91,0,1657,
        1656,1,0,0,0,1658,1661,1,0,0,0,1659,1657,1,0,0,0,1659,1660,1,0,0,
        0,1660,1663,1,0,0,0,1661,1659,1,0,0,0,1662,1664,5,287,0,0,1663,1662,
        1,0,0,0,1663,1664,1,0,0,0,1664,169,1,0,0,0,1665,1669,5,44,0,0,1666,
        1668,3,182,91,0,1667,1666,1,0,0,0,1668,1671,1,0,0,0,1669,1667,1,
        0,0,0,1669,1670,1,0,0,0,1670,1673,1,0,0,0,1671,1669,1,0,0,0,1672,
        1674,5,287,0,0,1673,1672,1,0,0,0,1673,1674,1,0,0,0,1674,171,1,0,
        0,0,1675,1679,5,46,0,0,1676,1678,3,182,91,0,1677,1676,1,0,0,0,1678,
        1681,1,0,0,0,1679,1677,1,0,0,0,1679,1680,1,0,0,0,1680,1683,1,0,0,
        0,1681,1679,1,0,0,0,1682,1684,5,287,0,0,1683,1682,1,0,0,0,1683,1684,
        1,0,0,0,1684,173,1,0,0,0,1685,1687,5,67,0,0,1686,1688,5,286,0,0,
        1687,1686,1,0,0,0,1687,1688,1,0,0,0,1688,1690,1,0,0,0,1689,1691,
        5,124,0,0,1690,1689,1,0,0,0,1690,1691,1,0,0,0,1691,1693,1,0,0,0,
        1692,1694,5,286,0,0,1693,1692,1,0,0,0,1693,1694,1,0,0,0,1694,1695,
        1,0,0,0,1695,1697,3,20,10,0,1696,1698,5,286,0,0,1697,1696,1,0,0,
        0,1697,1698,1,0,0,0,1698,1700,1,0,0,0,1699,1701,5,264,0,0,1700,1699,
        1,0,0,0,1700,1701,1,0,0,0,1701,1702,1,0,0,0,1702,1704,5,276,0,0,
        1703,1705,5,286,0,0,1704,1703,1,0,0,0,1704,1705,1,0,0,0,1705,1706,
        1,0,0,0,1706,1708,3,146,73,0,1707,1709,5,286,0,0,1708,1707,1,0,0,
        0,1708,1709,1,0,0,0,1709,1710,1,0,0,0,1710,1712,3,186,93,0,1711,
        1713,5,286,0,0,1712,1711,1,0,0,0,1712,1713,1,0,0,0,1713,1714,1,0,
        0,0,1714,1716,3,146,73,0,1715,1717,5,286,0,0,1716,1715,1,0,0,0,1716,
        1717,1,0,0,0,1717,1719,1,0,0,0,1718,1720,3,178,89,0,1719,1718,1,
        0,0,0,1719,1720,1,0,0,0,1720,1745,1,0,0,0,1721,1723,5,67,0,0,1722,
        1724,5,286,0,0,1723,1722,1,0,0,0,1723,1724,1,0,0,0,1724,1726,1,0,
        0,0,1725,1727,5,124,0,0,1726,1725,1,0,0,0,1726,1727,1,0,0,0,1727,
        1729,1,0,0,0,1728,1730,5,286,0,0,1729,1728,1,0,0,0,1729,1730,1,0,
        0,0,1730,1731,1,0,0,0,1731,1733,3,20,10,0,1732,1734,5,286,0,0,1733,
        1732,1,0,0,0,1733,1734,1,0,0,0,1734,1736,1,0,0,0,1735,1737,5,264,
        0,0,1736,1735,1,0,0,0,1736,1737,1,0,0,0,1737,1738,1,0,0,0,1738,1740,
        5,276,0,0,1739,1741,5,286,0,0,1740,1739,1,0,0,0,1740,1741,1,0,0,
        0,1741,1742,1,0,0,0,1742,1743,3,146,73,0,1743,1745,1,0,0,0,1744,
        1685,1,0,0,0,1744,1721,1,0,0,0,1745,175,1,0,0,0,1746,1748,5,284,
        0,0,1747,1749,5,286,0,0,1748,1747,1,0,0,0,1748,1749,1,0,0,0,1749,
        1751,1,0,0,0,1750,1752,5,264,0,0,1751,1750,1,0,0,0,1751,1752,1,0,
        0,0,1752,1753,1,0,0,0,1753,1755,5,276,0,0,1754,1756,5,286,0,0,1755,
        1754,1,0,0,0,1755,1756,1,0,0,0,1756,1757,1,0,0,0,1757,1759,3,146,
        73,0,1758,1760,5,286,0,0,1759,1758,1,0,0,0,1759,1760,1,0,0,0,1760,
        1761,1,0,0,0,1761,1763,3,186,93,0,1762,1764,5,286,0,0,1763,1762,
        1,0,0,0,1763,1764,1,0,0,0,1764,1765,1,0,0,0,1765,1767,3,146,73,0,
        1766,1768,5,286,0,0,1767,1766,1,0,0,0,1767,1768,1,0,0,0,1768,1770,
        1,0,0,0,1769,1771,3,178,89,0,1770,1769,1,0,0,0,1770,1771,1,0,0,0,
        1771,177,1,0,0,0,1772,1774,3,186,93,0,1773,1775,5,286,0,0,1774,1773,
        1,0,0,0,1774,1775,1,0,0,0,1775,1776,1,0,0,0,1776,1778,3,146,73,0,
        1777,1779,5,286,0,0,1778,1777,1,0,0,0,1778,1779,1,0,0,0,1779,1781,
        1,0,0,0,1780,1782,3,178,89,0,1781,1780,1,0,0,0,1781,1782,1,0,0,0,
        1782,179,1,0,0,0,1783,1790,3,166,83,0,1784,1790,3,170,85,0,1785,
        1790,3,168,84,0,1786,1790,3,172,86,0,1787,1790,3,174,87,0,1788,1790,
        3,176,88,0,1789,1783,1,0,0,0,1789,1784,1,0,0,0,1789,1785,1,0,0,0,
        1789,1786,1,0,0,0,1789,1787,1,0,0,0,1789,1788,1,0,0,0,1790,181,1,
        0,0,0,1791,1792,7,32,0,0,1792,183,1,0,0,0,1793,1794,7,33,0,0,1794,
        185,1,0,0,0,1795,1796,7,34,0,0,1796,187,1,0,0,0,1797,1798,7,35,0,
        0,1798,189,1,0,0,0,1799,1801,8,36,0,0,1800,1799,1,0,0,0,1801,1802,
        1,0,0,0,1802,1803,1,0,0,0,1802,1800,1,0,0,0,1803,191,1,0,0,0,311,
        196,198,202,207,251,259,267,273,275,281,288,292,298,301,305,308,
        321,323,326,333,337,340,344,350,353,358,363,367,372,374,379,395,
        401,414,416,424,429,431,434,439,441,460,466,475,482,486,489,492,
        495,500,505,509,512,515,519,522,525,528,533,536,540,544,547,551,
        557,564,568,580,584,592,620,622,627,631,640,643,650,653,657,662,
        664,667,679,685,689,693,696,699,702,705,708,711,714,718,721,726,
        733,735,740,750,756,759,764,774,807,809,822,825,834,837,843,851,
        854,860,864,880,882,889,898,901,907,909,924,931,934,937,941,946,
        955,960,963,966,970,975,979,989,994,997,1000,1004,1011,1013,1020,
        1026,1030,1036,1038,1047,1052,1056,1060,1063,1070,1073,1079,1085,
        1091,1094,1098,1101,1106,1112,1126,1133,1139,1144,1147,1150,1153,
        1155,1158,1161,1164,1171,1181,1189,1193,1198,1202,1208,1219,1222,
        1225,1230,1233,1239,1242,1246,1254,1261,1267,1270,1274,1276,1284,
        1288,1293,1300,1305,1307,1313,1316,1324,1327,1332,1335,1341,1344,
        1347,1353,1356,1361,1366,1369,1375,1378,1381,1387,1390,1393,1401,
        1404,1407,1409,1414,1419,1422,1428,1431,1434,1448,1453,1459,1463,
        1471,1473,1477,1518,1522,1526,1530,1534,1538,1545,1547,1551,1555,
        1558,1561,1564,1568,1573,1577,1580,1583,1586,1589,1592,1595,1598,
        1601,1604,1607,1610,1613,1616,1619,1623,1626,1629,1633,1636,1641,
        1643,1649,1653,1659,1663,1669,1673,1679,1683,1687,1690,1693,1697,
        1700,1704,1708,1712,1716,1719,1723,1726,1729,1733,1736,1740,1744,
        1748,1751,1755,1759,1763,1767,1770,1774,1778,1781,1789,1802
    ]

class NaturalParser ( Parser ):

    grammarFileName = "NaturalParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'DEFINE'", "'FUNCTION'", "'RETURNS'", 
                     "'DATA'", "'LOCAL'", "'GLOBAL'", "'PARAMETER'", "'REDEFINE'", 
                     "'PERFORM'", "'CALLNAT'", "'ESCAPE'", "'ESCAPE BOTTOM'", 
                     "'RETURN'", "'IF'", "'THEN'", "'ELSE'", "'ELSE IF'", 
                     "'END-IF'", "'DECIDE'", "'END-DECIDE'", "'WHEN'", "'FOR'", 
                     "'THRU'", "'EVERY'", "'FIRST'", "'CONDITION'", "'ANY'", 
                     "'NONE'", "'ALL'", "'UNIQUE'", "'REPEAT'", "<INVALID>", 
                     "'END-FOR'", "'END'", "'READ'", "'FIND'", "'SELECT'", 
                     "'UPDATE'", "'STORE'", "'DELETE'", "'GET'", "'OBTAIN'", 
                     "'ADD'", "'SUBTRACT'", "'MULTIPLY'", "'DIVIDE'", "'MOVE'", 
                     "'VALUE OF'", "'TO'", "'DO'", "'DEFINE SUBROUTINE'", 
                     "'END-SUBROUTINE'", "'DEFINE SUBPROGRAM'", "'END-SUBPROGRAM'", 
                     "'DEFINE FUNCTION'", "'END-FUNCTION'", "'END-READ'", 
                     "'END-FIND'", "'END-SELECT'", "'END TRANSACTION'", 
                     "'BACKOUT TRANSACTION'", "'END-ALL'", "'VALUE'", "'DOEND'", 
                     "'USING HELP'", "'USING'", "'COMPUTE'", "'INPUT'", 
                     "'MAP'", "'RESET'", "'SET KEY'", "'COMPRESS'", "'NO RECORDS FOUND'", 
                     "'NO RECORD FOUND'", "'END-NOREC'", "'REINPUT'", "'MARK'", 
                     "'WITH TEXT'", "'FULL'", "'POSITION'", "'IN'", "'ALARM'", 
                     "'RECORD'", "'RECORDS'", "'STATEMENT'", "'SET'", "'SAME'", 
                     "'GET TRANSACTION DATA'", "'GET SAME'", "'WITH'", "'ACCEPT IF'", 
                     "'REJECT IF'", "'EXAMINE'", "'SUBSTRING'", "'REPLACE'", 
                     "'GIVING'", "'ABSOLUTE'", "'CHARPOSITION'", "'CHARLENGTH'", 
                     "'LENGTH'", "'NUMBER'", "'TRANSLATE'", "'DELIMITER'", 
                     "'UPPPER CASE'", "'LOWER CASE'", "'INTO'", "'INVERTED'", 
                     "'INDEX'", "'INDEXED'", "'PATTERN'", "'DISPLAY'", "'WRITE'", 
                     "'WRITE TITLE'", "'WRITE TRAILER'", "'FIELD'", "'BY NAME'", 
                     "'BY POSITION'", "'EDITED'", "'LEFT'", "'RIGHT'", "'JUSTIFIED'", 
                     "'NORMALIZED'", "'ENCODED'", "'ROUNDED'", "'SEPARATE'", 
                     "'SORT'", "'END-SORT'", "'FORMAT'", "'SKIP'", "'EJECT'", 
                     "'NEWPAGE'", "'SUSPEND IDENTICAL SUPPRESS'", "'DEFINE PRINTER'", 
                     "'CLOSE PRINTER'", "'DEFINE WINDOW'", "'SET WINDOW'", 
                     "'PROCESS PAGE'", "'PROCESS PAGE USING'", "'PROCESS PAGE UPDATE'", 
                     "'PROCESS PAGE MODAL'", "'IF SELECTION'", "'DECIDE FOR'", 
                     "'DECIDE ON'", "'CALL'", "'CALL FILE'", "'CALL LOOP'", 
                     "'FETCH'", "'PROCESS COMMAND'", "'RUN'", "'DEFINE PROTOTYPE'", 
                     "'Function Call'", "'STOP'", "'TERMINATE'", "'WRITE WORK FILE'", 
                     "'WRITE WORK'", "'DOWNLOAD PC FILE'", "'READ WORK FILE'", 
                     "'READ WORK'", "'UPLOAD PC FILE'", "'CLOSE WORK FILE'", 
                     "'CLOSE WORK'", "'CLOSE PC FILE'", "'DEFINE WORK FILE'", 
                     "'DEFINE CLASS'", "'CREATE OBJECT'", "'SEND METHOD'", 
                     "'INTERFACE'", "'METHOD'", "'PROPERTY'", "'EXPAND'", 
                     "'REDUCE'", "'RESIZE'", "'OPEN CONVERSATION'", "'CLOSE CONVERSATION'", 
                     "'DEFINE DATA CONTEXT'", "'PARSE'", "'REQUEST DOCUMENT'", 
                     "'RETRY'", "'AT START OF DATA'", "'AT END OF DATA'", 
                     "'AT BREAK'", "'BEFORE BREAK PROCESSING'", "'PERFORM BREAK PROCESSING'", 
                     "'CALLDBPROC'", "'COMMIT'", "'PROCESS SQL'", "'READ RESULT SET'", 
                     "'ROLLBACK'", "'WRITE / PRINT'", "'AT TOP OF PAGE'", 
                     "'AT END OF PAGE'", "'DEFINE DATA'", "'END-DEFINE'", 
                     "'INCLUDE'", "'ON ERROR'", "'RELEASE'", "'SET CONTROL'", 
                     "'SET GLOBALS'", "'SET TIME'", "'STACK'", "'ACCEPT'", 
                     "'REJECT'", "'PASSW'", "'LIMIT'", "'INSERT'", "'HISTOGRAM'", 
                     "'END-HISTOGRAM'", "'THEN_DO'", "'IGNORE'", "'FRAC'", 
                     "'FROM'", "'VIEW'", "'ASSIGN'", "'NUMERIC'", "'LEAVING SPACE'", 
                     "<INVALID>", "'END-START'", "'ON'", "'OFF'", "'BY'", 
                     "'INTERFACE4'", "'RETAIN AS'", "'WHERE'", "'STARTING WITH'", 
                     "'COUPLED'", "'VIA'", "'BUT'", "'SORTED'", "'ASCENDING'", 
                     "'DESCENDING'", "'OF'", "'MULTI-FETCH'", "'STARTING FROM'", 
                     "'ENDING AT'", "'VARIABLE'", "'DYNAMIC'", "'SEQUENCE'", 
                     "'END-WORK'", "'OFFSET'", "'FILLER'", "'ONCE'", "'AT END OF FILE'", 
                     "'END-ENDFILE'", "'GT'", "'LT'", "'GE'", "'LE'", "'EQ'", 
                     "'NE'", "'AND'", "'OR'", "'NOT'", "'AND='", "'OR='", 
                     "'OR ='", "'EQUAL'", "'NOTEQUAL'", "'EQUAL TO'", "'LESS THAN'", 
                     "'GREATER THAN'", "'LESS EQUAL'", "'GREATER EQUAL'", 
                     "<INVALID>", "':'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'+'", "'-'", "'*'", "'/'", "'='", "'>'", "'<'", "'>='", 
                     "'<='", "'!='", "'('", "')'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','", "'%'", "'&'", "'|'", "'^'", "'!'", "'~'", "'?'", 
                     "'.'", "'['", "']'", "'{'", "'}'", "'DUMMY_TEXT'" ]

    symbolicNames = [ "<INVALID>", "DEFINE", "FUNCTION", "RETURNS", "DATA", 
                      "LOCAL", "GLOBAL", "PARAMETER", "REDEFINE", "PERFORM", 
                      "CALLNAT", "ESCAPE", "ESCAPE_BOTTOM", "RETURN", "IF", 
                      "THEN", "ELSE", "ELSE_IF", "END_IF", "DECIDE", "END_DECIDE", 
                      "WHEN", "FOR", "THRU", "EVERY", "FIRST", "CONDITION", 
                      "ANY", "NONE", "ALL", "UNIQUE_LEX", "REPEAT", "LOOP", 
                      "END_FOR", "END", "READ", "FIND", "SELECT", "UPDATE", 
                      "STORE", "DELETE", "GET", "OBTAIN", "ADD", "SUBTRACT", 
                      "MULTIPLY", "DIVIDE", "MOVE", "VALUE_OF", "TO", "DO", 
                      "DEFINE_SUBROUTINE", "END_SUBROUTINE", "DEFINE_SUBPROGRAM", 
                      "END_SUBPROGRAM", "DEFINE_FUNCTION", "END_FUNCTION", 
                      "END_READ", "END_FIND", "END_SELECT", "END_TRANSACTION", 
                      "BACKOUT_TRANSACTION", "END_ALL", "VALUE", "DOEND", 
                      "USING_HELP", "USING", "COMPUTE", "INPUT", "MAP", 
                      "RESET", "SET_KEY", "COMPRESS", "NO_RECORDS_FOUND", 
                      "NO_RECORD_FOUND", "END_NOREC", "REINPUT", "MARK", 
                      "WITH_TEXT", "FULL", "POSITION", "IN", "ALARM", "RECORD", 
                      "RECORDS", "STATEMENT", "SET", "SAME", "GET_TRANSACTION_DATA", 
                      "GET_SAME", "WITH", "ACCEPT_IF", "REJECT_IF", "EXAMINE", 
                      "SUBSTRING", "REPLACE", "GIVING", "ABSOLUTE", "CHARPOSITION", 
                      "CHARLENGTH", "LENGTH", "NUMBER", "TRANSLATE", "DELIMITER", 
                      "UPPPER_CASE", "LOWER_CASE", "INTO", "INVERTED", "INDEX", 
                      "INDEXED", "PATTERN", "DISPLAY", "WRITE", "WRITE_TITLE", 
                      "WRITE_TRAILER", "FIELD", "BY_NAME", "BY_POSITION", 
                      "EDITED", "LEFT", "RIGHT", "JUSTIFIED", "NORMALIZED", 
                      "ENCODED", "ROUNDED", "SEPARATE", "SORT", "END_SORT", 
                      "FORMAT", "SKIP_LEX", "EJECT", "NEWPAGE", "SUSPEND_IDENTICAL_SUPPRESS", 
                      "DEFINE_PRINTER", "CLOSE_PRINTER", "DEFINE_WINDOW", 
                      "SET_WINDOW", "PROCESS_PAGE", "PROCESS_PAGE_USING", 
                      "PROCESS_PAGE_UPDATE", "PROCESS_PAGE_MODAL", "IF_SELECTION", 
                      "DECIDE_FOR", "DECIDE_ON", "CALL", "CALL_FILE", "CALL_LOOP", 
                      "FETCH", "PROCESS_COMMAND", "RUN", "DEFINE_PROTOTYPE", 
                      "FUNCTION_CALL", "STOP", "TERMINATE", "WRITE_WORK_FILE", 
                      "WRITE_WORK", "DOWNLOAD_PC_FILE", "READ_WORK_FILE", 
                      "READ_WORK", "UPLOAD_PC_FILE", "CLOSE_WORK_FILE", 
                      "CLOSE_WORK", "CLOSE_PC_FILE", "DEFINE_WORK_FILE", 
                      "DEFINE_CLASS", "CREATE_OBJECT", "SEND_METHOD", "INTERFACE", 
                      "METHOD", "PROPERTY", "EXPAND", "REDUCE", "RESIZE", 
                      "OPEN_CONVERSATION", "CLOSE_CONVERSATION", "DEFINE_DATA_CONTEXT", 
                      "PARSE", "REQUEST_DOCUMENT", "RETRY", "AT_START_OF_DATA", 
                      "AT_END_OF_DATA", "AT_BREAK", "BEFORE_BREAK_PROCESSING", 
                      "PERFORM_BREAK_PROCESSING", "CALLDBPROC", "COMMIT", 
                      "PROCESS_SQL", "READ_RESULT_SET", "ROLLBACK", "WRITE_PRINT", 
                      "AT_TOP_OF_PAGE", "AT_END_OF_PAGE", "DEFINE_DATA", 
                      "END_DEFINE", "INCLUDE", "ON_ERROR", "RELEASE", "SET_CONTROL", 
                      "SET_GLOBALS", "SET_TIME", "STACK", "ACCEPT", "REJECT", 
                      "PASSW", "LIMIT", "INSERT", "HISTOGRAM", "END_HISTOGRAM", 
                      "THEN_DO", "IGNORE", "FRAC", "FROM", "VIEW", "ASSIGN", 
                      "NUMERIC", "LEAVING_SPACE", "LEAVING_NO_SPACE", "END_START", 
                      "ON", "OFF", "BY", "INTERFACE4", "RETAIN_AS", "WHERE", 
                      "STARTING_WITH", "COUPLED", "VIA", "BUT", "SORTED", 
                      "ASCENDING", "DESCENDING", "OF", "MULTI_FETCH", "STARTING_FROM", 
                      "ENDING_AT", "VARIABLE", "DYNAMIC", "SEQUENCE", "END_WORK", 
                      "OFFSET", "FILLER", "ONCE", "AT_END_OF_FILE", "END_ENDFILE", 
                      "GT_TEXT", "LT_TEXT", "GE_TEXT", "LE_TEXT", "EQ_TEXT", 
                      "NE_TEXT", "AND_TEXT", "OR_TEXT", "NOT_TEXT", "AND_EQ", 
                      "OR_RQ", "OR_SRQ", "EQUAL", "NOTEQUAL", "EQUAL_TO", 
                      "LESS_THAN", "GREATER_THAN", "LESS_EQUAL", "GREATER_EQUAL", 
                      "STRING", "COLON", "LINE_NUMBER", "FLOAT", "LITERAL", 
                      "LINE_REF", "INPUT_PARAM", "DATE_CONSTANT", "H_CONSTANT", 
                      "PLUS", "MINUS", "MULT", "DIV", "EQ", "GT", "LT", 
                      "GE", "LE", "NE", "LPAREN", "RPAREN", "IDENTIFIER", 
                      "TRAILING_COMMENT", "WS", "NL", "WS_C", "NL_C", "COMMA", 
                      "MOD", "AND", "OR", "XOR", "NOT", "TILDE", "QUESTION", 
                      "DOT", "LBRACK", "RBRACK", "LBRACE", "RBRACE", "LABEL" ]

    RULE_program = 0
    RULE_lineNumberStatement = 1
    RULE_statement = 2
    RULE_label = 3
    RULE_dataDefinition = 4
    RULE_compressStatement = 5
    RULE_compressEnd = 6
    RULE_inputStatement = 7
    RULE_inputOptions = 8
    RULE_inputUsingMap = 9
    RULE_variable = 10
    RULE_reinputStatement = 11
    RULE_reinputOptions = 12
    RULE_sortStatement = 13
    RULE_examineStatement = 14
    RULE_examineOptions = 15
    RULE_moveStatement = 16
    RULE_moveOptions = 17
    RULE_repeatStatement = 18
    RULE_doStatement = 19
    RULE_storeStatement = 20
    RULE_storeCondition = 21
    RULE_findStatement = 22
    RULE_findOptions = 23
    RULE_findNumber = 24
    RULE_readStatement = 25
    RULE_updateStatement = 26
    RULE_updateStartline = 27
    RULE_deleteStatement = 28
    RULE_getStatements = 29
    RULE_getTabledStatements = 30
    RULE_getTabledOptions = 31
    RULE_getTransactionStatement = 32
    RULE_getSameStatement = 33
    RULE_histogramStatement = 34
    RULE_histogramOptions = 35
    RULE_endTransaction = 36
    RULE_backoutTransaction = 37
    RULE_readworkfileStatement = 38
    RULE_workfilenumberOption = 39
    RULE_readworkfileOptions = 40
    RULE_atEndOfFileStatement = 41
    RULE_writeworkfileStatement = 42
    RULE_closeworkfileStatement = 43
    RULE_noRecordsFoundStatement = 44
    RULE_atStartOfDataStatement = 45
    RULE_formatStatement = 46
    RULE_formatOptions = 47
    RULE_assignmentStatement = 48
    RULE_includeStatement = 49
    RULE_redefineStatement = 50
    RULE_redefineBody = 51
    RULE_resetStatement = 52
    RULE_callnatStatement = 53
    RULE_setkeyStatement = 54
    RULE_performStatement = 55
    RULE_subroutineNames = 56
    RULE_fetchStatement = 57
    RULE_callStatement = 58
    RULE_forStatement = 59
    RULE_acceptRejectIfStatement = 60
    RULE_decisionStatement = 61
    RULE_ifStatement = 62
    RULE_ifStructuredStatement = 63
    RULE_elseStructured = 64
    RULE_ifElseStatement = 65
    RULE_ifMultilinedStatement = 66
    RULE_ifSinglelinedStatement = 67
    RULE_elseMultilinedStatement = 68
    RULE_elseSinglelinedStatement = 69
    RULE_onelinerBody = 70
    RULE_condition = 71
    RULE_optionalCondition = 72
    RULE_operand = 73
    RULE_naturalKeywords = 74
    RULE_logicalOp = 75
    RULE_subroutine = 76
    RULE_blockContentSubroutine = 77
    RULE_subroutineStatement = 78
    RULE_functionDefinition = 79
    RULE_blockContent = 80
    RULE_valueAssignment = 81
    RULE_assignStatement = 82
    RULE_addOperation = 83
    RULE_multiplyOperation = 84
    RULE_subtractOperation = 85
    RULE_divideOperation = 86
    RULE_computeOperation = 87
    RULE_arithmaticOperation = 88
    RULE_optionalCompute = 89
    RULE_calculations = 90
    RULE_addContent = 91
    RULE_compOp = 92
    RULE_arithmaticOp = 93
    RULE_endStatement = 94
    RULE_otherStatement = 95

    ruleNames =  [ "program", "lineNumberStatement", "statement", "label", 
                   "dataDefinition", "compressStatement", "compressEnd", 
                   "inputStatement", "inputOptions", "inputUsingMap", "variable", 
                   "reinputStatement", "reinputOptions", "sortStatement", 
                   "examineStatement", "examineOptions", "moveStatement", 
                   "moveOptions", "repeatStatement", "doStatement", "storeStatement", 
                   "storeCondition", "findStatement", "findOptions", "findNumber", 
                   "readStatement", "updateStatement", "updateStartline", 
                   "deleteStatement", "getStatements", "getTabledStatements", 
                   "getTabledOptions", "getTransactionStatement", "getSameStatement", 
                   "histogramStatement", "histogramOptions", "endTransaction", 
                   "backoutTransaction", "readworkfileStatement", "workfilenumberOption", 
                   "readworkfileOptions", "atEndOfFileStatement", "writeworkfileStatement", 
                   "closeworkfileStatement", "noRecordsFoundStatement", 
                   "atStartOfDataStatement", "formatStatement", "formatOptions", 
                   "assignmentStatement", "includeStatement", "redefineStatement", 
                   "redefineBody", "resetStatement", "callnatStatement", 
                   "setkeyStatement", "performStatement", "subroutineNames", 
                   "fetchStatement", "callStatement", "forStatement", "acceptRejectIfStatement", 
                   "decisionStatement", "ifStatement", "ifStructuredStatement", 
                   "elseStructured", "ifElseStatement", "ifMultilinedStatement", 
                   "ifSinglelinedStatement", "elseMultilinedStatement", 
                   "elseSinglelinedStatement", "onelinerBody", "condition", 
                   "optionalCondition", "operand", "naturalKeywords", "logicalOp", 
                   "subroutine", "blockContentSubroutine", "subroutineStatement", 
                   "functionDefinition", "blockContent", "valueAssignment", 
                   "assignStatement", "addOperation", "multiplyOperation", 
                   "subtractOperation", "divideOperation", "computeOperation", 
                   "arithmaticOperation", "optionalCompute", "calculations", 
                   "addContent", "compOp", "arithmaticOp", "endStatement", 
                   "otherStatement" ]

    EOF = Token.EOF
    DEFINE=1
    FUNCTION=2
    RETURNS=3
    DATA=4
    LOCAL=5
    GLOBAL=6
    PARAMETER=7
    REDEFINE=8
    PERFORM=9
    CALLNAT=10
    ESCAPE=11
    ESCAPE_BOTTOM=12
    RETURN=13
    IF=14
    THEN=15
    ELSE=16
    ELSE_IF=17
    END_IF=18
    DECIDE=19
    END_DECIDE=20
    WHEN=21
    FOR=22
    THRU=23
    EVERY=24
    FIRST=25
    CONDITION=26
    ANY=27
    NONE=28
    ALL=29
    UNIQUE_LEX=30
    REPEAT=31
    LOOP=32
    END_FOR=33
    END=34
    READ=35
    FIND=36
    SELECT=37
    UPDATE=38
    STORE=39
    DELETE=40
    GET=41
    OBTAIN=42
    ADD=43
    SUBTRACT=44
    MULTIPLY=45
    DIVIDE=46
    MOVE=47
    VALUE_OF=48
    TO=49
    DO=50
    DEFINE_SUBROUTINE=51
    END_SUBROUTINE=52
    DEFINE_SUBPROGRAM=53
    END_SUBPROGRAM=54
    DEFINE_FUNCTION=55
    END_FUNCTION=56
    END_READ=57
    END_FIND=58
    END_SELECT=59
    END_TRANSACTION=60
    BACKOUT_TRANSACTION=61
    END_ALL=62
    VALUE=63
    DOEND=64
    USING_HELP=65
    USING=66
    COMPUTE=67
    INPUT=68
    MAP=69
    RESET=70
    SET_KEY=71
    COMPRESS=72
    NO_RECORDS_FOUND=73
    NO_RECORD_FOUND=74
    END_NOREC=75
    REINPUT=76
    MARK=77
    WITH_TEXT=78
    FULL=79
    POSITION=80
    IN=81
    ALARM=82
    RECORD=83
    RECORDS=84
    STATEMENT=85
    SET=86
    SAME=87
    GET_TRANSACTION_DATA=88
    GET_SAME=89
    WITH=90
    ACCEPT_IF=91
    REJECT_IF=92
    EXAMINE=93
    SUBSTRING=94
    REPLACE=95
    GIVING=96
    ABSOLUTE=97
    CHARPOSITION=98
    CHARLENGTH=99
    LENGTH=100
    NUMBER=101
    TRANSLATE=102
    DELIMITER=103
    UPPPER_CASE=104
    LOWER_CASE=105
    INTO=106
    INVERTED=107
    INDEX=108
    INDEXED=109
    PATTERN=110
    DISPLAY=111
    WRITE=112
    WRITE_TITLE=113
    WRITE_TRAILER=114
    FIELD=115
    BY_NAME=116
    BY_POSITION=117
    EDITED=118
    LEFT=119
    RIGHT=120
    JUSTIFIED=121
    NORMALIZED=122
    ENCODED=123
    ROUNDED=124
    SEPARATE=125
    SORT=126
    END_SORT=127
    FORMAT=128
    SKIP_LEX=129
    EJECT=130
    NEWPAGE=131
    SUSPEND_IDENTICAL_SUPPRESS=132
    DEFINE_PRINTER=133
    CLOSE_PRINTER=134
    DEFINE_WINDOW=135
    SET_WINDOW=136
    PROCESS_PAGE=137
    PROCESS_PAGE_USING=138
    PROCESS_PAGE_UPDATE=139
    PROCESS_PAGE_MODAL=140
    IF_SELECTION=141
    DECIDE_FOR=142
    DECIDE_ON=143
    CALL=144
    CALL_FILE=145
    CALL_LOOP=146
    FETCH=147
    PROCESS_COMMAND=148
    RUN=149
    DEFINE_PROTOTYPE=150
    FUNCTION_CALL=151
    STOP=152
    TERMINATE=153
    WRITE_WORK_FILE=154
    WRITE_WORK=155
    DOWNLOAD_PC_FILE=156
    READ_WORK_FILE=157
    READ_WORK=158
    UPLOAD_PC_FILE=159
    CLOSE_WORK_FILE=160
    CLOSE_WORK=161
    CLOSE_PC_FILE=162
    DEFINE_WORK_FILE=163
    DEFINE_CLASS=164
    CREATE_OBJECT=165
    SEND_METHOD=166
    INTERFACE=167
    METHOD=168
    PROPERTY=169
    EXPAND=170
    REDUCE=171
    RESIZE=172
    OPEN_CONVERSATION=173
    CLOSE_CONVERSATION=174
    DEFINE_DATA_CONTEXT=175
    PARSE=176
    REQUEST_DOCUMENT=177
    RETRY=178
    AT_START_OF_DATA=179
    AT_END_OF_DATA=180
    AT_BREAK=181
    BEFORE_BREAK_PROCESSING=182
    PERFORM_BREAK_PROCESSING=183
    CALLDBPROC=184
    COMMIT=185
    PROCESS_SQL=186
    READ_RESULT_SET=187
    ROLLBACK=188
    WRITE_PRINT=189
    AT_TOP_OF_PAGE=190
    AT_END_OF_PAGE=191
    DEFINE_DATA=192
    END_DEFINE=193
    INCLUDE=194
    ON_ERROR=195
    RELEASE=196
    SET_CONTROL=197
    SET_GLOBALS=198
    SET_TIME=199
    STACK=200
    ACCEPT=201
    REJECT=202
    PASSW=203
    LIMIT=204
    INSERT=205
    HISTOGRAM=206
    END_HISTOGRAM=207
    THEN_DO=208
    IGNORE=209
    FRAC=210
    FROM=211
    VIEW=212
    ASSIGN=213
    NUMERIC=214
    LEAVING_SPACE=215
    LEAVING_NO_SPACE=216
    END_START=217
    ON=218
    OFF=219
    BY=220
    INTERFACE4=221
    RETAIN_AS=222
    WHERE=223
    STARTING_WITH=224
    COUPLED=225
    VIA=226
    BUT=227
    SORTED=228
    ASCENDING=229
    DESCENDING=230
    OF=231
    MULTI_FETCH=232
    STARTING_FROM=233
    ENDING_AT=234
    VARIABLE=235
    DYNAMIC=236
    SEQUENCE=237
    END_WORK=238
    OFFSET=239
    FILLER=240
    ONCE=241
    AT_END_OF_FILE=242
    END_ENDFILE=243
    GT_TEXT=244
    LT_TEXT=245
    GE_TEXT=246
    LE_TEXT=247
    EQ_TEXT=248
    NE_TEXT=249
    AND_TEXT=250
    OR_TEXT=251
    NOT_TEXT=252
    AND_EQ=253
    OR_RQ=254
    OR_SRQ=255
    EQUAL=256
    NOTEQUAL=257
    EQUAL_TO=258
    LESS_THAN=259
    GREATER_THAN=260
    LESS_EQUAL=261
    GREATER_EQUAL=262
    STRING=263
    COLON=264
    LINE_NUMBER=265
    FLOAT=266
    LITERAL=267
    LINE_REF=268
    INPUT_PARAM=269
    DATE_CONSTANT=270
    H_CONSTANT=271
    PLUS=272
    MINUS=273
    MULT=274
    DIV=275
    EQ=276
    GT=277
    LT=278
    GE=279
    LE=280
    NE=281
    LPAREN=282
    RPAREN=283
    IDENTIFIER=284
    TRAILING_COMMENT=285
    WS=286
    NL=287
    WS_C=288
    NL_C=289
    COMMA=290
    MOD=291
    AND=292
    OR=293
    XOR=294
    NOT=295
    TILDE=296
    QUESTION=297
    DOT=298
    LBRACK=299
    RBRACK=300
    LBRACE=301
    RBRACE=302
    LABEL=303

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.11.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lineNumberStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LineNumberStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LineNumberStatementContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_program




    def program(self):

        localctx = NaturalParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 196
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 192
                    self.lineNumberStatement()
                    pass

                elif la_ == 2:
                    self.state = 193
                    self.statement()
                    pass

                elif la_ == 3:
                    self.state = 194
                    self.match(NaturalParser.WS)
                    pass

                elif la_ == 4:
                    self.state = 195
                    self.match(NaturalParser.NL)
                    pass


                self.state = 198 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineNumberStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def statement(self):
            return self.getTypedRuleContext(NaturalParser.StatementContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_lineNumberStatement




    def lineNumberStatement(self):

        localctx = NaturalParser.LineNumberStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_lineNumberStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(NaturalParser.LINE_NUMBER)
            self.state = 202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 201
                self.match(NaturalParser.WS)


            self.state = 204
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataDefinition(self):
            return self.getTypedRuleContext(NaturalParser.DataDefinitionContext,0)


        def subroutine(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(NaturalParser.FunctionDefinitionContext,0)


        def noRecordsFoundStatement(self):
            return self.getTypedRuleContext(NaturalParser.NoRecordsFoundStatementContext,0)


        def decisionStatement(self):
            return self.getTypedRuleContext(NaturalParser.DecisionStatementContext,0)


        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(NaturalParser.ForStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStatementContext,0)


        def performStatement(self):
            return self.getTypedRuleContext(NaturalParser.PerformStatementContext,0)


        def callnatStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallnatStatementContext,0)


        def examineStatement(self):
            return self.getTypedRuleContext(NaturalParser.ExamineStatementContext,0)


        def moveStatement(self):
            return self.getTypedRuleContext(NaturalParser.MoveStatementContext,0)


        def findStatement(self):
            return self.getTypedRuleContext(NaturalParser.FindStatementContext,0)


        def readStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadStatementContext,0)


        def storeStatement(self):
            return self.getTypedRuleContext(NaturalParser.StoreStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(NaturalParser.DeleteStatementContext,0)


        def getStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetStatementsContext,0)


        def histogramStatement(self):
            return self.getTypedRuleContext(NaturalParser.HistogramStatementContext,0)


        def endTransaction(self):
            return self.getTypedRuleContext(NaturalParser.EndTransactionContext,0)


        def backoutTransaction(self):
            return self.getTypedRuleContext(NaturalParser.BackoutTransactionContext,0)


        def readworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileStatementContext,0)


        def writeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.WriteworkfileStatementContext,0)


        def closeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.CloseworkfileStatementContext,0)


        def inputStatement(self):
            return self.getTypedRuleContext(NaturalParser.InputStatementContext,0)


        def reinputStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReinputStatementContext,0)


        def calculations(self):
            return self.getTypedRuleContext(NaturalParser.CalculationsContext,0)


        def assignStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignStatementContext,0)


        def setkeyStatement(self):
            return self.getTypedRuleContext(NaturalParser.SetkeyStatementContext,0)


        def redefineStatement(self):
            return self.getTypedRuleContext(NaturalParser.RedefineStatementContext,0)


        def resetStatement(self):
            return self.getTypedRuleContext(NaturalParser.ResetStatementContext,0)


        def sortStatement(self):
            return self.getTypedRuleContext(NaturalParser.SortStatementContext,0)


        def compressStatement(self):
            return self.getTypedRuleContext(NaturalParser.CompressStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def repeatStatement(self):
            return self.getTypedRuleContext(NaturalParser.RepeatStatementContext,0)


        def atStartOfDataStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtStartOfDataStatementContext,0)


        def formatStatement(self):
            return self.getTypedRuleContext(NaturalParser.FormatStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,0)


        def includeStatement(self):
            return self.getTypedRuleContext(NaturalParser.IncludeStatementContext,0)


        def fetchStatement(self):
            return self.getTypedRuleContext(NaturalParser.FetchStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallStatementContext,0)


        def otherStatement(self):
            return self.getTypedRuleContext(NaturalParser.OtherStatementContext,0)


        def label(self):
            return self.getTypedRuleContext(NaturalParser.LabelContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_statement




    def statement(self):

        localctx = NaturalParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 206
                self.label()


            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 209
                self.dataDefinition()
                pass

            elif la_ == 2:
                self.state = 210
                self.subroutine()
                pass

            elif la_ == 3:
                self.state = 211
                self.functionDefinition()
                pass

            elif la_ == 4:
                self.state = 212
                self.noRecordsFoundStatement()
                pass

            elif la_ == 5:
                self.state = 213
                self.decisionStatement()
                pass

            elif la_ == 6:
                self.state = 214
                self.valueAssignment()
                pass

            elif la_ == 7:
                self.state = 215
                self.forStatement()
                pass

            elif la_ == 8:
                self.state = 216
                self.ifStatement()
                pass

            elif la_ == 9:
                self.state = 217
                self.performStatement()
                pass

            elif la_ == 10:
                self.state = 218
                self.callnatStatement()
                pass

            elif la_ == 11:
                self.state = 219
                self.examineStatement()
                pass

            elif la_ == 12:
                self.state = 220
                self.moveStatement()
                pass

            elif la_ == 13:
                self.state = 221
                self.findStatement()
                pass

            elif la_ == 14:
                self.state = 222
                self.readStatement()
                pass

            elif la_ == 15:
                self.state = 223
                self.storeStatement()
                pass

            elif la_ == 16:
                self.state = 224
                self.updateStatement()
                pass

            elif la_ == 17:
                self.state = 225
                self.deleteStatement()
                pass

            elif la_ == 18:
                self.state = 226
                self.getStatements()
                pass

            elif la_ == 19:
                self.state = 227
                self.histogramStatement()
                pass

            elif la_ == 20:
                self.state = 228
                self.endTransaction()
                pass

            elif la_ == 21:
                self.state = 229
                self.backoutTransaction()
                pass

            elif la_ == 22:
                self.state = 230
                self.readworkfileStatement()
                pass

            elif la_ == 23:
                self.state = 231
                self.writeworkfileStatement()
                pass

            elif la_ == 24:
                self.state = 232
                self.closeworkfileStatement()
                pass

            elif la_ == 25:
                self.state = 233
                self.inputStatement()
                pass

            elif la_ == 26:
                self.state = 234
                self.reinputStatement()
                pass

            elif la_ == 27:
                self.state = 235
                self.calculations()
                pass

            elif la_ == 28:
                self.state = 236
                self.assignStatement()
                pass

            elif la_ == 29:
                self.state = 237
                self.setkeyStatement()
                pass

            elif la_ == 30:
                self.state = 238
                self.redefineStatement()
                pass

            elif la_ == 31:
                self.state = 239
                self.resetStatement()
                pass

            elif la_ == 32:
                self.state = 240
                self.sortStatement()
                pass

            elif la_ == 33:
                self.state = 241
                self.compressStatement()
                pass

            elif la_ == 34:
                self.state = 242
                self.doStatement()
                pass

            elif la_ == 35:
                self.state = 243
                self.repeatStatement()
                pass

            elif la_ == 36:
                self.state = 244
                self.atStartOfDataStatement()
                pass

            elif la_ == 37:
                self.state = 245
                self.formatStatement()
                pass

            elif la_ == 38:
                self.state = 246
                self.assignmentStatement()
                pass

            elif la_ == 39:
                self.state = 247
                self.includeStatement()
                pass

            elif la_ == 40:
                self.state = 248
                self.fetchStatement()
                pass

            elif la_ == 41:
                self.state = 249
                self.callStatement()
                pass

            elif la_ == 42:
                self.state = 250
                self.otherStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(NaturalParser.LABEL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_label




    def label(self):

        localctx = NaturalParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(NaturalParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_DATA(self):
            return self.getToken(NaturalParser.DEFINE_DATA, 0)

        def END_DEFINE(self):
            return self.getToken(NaturalParser.END_DEFINE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_dataDefinition




    def dataDefinition(self):

        localctx = NaturalParser.DataDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dataDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.match(NaturalParser.DEFINE_DATA)
            self.state = 257 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 256
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 259 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 261
            self.match(NaturalParser.END_DEFINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompressStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPRESS(self):
            return self.getToken(NaturalParser.COMPRESS, 0)

        def INTO(self):
            return self.getToken(NaturalParser.INTO, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def compressEnd(self):
            return self.getTypedRuleContext(NaturalParser.CompressEndContext,0)


        def NUMERIC(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NUMERIC)
            else:
                return self.getToken(NaturalParser.NUMERIC, i)

        def FULL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FULL)
            else:
                return self.getToken(NaturalParser.FULL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_compressStatement




    def compressStatement(self):

        localctx = NaturalParser.CompressStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_compressStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 263
            self.match(NaturalParser.COMPRESS)
            self.state = 267
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 264
                    _la = self._input.LA(1)
                    if not(_la==79 or _la==214 or _la==286):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 269
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 273 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 273
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [80, 263, 265, 266, 269, 270, 271, 282, 284]:
                    self.state = 270
                    self.operand()
                    pass
                elif token in [286]:
                    self.state = 271
                    self.match(NaturalParser.WS)
                    pass
                elif token in [287]:
                    self.state = 272
                    self.match(NaturalParser.NL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 275 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==80 or (((_la - 263)) & ~0x3f) == 0 and ((1 << (_la - 263)) & 27787725) != 0):
                    break

            self.state = 277
            self.match(NaturalParser.INTO)
            self.state = 281
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 278
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 283
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 284
            self.operand()
            self.state = 292
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 288
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                    self.state = 285
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 290
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 291
                self.compressEnd()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompressEndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEAVING_SPACE(self):
            return self.getToken(NaturalParser.LEAVING_SPACE, 0)

        def LEAVING_NO_SPACE(self):
            return self.getToken(NaturalParser.LEAVING_NO_SPACE, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def DELIMITER(self):
            return self.getToken(NaturalParser.DELIMITER, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_compressEnd




    def compressEnd(self):

        localctx = NaturalParser.CompressEndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_compressEnd)
        self._la = 0 # Token type
        try:
            self.state = 308
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 294
                self.match(NaturalParser.LEAVING_SPACE)
                pass
            elif token in [216]:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.match(NaturalParser.LEAVING_NO_SPACE)
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 3)
                self.state = 296
                self.match(NaturalParser.WITH)
                self.state = 301
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29 or _la==286:
                    self.state = 298
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 297
                        self.match(NaturalParser.WS)


                    self.state = 300
                    self.match(NaturalParser.ALL)


                self.state = 303
                self.match(NaturalParser.DELIMITER)
                self.state = 305
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 304
                    self.match(NaturalParser.WS)


                self.state = 307
                self.match(NaturalParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INPUT(self):
            return self.getToken(NaturalParser.INPUT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def inputUsingMap(self):
            return self.getTypedRuleContext(NaturalParser.InputUsingMapContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def inputOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.InputOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.InputOptionsContext,i)


        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DIV)
            else:
                return self.getToken(NaturalParser.DIV, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputStatement




    def inputStatement(self):

        localctx = NaturalParser.InputStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_inputStatement)
        try:
            self.state = 326
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 310
                self.match(NaturalParser.INPUT)
                self.state = 311
                self.match(NaturalParser.WS)
                self.state = 312
                self.inputUsingMap()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 313
                self.match(NaturalParser.INPUT)
                self.state = 321 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 321
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [263]:
                            self.state = 314
                            self.match(NaturalParser.STRING)
                            pass
                        elif token in [284]:
                            self.state = 315
                            self.variable()
                            pass
                        elif token in [77, 80, 81, 115]:
                            self.state = 316
                            self.inputOptions()
                            pass
                        elif token in [275]:
                            self.state = 317
                            self.match(NaturalParser.DIV)
                            pass
                        elif token in [286]:
                            self.state = 318
                            self.match(NaturalParser.WS)
                            pass
                        elif token in [265]:
                            self.state = 319
                            self.match(NaturalParser.LINE_NUMBER)
                            pass
                        elif token in [287]:
                            self.state = 320
                            self.match(NaturalParser.NL)
                            pass
                        else:
                            raise NoViableAltException(self)


                    else:
                        raise NoViableAltException(self)
                    self.state = 323 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

                self.state = 325
                self.match(NaturalParser.NL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MARK(self):
            return self.getToken(NaturalParser.MARK, 0)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def FIELD(self):
            return self.getToken(NaturalParser.FIELD, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputOptions




    def inputOptions(self):

        localctx = NaturalParser.InputOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_inputOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 328
            _la = self._input.LA(1)
            if not((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & 274877906969) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputUsingMapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(NaturalParser.MAP, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputUsingMap




    def inputUsingMap(self):

        localctx = NaturalParser.InputUsingMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_inputUsingMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 333
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 330
                    self.statement() 
                self.state = 335
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

            self.state = 337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 336
                self.match(NaturalParser.USING)


            self.state = 340
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 339
                self.match(NaturalParser.WS)


            self.state = 342
            self.match(NaturalParser.MAP)
            self.state = 344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 343
                self.match(NaturalParser.WS)


            self.state = 346
            self.match(NaturalParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def DOT(self):
            return self.getToken(NaturalParser.DOT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_variable




    def variable(self):

        localctx = NaturalParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        self._la = 0 # Token type
        try:
            self.state = 358
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 348
                self.match(NaturalParser.IDENTIFIER)
                self.state = 353
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                if la_ == 1:
                    self.state = 350
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 349
                        self.match(NaturalParser.WS)


                    self.state = 352
                    _la = self._input.LA(1)
                    if not(_la==268 or _la==284):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 355
                self.match(NaturalParser.IDENTIFIER)
                self.state = 356
                self.match(NaturalParser.DOT)
                self.state = 357
                self.match(NaturalParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReinputStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REINPUT(self):
            return self.getToken(NaturalParser.REINPUT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def FULL(self):
            return self.getToken(NaturalParser.FULL, 0)

        def reinputOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.ReinputOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.ReinputOptionsContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def ALARM(self):
            return self.getToken(NaturalParser.ALARM, 0)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_reinputStatement




    def reinputStatement(self):

        localctx = NaturalParser.ReinputStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_reinputStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(NaturalParser.REINPUT)
            self.state = 363
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 361
                self.match(NaturalParser.WS)
                self.state = 362
                self.match(NaturalParser.FULL)


            self.state = 374
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 372
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [65, 77, 78, 263, 265, 284]:
                        self.state = 367
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==265:
                            self.state = 365
                            self.match(NaturalParser.LINE_NUMBER)
                            self.state = 366
                            self.match(NaturalParser.WS)


                        self.state = 369
                        self.reinputOptions()
                        pass
                    elif token in [286]:
                        self.state = 370
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 371
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 376
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

            self.state = 379
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 377
                self.match(NaturalParser.WS)
                self.state = 378
                self.match(NaturalParser.ALARM)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReinputOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MARK(self):
            return self.getToken(NaturalParser.MARK, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WITH_TEXT(self):
            return self.getToken(NaturalParser.WITH_TEXT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def USING_HELP(self):
            return self.getToken(NaturalParser.USING_HELP, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_reinputOptions




    def reinputOptions(self):

        localctx = NaturalParser.ReinputOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_reinputOptions)
        try:
            self.state = 395
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 381
                self.match(NaturalParser.MARK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 382
                self.match(NaturalParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 383
                self.match(NaturalParser.WITH_TEXT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 384
                self.match(NaturalParser.MARK)
                self.state = 385
                self.match(NaturalParser.WS)
                self.state = 386
                self.match(NaturalParser.POSITION)
                self.state = 387
                self.match(NaturalParser.WS)
                self.state = 388
                self.match(NaturalParser.LINE_NUMBER)
                self.state = 389
                self.match(NaturalParser.WS)
                self.state = 390
                self.match(NaturalParser.IN)
                self.state = 391
                self.match(NaturalParser.WS)
                self.state = 392
                self.match(NaturalParser.IDENTIFIER)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 393
                self.match(NaturalParser.USING_HELP)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 394
                self.match(NaturalParser.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SORT(self):
            return self.getToken(NaturalParser.SORT, 0)

        def END_SORT(self):
            return self.getToken(NaturalParser.END_SORT, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_sortStatement




    def sortStatement(self):

        localctx = NaturalParser.SortStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sortStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self.match(NaturalParser.SORT)
            self.state = 401
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 398
                    self.statement() 
                self.state = 403
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

            self.state = 404
            self.match(NaturalParser.END_SORT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExamineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXAMINE(self):
            return self.getToken(NaturalParser.EXAMINE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def examineOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.ExamineOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.ExamineOptionsContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_examineStatement




    def examineStatement(self):

        localctx = NaturalParser.ExamineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_examineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.match(NaturalParser.EXAMINE)
            self.state = 407
            self.match(NaturalParser.WS)
            self.state = 414 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 414
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [284]:
                        self.state = 408
                        self.variable()
                        pass
                    elif token in [263]:
                        self.state = 409
                        self.match(NaturalParser.STRING)
                        pass
                    elif token in [22, 40, 48, 66, 79, 80, 81, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 250]:
                        self.state = 410
                        self.examineOptions()
                        pass
                    elif token in [265]:
                        self.state = 411
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    elif token in [286]:
                        self.state = 412
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 413
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 416 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

            self.state = 418
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExamineOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def AND_TEXT(self):
            return self.getToken(NaturalParser.AND_TEXT, 0)

        def FULL(self):
            return self.getToken(NaturalParser.FULL, 0)

        def SUBSTRING(self):
            return self.getToken(NaturalParser.SUBSTRING, 0)

        def REPLACE(self):
            return self.getToken(NaturalParser.REPLACE, 0)

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def GIVING(self):
            return self.getToken(NaturalParser.GIVING, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def ABSOLUTE(self):
            return self.getToken(NaturalParser.ABSOLUTE, 0)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def CHARPOSITION(self):
            return self.getToken(NaturalParser.CHARPOSITION, 0)

        def CHARLENGTH(self):
            return self.getToken(NaturalParser.CHARLENGTH, 0)

        def LENGTH(self):
            return self.getToken(NaturalParser.LENGTH, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def NUMBER(self):
            return self.getToken(NaturalParser.NUMBER, 0)

        def TRANSLATE(self):
            return self.getToken(NaturalParser.TRANSLATE, 0)

        def DELIMITER(self):
            return self.getToken(NaturalParser.DELIMITER, 0)

        def UPPPER_CASE(self):
            return self.getToken(NaturalParser.UPPPER_CASE, 0)

        def LOWER_CASE(self):
            return self.getToken(NaturalParser.LOWER_CASE, 0)

        def INTO(self):
            return self.getToken(NaturalParser.INTO, 0)

        def INVERTED(self):
            return self.getToken(NaturalParser.INVERTED, 0)

        def INDEX(self):
            return self.getToken(NaturalParser.INDEX, 0)

        def PATTERN(self):
            return self.getToken(NaturalParser.PATTERN, 0)

        def VALUE_OF(self):
            return self.getToken(NaturalParser.VALUE_OF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_examineOptions




    def examineOptions(self):

        localctx = NaturalParser.ExamineOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_examineOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 282574492532736) != 0 or (((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 26388027465729) != 0 or _la==250):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MOVE(self):
            return self.getToken(NaturalParser.MOVE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def moveOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.MoveOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.MoveOptionsContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_moveStatement




    def moveStatement(self):

        localctx = NaturalParser.MoveStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_moveStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(NaturalParser.MOVE)
            self.state = 424
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 423
                self.match(NaturalParser.WS)


            self.state = 429 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 429
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [29, 80, 94, 109, 116, 117, 118, 119, 120, 121, 122, 123, 124, 263, 265, 266, 269, 270, 271, 278, 282, 284]:
                        self.state = 426
                        self.moveOptions()
                        pass
                    elif token in [286]:
                        self.state = 427
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 428
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 431 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

            self.state = 434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 433
                self.match(NaturalParser.TO)


            self.state = 439 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 439
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [29, 80, 94, 109, 116, 117, 118, 119, 120, 121, 122, 123, 124, 263, 265, 266, 269, 270, 271, 278, 282, 284]:
                        self.state = 436
                        self.moveOptions()
                        pass
                    elif token in [286]:
                        self.state = 437
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 438
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 441 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def LT(self):
            return self.getToken(NaturalParser.LT, 0)

        def GT(self):
            return self.getToken(NaturalParser.GT, 0)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def SUBSTRING(self):
            return self.getToken(NaturalParser.SUBSTRING, 0)

        def BY_NAME(self):
            return self.getToken(NaturalParser.BY_NAME, 0)

        def BY_POSITION(self):
            return self.getToken(NaturalParser.BY_POSITION, 0)

        def EDITED(self):
            return self.getToken(NaturalParser.EDITED, 0)

        def LEFT(self):
            return self.getToken(NaturalParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(NaturalParser.RIGHT, 0)

        def JUSTIFIED(self):
            return self.getToken(NaturalParser.JUSTIFIED, 0)

        def NORMALIZED(self):
            return self.getToken(NaturalParser.NORMALIZED, 0)

        def ENCODED(self):
            return self.getToken(NaturalParser.ENCODED, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def INDEXED(self):
            return self.getToken(NaturalParser.INDEXED, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_moveOptions




    def moveOptions(self):

        localctx = NaturalParser.MoveOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_moveOptions)
        try:
            self.state = 460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [80, 263, 265, 266, 269, 270, 271, 282, 284]:
                self.enterOuterAlt(localctx, 1)
                self.state = 443
                self.operand()
                pass
            elif token in [278]:
                self.enterOuterAlt(localctx, 2)
                self.state = 444
                self.match(NaturalParser.LT)
                self.state = 445
                self.operand()
                self.state = 446
                self.match(NaturalParser.GT)
                pass
            elif token in [124]:
                self.enterOuterAlt(localctx, 3)
                self.state = 448
                self.match(NaturalParser.ROUNDED)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 4)
                self.state = 449
                self.match(NaturalParser.SUBSTRING)
                pass
            elif token in [116]:
                self.enterOuterAlt(localctx, 5)
                self.state = 450
                self.match(NaturalParser.BY_NAME)
                pass
            elif token in [117]:
                self.enterOuterAlt(localctx, 6)
                self.state = 451
                self.match(NaturalParser.BY_POSITION)
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 7)
                self.state = 452
                self.match(NaturalParser.EDITED)
                pass
            elif token in [119]:
                self.enterOuterAlt(localctx, 8)
                self.state = 453
                self.match(NaturalParser.LEFT)
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 9)
                self.state = 454
                self.match(NaturalParser.RIGHT)
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 10)
                self.state = 455
                self.match(NaturalParser.JUSTIFIED)
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 11)
                self.state = 456
                self.match(NaturalParser.NORMALIZED)
                pass
            elif token in [123]:
                self.enterOuterAlt(localctx, 12)
                self.state = 457
                self.match(NaturalParser.ENCODED)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 13)
                self.state = 458
                self.match(NaturalParser.ALL)
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 14)
                self.state = 459
                self.match(NaturalParser.INDEXED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepeatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_repeatStatement




    def repeatStatement(self):

        localctx = NaturalParser.RepeatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_repeatStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(NaturalParser.REPEAT)
            self.state = 466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0:
                self.state = 463
                self.statement()
                self.state = 468
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 469
            self.match(NaturalParser.LOOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_doStatement




    def doStatement(self):

        localctx = NaturalParser.DoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_doStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.match(NaturalParser.DO)
            self.state = 475
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0:
                self.state = 472
                self.statement()
                self.state = 477
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 478
            self.match(NaturalParser.DOEND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STORE(self):
            return self.getToken(NaturalParser.STORE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def storeCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StoreConditionContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StoreConditionContext,i)


        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_storeStatement




    def storeStatement(self):

        localctx = NaturalParser.StoreStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_storeStatement)
        self._la = 0 # Token type
        try:
            self.state = 536
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 480
                self.match(NaturalParser.STORE)
                self.state = 482
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 481
                    self.match(NaturalParser.WS)


                self.state = 484
                self.match(NaturalParser.IDENTIFIER)
                self.state = 486
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
                if la_ == 1:
                    self.state = 485
                    self.match(NaturalParser.WS)


                self.state = 489
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
                if la_ == 1:
                    self.state = 488
                    self.match(NaturalParser.WITH)


                self.state = 492
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 491
                    self.match(NaturalParser.WS)


                self.state = 495
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
                if la_ == 1:
                    self.state = 494
                    self.match(NaturalParser.NL)


                self.state = 500
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 497
                        self.storeCondition() 
                    self.state = 502
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 503
                self.match(NaturalParser.STORE)
                self.state = 505
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 504
                    self.match(NaturalParser.WS)


                self.state = 507
                self.match(NaturalParser.RECORD)
                self.state = 509
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
                if la_ == 1:
                    self.state = 508
                    self.match(NaturalParser.WS)


                self.state = 512
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==81:
                    self.state = 511
                    self.match(NaturalParser.IN)


                self.state = 515
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 514
                    self.match(NaturalParser.WS)


                self.state = 517
                self.match(NaturalParser.IDENTIFIER)
                self.state = 519
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 518
                    self.match(NaturalParser.WS)


                self.state = 522
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                if la_ == 1:
                    self.state = 521
                    self.match(NaturalParser.WITH)


                self.state = 525
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
                if la_ == 1:
                    self.state = 524
                    self.match(NaturalParser.WS)


                self.state = 528
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,57,self._ctx)
                if la_ == 1:
                    self.state = 527
                    self.match(NaturalParser.NL)


                self.state = 533
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,58,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 530
                        self.storeCondition() 
                    self.state = 535
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,58,self._ctx)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def otherStatement(self):
            return self.getTypedRuleContext(NaturalParser.OtherStatementContext,0)


        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_storeCondition




    def storeCondition(self):

        localctx = NaturalParser.StoreConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_storeCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.state = 538
                self.match(NaturalParser.LINE_NUMBER)
                self.state = 539
                self.match(NaturalParser.WS)


            self.state = 542
            self.otherStatement()
            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 543
                self.match(NaturalParser.WS)


            self.state = 547
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 546
                self.match(NaturalParser.COLON)


            self.state = 549
            self.match(NaturalParser.EQ)
            self.state = 551
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 550
                self.match(NaturalParser.WS)


            self.state = 553
            _la = self._input.LA(1)
            if not(_la==263 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 557
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==286:
                self.state = 554
                self.match(NaturalParser.WS)
                self.state = 559
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 560
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.findBody = None # BlockContentContext
            self.endBlock = None # Token

        def FIND(self):
            return self.getToken(NaturalParser.FIND, 0)

        def findOptions(self):
            return self.getTypedRuleContext(NaturalParser.FindOptionsContext,0)


        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_FIND(self):
            return self.getToken(NaturalParser.END_FIND, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NUMBER(self):
            return self.getToken(NaturalParser.NUMBER, 0)

        def findNumber(self):
            return self.getTypedRuleContext(NaturalParser.FindNumberContext,0)


        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_findStatement




    def findStatement(self):

        localctx = NaturalParser.FindStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_findStatement)
        self._la = 0 # Token type
        try:
            self.state = 584
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 562
                self.match(NaturalParser.FIND)
                self.state = 564
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 563
                    self.match(NaturalParser.WS)


                self.state = 566
                self.findOptions()
                self.state = 568
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                if la_ == 1:
                    self.state = 567
                    self.match(NaturalParser.WS)


                self.state = 570
                localctx.findBody = self.blockContent()
                self.state = 571
                localctx.endBlock = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==32 or _la==58):
                    localctx.endBlock = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.match(NaturalParser.FIND)
                self.state = 574
                self.match(NaturalParser.WS)
                self.state = 575
                self.match(NaturalParser.NUMBER)
                self.state = 576
                self.match(NaturalParser.WS)
                self.state = 577
                self.findNumber()
                self.state = 578
                self.operand()
                self.state = 580
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 579
                    self.match(NaturalParser.WS)


                self.state = 582
                self.match(NaturalParser.NL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST(self):
            return self.getToken(NaturalParser.FIRST, 0)

        def UNIQUE_LEX(self):
            return self.getToken(NaturalParser.UNIQUE_LEX, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_findOptions




    def findOptions(self):

        localctx = NaturalParser.FindOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_findOptions)
        try:
            self.state = 592
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 586
                self.match(NaturalParser.FIRST)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 587
                self.match(NaturalParser.UNIQUE_LEX)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 588
                self.match(NaturalParser.ALL)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 589
                self.match(NaturalParser.IDENTIFIER)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 590
                self.match(NaturalParser.LINE_REF)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 591
                self.variable()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WHERE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WHERE)
            else:
                return self.getToken(NaturalParser.WHERE, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WITH)
            else:
                return self.getToken(NaturalParser.WITH, i)

        def STARTING_WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_WITH)
            else:
                return self.getToken(NaturalParser.STARTING_WITH, i)

        def COUPLED(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COUPLED)
            else:
                return self.getToken(NaturalParser.COUPLED, i)

        def SORTED(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SORTED)
            else:
                return self.getToken(NaturalParser.SORTED, i)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY)
            else:
                return self.getToken(NaturalParser.BY, i)

        def RETAIN_AS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RETAIN_AS)
            else:
                return self.getToken(NaturalParser.RETAIN_AS, i)

        def MULTI_FETCH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.MULTI_FETCH)
            else:
                return self.getToken(NaturalParser.MULTI_FETCH, i)

        def VIA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VIA)
            else:
                return self.getToken(NaturalParser.VIA, i)

        def THRU(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THRU)
            else:
                return self.getToken(NaturalParser.THRU, i)

        def DESCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DESCENDING)
            else:
                return self.getToken(NaturalParser.DESCENDING, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AND)
            else:
                return self.getToken(NaturalParser.AND, i)

        def TO(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.TO)
            else:
                return self.getToken(NaturalParser.TO, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FROM)
            else:
                return self.getToken(NaturalParser.FROM, i)

        def OF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OF)
            else:
                return self.getToken(NaturalParser.OF, i)

        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ON)
            else:
                return self.getToken(NaturalParser.ON, i)

        def OFF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OFF)
            else:
                return self.getToken(NaturalParser.OFF, i)

        def BY_NAME(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_NAME)
            else:
                return self.getToken(NaturalParser.BY_NAME, i)

        def BY_POSITION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_POSITION)
            else:
                return self.getToken(NaturalParser.BY_POSITION, i)

        def BUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BUT)
            else:
                return self.getToken(NaturalParser.BUT, i)

        def compOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CompOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CompOpContext,i)


        def logicalOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LogicalOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LogicalOpContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_findNumber




    def findNumber(self):

        localctx = NaturalParser.FindNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_findNumber)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 622
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,71,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 620
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                    if la_ == 1:
                        self.state = 594
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 595
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 596
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 4:
                        self.state = 597
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 5:
                        self.state = 598
                        self.match(NaturalParser.WHERE)
                        pass

                    elif la_ == 6:
                        self.state = 599
                        self.match(NaturalParser.WITH)
                        pass

                    elif la_ == 7:
                        self.state = 600
                        self.match(NaturalParser.STARTING_WITH)
                        pass

                    elif la_ == 8:
                        self.state = 601
                        self.match(NaturalParser.COUPLED)
                        pass

                    elif la_ == 9:
                        self.state = 602
                        self.match(NaturalParser.SORTED)
                        pass

                    elif la_ == 10:
                        self.state = 603
                        self.match(NaturalParser.BY)
                        pass

                    elif la_ == 11:
                        self.state = 604
                        self.match(NaturalParser.RETAIN_AS)
                        pass

                    elif la_ == 12:
                        self.state = 605
                        self.match(NaturalParser.MULTI_FETCH)
                        pass

                    elif la_ == 13:
                        self.state = 606
                        self.match(NaturalParser.VIA)
                        pass

                    elif la_ == 14:
                        self.state = 607
                        self.match(NaturalParser.THRU)
                        pass

                    elif la_ == 15:
                        self.state = 608
                        self.match(NaturalParser.DESCENDING)
                        pass

                    elif la_ == 16:
                        self.state = 609
                        self.match(NaturalParser.AND)
                        pass

                    elif la_ == 17:
                        self.state = 610
                        self.match(NaturalParser.TO)
                        pass

                    elif la_ == 18:
                        self.state = 611
                        self.match(NaturalParser.FROM)
                        pass

                    elif la_ == 19:
                        self.state = 612
                        self.match(NaturalParser.OF)
                        pass

                    elif la_ == 20:
                        self.state = 613
                        self.match(NaturalParser.ON)
                        pass

                    elif la_ == 21:
                        self.state = 614
                        self.match(NaturalParser.OFF)
                        pass

                    elif la_ == 22:
                        self.state = 615
                        self.match(NaturalParser.BY_NAME)
                        pass

                    elif la_ == 23:
                        self.state = 616
                        self.match(NaturalParser.BY_POSITION)
                        pass

                    elif la_ == 24:
                        self.state = 617
                        self.match(NaturalParser.BUT)
                        pass

                    elif la_ == 25:
                        self.state = 618
                        self.compOp()
                        pass

                    elif la_ == 26:
                        self.state = 619
                        self.logicalOp()
                        pass

             
                self.state = 624
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,71,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.readBody = None # BlockContentContext
            self.endBlock = None # Token

        def READ(self):
            return self.getToken(NaturalParser.READ, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_READ(self):
            return self.getToken(NaturalParser.END_READ, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_readStatement




    def readStatement(self):

        localctx = NaturalParser.ReadStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_readStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 625
            self.match(NaturalParser.READ)
            self.state = 627
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 626
                self.match(NaturalParser.WS)


            self.state = 629
            _la = self._input.LA(1)
            if not(_la==268 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 631
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
            if la_ == 1:
                self.state = 630
                self.match(NaturalParser.WS)


            self.state = 633
            localctx.readBody = self.blockContent()
            self.state = 634
            localctx.endBlock = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==32 or _la==57):
                localctx.endBlock = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def updateStartline(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStartlineContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.EQ)
            else:
                return self.getToken(NaturalParser.EQ, i)

        def calculations(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CalculationsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CalculationsContext,i)


        def SET(self):
            return self.getToken(NaturalParser.SET, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COLON)
            else:
                return self.getToken(NaturalParser.COLON, i)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def SAME(self):
            return self.getToken(NaturalParser.SAME, 0)

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_updateStatement




    def updateStatement(self):

        localctx = NaturalParser.UpdateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_updateStatement)
        self._la = 0 # Token type
        try:
            self.state = 689
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 636
                self.updateStartline()
                self.state = 638 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 637
                        _la = self._input.LA(1)
                        if not(_la==286 or _la==287):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 640 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,74,self._ctx)

                self.state = 643
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==86 or _la==90:
                    self.state = 642
                    _la = self._input.LA(1)
                    if not(_la==86 or _la==90):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 662 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 662
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,79,self._ctx)
                        if la_ == 1:
                            self.state = 645
                            self.match(NaturalParser.WS)
                            pass

                        elif la_ == 2:
                            self.state = 646
                            self.match(NaturalParser.NL)
                            pass

                        elif la_ == 3:
                            self.state = 647
                            self.match(NaturalParser.LINE_NUMBER)
                            pass

                        elif la_ == 4:
                            self.state = 648
                            self.operand()
                            self.state = 650
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==286:
                                self.state = 649
                                self.match(NaturalParser.WS)


                            self.state = 653
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==264:
                                self.state = 652
                                self.match(NaturalParser.COLON)


                            self.state = 655
                            self.match(NaturalParser.EQ)
                            self.state = 657
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==286:
                                self.state = 656
                                self.match(NaturalParser.WS)


                            self.state = 659
                            self.operand()
                            pass

                        elif la_ == 5:
                            self.state = 661
                            self.calculations()
                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 664 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,80,self._ctx)

                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 666
                    self.match(NaturalParser.WS)


                self.state = 669
                self.match(NaturalParser.NL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 671
                self.updateStartline()
                self.state = 672
                self.match(NaturalParser.WS)
                self.state = 673
                self.match(NaturalParser.USING)
                self.state = 674
                self.match(NaturalParser.WS)
                self.state = 675
                self.match(NaturalParser.SAME)
                self.state = 676
                self.match(NaturalParser.WS)
                self.state = 677
                self.match(NaturalParser.RECORD)
                self.state = 679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 678
                    self.match(NaturalParser.WS)


                self.state = 681
                self.match(NaturalParser.NL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 683
                self.updateStartline()
                self.state = 685
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 684
                    self.match(NaturalParser.WS)


                self.state = 687
                self.match(NaturalParser.NL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStartlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(NaturalParser.UPDATE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def STATEMENT(self):
            return self.getToken(NaturalParser.STATEMENT, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_updateStartline




    def updateStartline(self):

        localctx = NaturalParser.UpdateStartlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_updateStartline)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 691
            self.match(NaturalParser.UPDATE)
            self.state = 693
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
            if la_ == 1:
                self.state = 692
                self.match(NaturalParser.WS)


            self.state = 696
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==83:
                self.state = 695
                self.match(NaturalParser.RECORD)


            self.state = 699
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
            if la_ == 1:
                self.state = 698
                self.match(NaturalParser.WS)


            self.state = 702
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 701
                self.match(NaturalParser.IN)


            self.state = 705
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.state = 704
                self.match(NaturalParser.WS)


            self.state = 708
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==85:
                self.state = 707
                self.match(NaturalParser.STATEMENT)


            self.state = 711
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                self.state = 710
                self.match(NaturalParser.WS)


            self.state = 714
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==268 or _la==284:
                self.state = 713
                _la = self._input.LA(1)
                if not(_la==268 or _la==284):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_deleteStatement




    def deleteStatement(self):

        localctx = NaturalParser.DeleteStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_deleteStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 716
            self.match(NaturalParser.DELETE)
            self.state = 718
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.state = 717
                self.match(NaturalParser.WS)


            self.state = 721
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.state = 720
                self.match(NaturalParser.LINE_REF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getTabledStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetTabledStatementsContext,0)


        def getTransactionStatement(self):
            return self.getTypedRuleContext(NaturalParser.GetTransactionStatementContext,0)


        def getSameStatement(self):
            return self.getTypedRuleContext(NaturalParser.GetSameStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_getStatements




    def getStatements(self):

        localctx = NaturalParser.GetStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_getStatements)
        try:
            self.state = 726
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 723
                self.getTabledStatements()
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 2)
                self.state = 724
                self.getTransactionStatement()
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 3)
                self.state = 725
                self.getSameStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTabledStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token
            self.filterCondition = None # VariableContext

        def GET(self):
            return self.getToken(NaturalParser.GET, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def getTabledOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.GetTabledOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.GetTabledOptionsContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_getTabledStatements




    def getTabledStatements(self):

        localctx = NaturalParser.GetTabledStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_getTabledStatements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(NaturalParser.GET)
            self.state = 729
            self.match(NaturalParser.WS)
            self.state = 730
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 735
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==83 or _la==84 or _la==286:
                self.state = 733
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [83, 84]:
                    self.state = 731
                    self.getTabledOptions()
                    pass
                elif token in [286]:
                    self.state = 732
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 737
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 738
            localctx.filterCondition = self.variable()
            self.state = 740
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 739
                self.match(NaturalParser.WS)


            self.state = 742
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTabledOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def RECORDS(self):
            return self.getToken(NaturalParser.RECORDS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_getTabledOptions




    def getTabledOptions(self):

        localctx = NaturalParser.GetTabledOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_getTabledOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 744
            _la = self._input.LA(1)
            if not(_la==83 or _la==84):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTransactionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_TRANSACTION_DATA(self):
            return self.getToken(NaturalParser.GET_TRANSACTION_DATA, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_getTransactionStatement




    def getTransactionStatement(self):

        localctx = NaturalParser.GetTransactionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_getTransactionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.match(NaturalParser.GET_TRANSACTION_DATA)
            self.state = 748 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 747
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6815745) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 750 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,99,self._ctx)

            self.state = 752
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetSameStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_SAME(self):
            return self.getToken(NaturalParser.GET_SAME, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_getSameStatement




    def getSameStatement(self):

        localctx = NaturalParser.GetSameStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_getSameStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 754
            self.match(NaturalParser.GET_SAME)
            self.state = 759
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 755
                    self.match(NaturalParser.WS)


                self.state = 758
                self.match(NaturalParser.LINE_REF)


            self.state = 764
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==284 or _la==286:
                self.state = 761
                _la = self._input.LA(1)
                if not(_la==284 or _la==286):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 766
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 767
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.query = None # HistogramOptionsContext
            self.endBlock = None # Token

        def HISTOGRAM(self):
            return self.getToken(NaturalParser.HISTOGRAM, 0)

        def histogramOptions(self):
            return self.getTypedRuleContext(NaturalParser.HistogramOptionsContext,0)


        def END_HISTOGRAM(self):
            return self.getToken(NaturalParser.END_HISTOGRAM, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_histogramStatement




    def histogramStatement(self):

        localctx = NaturalParser.HistogramStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_histogramStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 769
            self.match(NaturalParser.HISTOGRAM)
            self.state = 770
            localctx.query = self.histogramOptions()
            self.state = 774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0:
                self.state = 771
                self.statement()
                self.state = 776
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 777
            localctx.endBlock = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==32 or _la==207):
                localctx.endBlock = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_REF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_REF)
            else:
                return self.getToken(NaturalParser.LINE_REF, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def ALL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ALL)
            else:
                return self.getToken(NaturalParser.ALL, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FROM)
            else:
                return self.getToken(NaturalParser.FROM, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WITH)
            else:
                return self.getToken(NaturalParser.WITH, i)

        def THRU(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THRU)
            else:
                return self.getToken(NaturalParser.THRU, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VALUE)
            else:
                return self.getToken(NaturalParser.VALUE, i)

        def FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FOR)
            else:
                return self.getToken(NaturalParser.FOR, i)

        def FIELD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FIELD)
            else:
                return self.getToken(NaturalParser.FIELD, i)

        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ON)
            else:
                return self.getToken(NaturalParser.ON, i)

        def OFF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OFF)
            else:
                return self.getToken(NaturalParser.OFF, i)

        def OF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OF)
            else:
                return self.getToken(NaturalParser.OF, i)

        def ASCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ASCENDING)
            else:
                return self.getToken(NaturalParser.ASCENDING, i)

        def DESCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DESCENDING)
            else:
                return self.getToken(NaturalParser.DESCENDING, i)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VARIABLE)
            else:
                return self.getToken(NaturalParser.VARIABLE, i)

        def DYNAMIC(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DYNAMIC)
            else:
                return self.getToken(NaturalParser.DYNAMIC, i)

        def SEQUENCE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SEQUENCE)
            else:
                return self.getToken(NaturalParser.SEQUENCE, i)

        def STARTING_WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_WITH)
            else:
                return self.getToken(NaturalParser.STARTING_WITH, i)

        def STARTING_FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_FROM)
            else:
                return self.getToken(NaturalParser.STARTING_FROM, i)

        def ENDING_AT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ENDING_AT)
            else:
                return self.getToken(NaturalParser.ENDING_AT, i)

        def MULTI_FETCH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.MULTI_FETCH)
            else:
                return self.getToken(NaturalParser.MULTI_FETCH, i)

        def WHERE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WHERE)
            else:
                return self.getToken(NaturalParser.WHERE, i)

        def compOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CompOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CompOpContext,i)


        def logicalOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LogicalOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LogicalOpContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_histogramOptions




    def histogramOptions(self):

        localctx = NaturalParser.HistogramOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_histogramOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 809
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,105,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 807
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
                    if la_ == 1:
                        self.state = 779
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 780
                        self.match(NaturalParser.LINE_REF)
                        pass

                    elif la_ == 3:
                        self.state = 781
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 782
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 5:
                        self.state = 783
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 6:
                        self.state = 784
                        self.match(NaturalParser.ALL)
                        pass

                    elif la_ == 7:
                        self.state = 785
                        self.match(NaturalParser.FROM)
                        pass

                    elif la_ == 8:
                        self.state = 786
                        self.match(NaturalParser.WITH)
                        pass

                    elif la_ == 9:
                        self.state = 787
                        self.match(NaturalParser.THRU)
                        pass

                    elif la_ == 10:
                        self.state = 788
                        self.match(NaturalParser.IN)
                        pass

                    elif la_ == 11:
                        self.state = 789
                        self.match(NaturalParser.VALUE)
                        pass

                    elif la_ == 12:
                        self.state = 790
                        self.match(NaturalParser.FOR)
                        pass

                    elif la_ == 13:
                        self.state = 791
                        self.match(NaturalParser.FIELD)
                        pass

                    elif la_ == 14:
                        self.state = 792
                        self.match(NaturalParser.ON)
                        pass

                    elif la_ == 15:
                        self.state = 793
                        self.match(NaturalParser.OFF)
                        pass

                    elif la_ == 16:
                        self.state = 794
                        self.match(NaturalParser.OF)
                        pass

                    elif la_ == 17:
                        self.state = 795
                        self.match(NaturalParser.ASCENDING)
                        pass

                    elif la_ == 18:
                        self.state = 796
                        self.match(NaturalParser.DESCENDING)
                        pass

                    elif la_ == 19:
                        self.state = 797
                        self.match(NaturalParser.VARIABLE)
                        pass

                    elif la_ == 20:
                        self.state = 798
                        self.match(NaturalParser.DYNAMIC)
                        pass

                    elif la_ == 21:
                        self.state = 799
                        self.match(NaturalParser.SEQUENCE)
                        pass

                    elif la_ == 22:
                        self.state = 800
                        self.match(NaturalParser.STARTING_WITH)
                        pass

                    elif la_ == 23:
                        self.state = 801
                        self.match(NaturalParser.STARTING_FROM)
                        pass

                    elif la_ == 24:
                        self.state = 802
                        self.match(NaturalParser.ENDING_AT)
                        pass

                    elif la_ == 25:
                        self.state = 803
                        self.match(NaturalParser.MULTI_FETCH)
                        pass

                    elif la_ == 26:
                        self.state = 804
                        self.match(NaturalParser.WHERE)
                        pass

                    elif la_ == 27:
                        self.state = 805
                        self.compOp()
                        pass

                    elif la_ == 28:
                        self.state = 806
                        self.logicalOp()
                        pass

             
                self.state = 811
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,105,self._ctx)

            self.state = 812
            self.operand()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndTransactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END_TRANSACTION(self):
            return self.getToken(NaturalParser.END_TRANSACTION, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_endTransaction




    def endTransaction(self):

        localctx = NaturalParser.EndTransactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_endTransaction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 814
            self.match(NaturalParser.END_TRANSACTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BackoutTransactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKOUT_TRANSACTION(self):
            return self.getToken(NaturalParser.BACKOUT_TRANSACTION, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_backoutTransaction




    def backoutTransaction(self):

        localctx = NaturalParser.BackoutTransactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_backoutTransaction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 816
            self.match(NaturalParser.BACKOUT_TRANSACTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def readworkfileOptions(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileOptionsContext,0)


        def atEndOfFileStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtEndOfFileStatementContext,0)


        def READ_WORK_FILE(self):
            return self.getToken(NaturalParser.READ_WORK_FILE, 0)

        def READ_WORK(self):
            return self.getToken(NaturalParser.READ_WORK, 0)

        def ONCE(self):
            return self.getToken(NaturalParser.ONCE, 0)

        def END_ALL(self):
            return self.getToken(NaturalParser.END_ALL, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def END_WORK(self):
            return self.getToken(NaturalParser.END_WORK, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_readworkfileStatement




    def readworkfileStatement(self):

        localctx = NaturalParser.ReadworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_readworkfileStatement)
        self._la = 0 # Token type
        try:
            self.state = 864
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 818
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 819
                self.match(NaturalParser.WS)
                self.state = 820
                self.workfilenumberOption()
                self.state = 825
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 822
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 821
                        self.match(NaturalParser.WS)


                    self.state = 824
                    self.match(NaturalParser.ONCE)


                self.state = 827
                self.readworkfileOptions()
                self.state = 828
                self.atEndOfFileStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 830
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 831
                self.match(NaturalParser.WS)
                self.state = 832
                self.workfilenumberOption()
                self.state = 837
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                if la_ == 1:
                    self.state = 834
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 833
                        self.match(NaturalParser.WS)


                    self.state = 836
                    self.match(NaturalParser.ONCE)


                self.state = 839
                self.readworkfileOptions()
                self.state = 841 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 840
                        self.statement()

                    else:
                        raise NoViableAltException(self)
                    self.state = 843 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

                self.state = 845
                self.match(NaturalParser.END_ALL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 847
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 848
                self.match(NaturalParser.WS)
                self.state = 849
                self.workfilenumberOption()
                self.state = 854
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                if la_ == 1:
                    self.state = 851
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 850
                        self.match(NaturalParser.WS)


                    self.state = 853
                    self.match(NaturalParser.ONCE)


                self.state = 856
                self.readworkfileOptions()
                self.state = 858 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 857
                        self.statement()

                    else:
                        raise NoViableAltException(self)
                    self.state = 860 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,113,self._ctx)

                self.state = 862
                _la = self._input.LA(1)
                if not(_la==32 or _la==238):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WorkfilenumberOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_workfilenumberOption




    def workfilenumberOption(self):

        localctx = NaturalParser.WorkfilenumberOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_workfilenumberOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 866
            self.match(NaturalParser.LINE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadworkfileOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_REF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_REF)
            else:
                return self.getToken(NaturalParser.LINE_REF, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORD)
            else:
                return self.getToken(NaturalParser.RECORD, i)

        def FILLER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FILLER)
            else:
                return self.getToken(NaturalParser.FILLER, i)

        def OFFSET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OFFSET)
            else:
                return self.getToken(NaturalParser.OFFSET, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AND)
            else:
                return self.getToken(NaturalParser.AND, i)

        def SELECT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SELECT)
            else:
                return self.getToken(NaturalParser.SELECT, i)

        def GIVING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.GIVING)
            else:
                return self.getToken(NaturalParser.GIVING, i)

        def LENGTH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LENGTH)
            else:
                return self.getToken(NaturalParser.LENGTH, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_readworkfileOptions




    def readworkfileOptions(self):

        localctx = NaturalParser.ReadworkfileOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_readworkfileOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 882
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,116,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 880
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                    if la_ == 1:
                        self.state = 868
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 869
                        self.match(NaturalParser.LINE_REF)
                        pass

                    elif la_ == 3:
                        self.state = 870
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 871
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 5:
                        self.state = 872
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 6:
                        self.state = 873
                        self.match(NaturalParser.RECORD)
                        pass

                    elif la_ == 7:
                        self.state = 874
                        self.match(NaturalParser.FILLER)
                        pass

                    elif la_ == 8:
                        self.state = 875
                        self.match(NaturalParser.OFFSET)
                        pass

                    elif la_ == 9:
                        self.state = 876
                        self.match(NaturalParser.AND)
                        pass

                    elif la_ == 10:
                        self.state = 877
                        self.match(NaturalParser.SELECT)
                        pass

                    elif la_ == 11:
                        self.state = 878
                        self.match(NaturalParser.GIVING)
                        pass

                    elif la_ == 12:
                        self.state = 879
                        self.match(NaturalParser.LENGTH)
                        pass

             
                self.state = 884
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,116,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtEndOfFileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_END_OF_FILE(self):
            return self.getToken(NaturalParser.AT_END_OF_FILE, 0)

        def END_ENDFILE(self):
            return self.getToken(NaturalParser.END_ENDFILE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_atEndOfFileStatement




    def atEndOfFileStatement(self):

        localctx = NaturalParser.AtEndOfFileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_atEndOfFileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            self.match(NaturalParser.AT_END_OF_FILE)
            self.state = 889
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,117,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 886
                    self.statement() 
                self.state = 891
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,117,self._ctx)

            self.state = 892
            self.match(NaturalParser.END_ENDFILE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WriteworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WRITE_WORK_FILE(self):
            return self.getToken(NaturalParser.WRITE_WORK_FILE, 0)

        def WRITE_WORK(self):
            return self.getToken(NaturalParser.WRITE_WORK, 0)

        def VARIABLE(self):
            return self.getToken(NaturalParser.VARIABLE, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_writeworkfileStatement




    def writeworkfileStatement(self):

        localctx = NaturalParser.WriteworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_writeworkfileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 894
            _la = self._input.LA(1)
            if not(_la==154 or _la==155):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 895
            self.match(NaturalParser.WS)
            self.state = 896
            self.workfilenumberOption()
            self.state = 901
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,119,self._ctx)
            if la_ == 1:
                self.state = 898
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 897
                    self.match(NaturalParser.WS)


                self.state = 900
                self.match(NaturalParser.VARIABLE)


            self.state = 909
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,121,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 907
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                    if la_ == 1:
                        self.state = 903
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 904
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 3:
                        self.state = 905
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 906
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 911
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,121,self._ctx)

            self.state = 912
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CloseworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def CLOSE_WORK_FILE(self):
            return self.getToken(NaturalParser.CLOSE_WORK_FILE, 0)

        def CLOSE_WORK(self):
            return self.getToken(NaturalParser.CLOSE_WORK, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_closeworkfileStatement




    def closeworkfileStatement(self):

        localctx = NaturalParser.CloseworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_closeworkfileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            _la = self._input.LA(1)
            if not(_la==160 or _la==161):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 915
            self.match(NaturalParser.WS)
            self.state = 916
            self.workfilenumberOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NoRecordsFoundStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def END_NOREC(self):
            return self.getToken(NaturalParser.END_NOREC, 0)

        def NO_RECORDS_FOUND(self):
            return self.getToken(NaturalParser.NO_RECORDS_FOUND, 0)

        def NO_RECORD_FOUND(self):
            return self.getToken(NaturalParser.NO_RECORD_FOUND, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_noRecordsFoundStatement




    def noRecordsFoundStatement(self):

        localctx = NaturalParser.NoRecordsFoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_noRecordsFoundStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 918
            self.match(NaturalParser.IF)
            self.state = 919
            self.match(NaturalParser.WS)
            self.state = 920
            _la = self._input.LA(1)
            if not(_la==73 or _la==74):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 924
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,122,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 921
                    self.statement() 
                self.state = 926
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,122,self._ctx)

            self.state = 927
            self.match(NaturalParser.END_NOREC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtStartOfDataStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_START_OF_DATA(self):
            return self.getToken(NaturalParser.AT_START_OF_DATA, 0)

        def END_START(self):
            return self.getToken(NaturalParser.END_START, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_atStartOfDataStatement




    def atStartOfDataStatement(self):

        localctx = NaturalParser.AtStartOfDataStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_atStartOfDataStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 929
            self.match(NaturalParser.AT_START_OF_DATA)
            self.state = 931
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
            if la_ == 1:
                self.state = 930
                self.match(NaturalParser.WS)


            self.state = 934
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
            if la_ == 1:
                self.state = 933
                self.match(NaturalParser.IDENTIFIER)


            self.state = 937
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
            if la_ == 1:
                self.state = 936
                self.match(NaturalParser.NL)


            self.state = 941
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                self.state = 939
                self.match(NaturalParser.DO)
                self.state = 940
                self.match(NaturalParser.WS)


            self.state = 946
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,127,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 943
                    self.statement() 
                self.state = 948
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,127,self._ctx)

            self.state = 949
            _la = self._input.LA(1)
            if not(_la==64 or _la==217):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formatOptions(self):
            return self.getTypedRuleContext(NaturalParser.FormatOptionsContext,0)


        def assignmentStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AssignmentStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_formatStatement




    def formatStatement(self):

        localctx = NaturalParser.FormatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_formatStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 951
            self.formatOptions()
            self.state = 970
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,132,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 955
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,128,self._ctx)
                    while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1+1:
                            self.state = 952
                            self.match(NaturalParser.WS) 
                        self.state = 957
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,128,self._ctx)

                    self.state = 958
                    self.assignmentStatement()
                    self.state = 960
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                    if la_ == 1:
                        self.state = 959
                        self.match(NaturalParser.WS)


                    self.state = 963
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
                    if la_ == 1:
                        self.state = 962
                        self.match(NaturalParser.NL)


                    self.state = 966
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                    if la_ == 1:
                        self.state = 965
                        self.match(NaturalParser.LINE_NUMBER)

             
                self.state = 972
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,132,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT(self):
            return self.getToken(NaturalParser.FORMAT, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_formatOptions




    def formatOptions(self):

        localctx = NaturalParser.FormatOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_formatOptions)
        self._la = 0 # Token type
        try:
            self.state = 979
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 973
                self.match(NaturalParser.FORMAT)
                self.state = 975
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 974
                    self.match(NaturalParser.WS)


                self.state = 977
                self.match(NaturalParser.LINE_REF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 978
                self.match(NaturalParser.FORMAT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def ON(self):
            return self.getToken(NaturalParser.ON, 0)

        def OFF(self):
            return self.getToken(NaturalParser.OFF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_assignmentStatement




    def assignmentStatement(self):

        localctx = NaturalParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_assignmentStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 981
            self.match(NaturalParser.IDENTIFIER)
            self.state = 982
            self.compOp()
            self.state = 983
            _la = self._input.LA(1)
            if not((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 140737488355331) != 0 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(NaturalParser.INCLUDE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_includeStatement




    def includeStatement(self):

        localctx = NaturalParser.IncludeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_includeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 985
            self.match(NaturalParser.INCLUDE)

            self.state = 989
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,135,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 986
                    self.match(NaturalParser.WS) 
                self.state = 991
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,135,self._ctx)

            self.state = 992
            self.match(NaturalParser.IDENTIFIER)
            self.state = 994
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,136,self._ctx)
            if la_ == 1:
                self.state = 993
                self.match(NaturalParser.WS)


            self.state = 997
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,137,self._ctx)
            if la_ == 1:
                self.state = 996
                self.match(NaturalParser.NL)


            self.state = 1000
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                self.state = 999
                self.match(NaturalParser.LINE_NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RedefineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REDEFINE(self):
            return self.getToken(NaturalParser.REDEFINE, 0)

        def redefineBody(self):
            return self.getTypedRuleContext(NaturalParser.RedefineBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_redefineStatement




    def redefineStatement(self):

        localctx = NaturalParser.RedefineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_redefineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1002
            self.match(NaturalParser.REDEFINE)
            self.state = 1004
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,139,self._ctx)
            if la_ == 1:
                self.state = 1003
                self.match(NaturalParser.WS)


            self.state = 1006
            self.redefineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RedefineBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_redefineBody




    def redefineBody(self):

        localctx = NaturalParser.RedefineBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_redefineBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1013
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,141,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1011
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [265, 284]:
                        self.state = 1008
                        _la = self._input.LA(1)
                        if not(_la==265 or _la==284):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    elif token in [286]:
                        self.state = 1009
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 1010
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 1015
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,141,self._ctx)

            self.state = 1016
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESET(self):
            return self.getToken(NaturalParser.RESET, 0)

        def redefineBody(self):
            return self.getTypedRuleContext(NaturalParser.RedefineBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_resetStatement




    def resetStatement(self):

        localctx = NaturalParser.ResetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_resetStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1018
            self.match(NaturalParser.RESET)
            self.state = 1020
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
            if la_ == 1:
                self.state = 1019
                self.match(NaturalParser.WS)


            self.state = 1022
            self.redefineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallnatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def CALLNAT(self):
            return self.getToken(NaturalParser.CALLNAT, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_callnatStatement




    def callnatStatement(self):

        localctx = NaturalParser.CallnatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_callnatStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1024
            self.match(NaturalParser.CALLNAT)
            self.state = 1026
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1025
                self.match(NaturalParser.WS)


            self.state = 1028
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1030
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,144,self._ctx)
            if la_ == 1:
                self.state = 1029
                self.match(NaturalParser.WS)


            self.state = 1038
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,146,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1036
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [284]:
                        self.state = 1032
                        self.variable()
                        pass
                    elif token in [286]:
                        self.state = 1033
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 1034
                        self.match(NaturalParser.NL)
                        pass
                    elif token in [265]:
                        self.state = 1035
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 1040
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,146,self._ctx)

            self.state = 1041
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetkeyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_KEY(self):
            return self.getToken(NaturalParser.SET_KEY, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_setkeyStatement




    def setkeyStatement(self):

        localctx = NaturalParser.SetkeyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_setkeyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1043
            self.match(NaturalParser.SET_KEY)
            self.state = 1047
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,147,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1044
                    self.match(NaturalParser.WS) 
                self.state = 1049
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,147,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PerformStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subroutineName = None # SubroutineNamesContext

        def PERFORM(self):
            return self.getToken(NaturalParser.PERFORM, 0)

        def subroutineNames(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineNamesContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_performStatement




    def performStatement(self):

        localctx = NaturalParser.PerformStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_performStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1050
            self.match(NaturalParser.PERFORM)
            self.state = 1052
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1051
                self.match(NaturalParser.WS)


            self.state = 1054
            localctx.subroutineName = self.subroutineNames()
            self.state = 1063
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,151,self._ctx)
            if la_ == 1:
                self.state = 1056
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1055
                    self.match(NaturalParser.WS)


                self.state = 1058
                self.match(NaturalParser.USING)
                self.state = 1060
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1059
                    self.match(NaturalParser.WS)


                self.state = 1062
                self.variable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineNamesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def TRANSLATE(self):
            return self.getToken(NaturalParser.TRANSLATE, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_subroutineNames




    def subroutineNames(self):

        localctx = NaturalParser.SubroutineNamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_subroutineNames)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1065
            _la = self._input.LA(1)
            if not(_la==102 or _la==284):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FetchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def FETCH(self):
            return self.getToken(NaturalParser.FETCH, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def RETURN(self):
            return self.getToken(NaturalParser.RETURN, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_fetchStatement




    def fetchStatement(self):

        localctx = NaturalParser.FetchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_fetchStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1067
            self.match(NaturalParser.FETCH)
            self.state = 1070
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,152,self._ctx)
            if la_ == 1:
                self.state = 1068
                self.match(NaturalParser.WS)
                self.state = 1069
                _la = self._input.LA(1)
                if not(_la==13 or _la==31):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1073
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1072
                self.match(NaturalParser.WS)


            self.state = 1075
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1085
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,155,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1079
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                        self.state = 1076
                        _la = self._input.LA(1)
                        if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1081
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1082
                    _la = self._input.LA(1)
                    if not(_la==263 or _la==284):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1087
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,155,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def CALL(self):
            return self.getToken(NaturalParser.CALL, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def INTERFACE4(self):
            return self.getToken(NaturalParser.INTERFACE4, 0)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_callStatement




    def callStatement(self):

        localctx = NaturalParser.CallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_callStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1088
            self.match(NaturalParser.CALL)
            self.state = 1091
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.state = 1089
                self.match(NaturalParser.WS)
                self.state = 1090
                self.match(NaturalParser.INTERFACE4)


            self.state = 1094
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1093
                self.match(NaturalParser.WS)


            self.state = 1096
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1101
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,159,self._ctx)
            if la_ == 1:
                self.state = 1098
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1097
                    self.match(NaturalParser.WS)


                self.state = 1100
                self.match(NaturalParser.USING)


            self.state = 1112
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1106
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                        self.state = 1103
                        _la = self._input.LA(1)
                        if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1108
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1109
                    _la = self._input.LA(1)
                    if not(_la==263 or _la==284):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1114
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

            self.state = 1115
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_FOR(self):
            return self.getToken(NaturalParser.END_FOR, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_forStatement




    def forStatement(self):

        localctx = NaturalParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_forStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1117
            self.match(NaturalParser.FOR)
            self.state = 1118
            self.match(NaturalParser.WS)
            self.state = 1119
            self.condition()
            self.state = 1120
            self.match(NaturalParser.TO)
            self.state = 1121
            self.match(NaturalParser.WS)
            self.state = 1122
            self.operand()
            self.state = 1126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0:
                self.state = 1123
                self.statement()
                self.state = 1128
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1129
            _la = self._input.LA(1)
            if not(_la==32 or _la==33):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AcceptRejectIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def ACCEPT_IF(self):
            return self.getToken(NaturalParser.ACCEPT_IF, 0)

        def REJECT_IF(self):
            return self.getToken(NaturalParser.REJECT_IF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_acceptRejectIfStatement




    def acceptRejectIfStatement(self):

        localctx = NaturalParser.AcceptRejectIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_acceptRejectIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            _la = self._input.LA(1)
            if not(_la==91 or _la==92):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1132
                self.match(NaturalParser.WS)


            self.state = 1135
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def END_DECIDE(self):
            return self.getToken(NaturalParser.END_DECIDE, 0)

        def DECIDE_FOR(self):
            return self.getToken(NaturalParser.DECIDE_FOR, 0)

        def DECIDE_ON(self):
            return self.getToken(NaturalParser.DECIDE_ON, 0)

        def FIRST(self):
            return self.getToken(NaturalParser.FIRST, 0)

        def EVERY(self):
            return self.getToken(NaturalParser.EVERY, 0)

        def WHEN(self):
            return self.getToken(NaturalParser.WHEN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def VALUE_OF(self):
            return self.getToken(NaturalParser.VALUE_OF, 0)

        def VALUE(self):
            return self.getToken(NaturalParser.VALUE, 0)

        def CONDITION(self):
            return self.getToken(NaturalParser.CONDITION, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_decisionStatement




    def decisionStatement(self):

        localctx = NaturalParser.DecisionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_decisionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1137
            _la = self._input.LA(1)
            if not(_la==142 or _la==143):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1138
                self.match(NaturalParser.WS)


            self.state = 1141
            _la = self._input.LA(1)
            if not(_la==24 or _la==25):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1155
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.state = 1142
                self.match(NaturalParser.WS)
                self.state = 1144
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 1143
                    self.match(NaturalParser.CONDITION)


                self.state = 1147
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,166,self._ctx)
                if la_ == 1:
                    self.state = 1146
                    self.match(NaturalParser.WS)


                self.state = 1150
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==287:
                    self.state = 1149
                    self.match(NaturalParser.NL)


                self.state = 1153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1152
                    self.match(NaturalParser.LINE_NUMBER)




            self.state = 1158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48 or _la==63:
                self.state = 1157
                _la = self._input.LA(1)
                if not(_la==48 or _la==63):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1161
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,171,self._ctx)
            if la_ == 1:
                self.state = 1160
                self.match(NaturalParser.WS)


            self.state = 1164
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 1163
                self.match(NaturalParser.WHEN)


            self.state = 1166
            self.match(NaturalParser.WS)
            self.state = 1167
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1171
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,173,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1168
                    self.statement() 
                self.state = 1173
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,173,self._ctx)

            self.state = 1174
            self.match(NaturalParser.END_DECIDE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifStructuredStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStructuredStatementContext,0)


        def ifElseStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfElseStatementContext,0)


        def ifMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfMultilinedStatementContext,0)


        def ifSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfSinglelinedStatementContext,0)


        def acceptRejectIfStatement(self):
            return self.getTypedRuleContext(NaturalParser.AcceptRejectIfStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifStatement




    def ifStatement(self):

        localctx = NaturalParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_ifStatement)
        try:
            self.state = 1181
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1176
                self.ifStructuredStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1177
                self.ifElseStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1178
                self.ifMultilinedStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1179
                self.ifSinglelinedStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1180
                self.acceptRejectIfStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStructuredStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def END_IF(self):
            return self.getToken(NaturalParser.END_IF, 0)

        def elseStructured(self):
            return self.getTypedRuleContext(NaturalParser.ElseStructuredContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_ifStructuredStatement




    def ifStructuredStatement(self):

        localctx = NaturalParser.IfStructuredStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_ifStructuredStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1183
            self.match(NaturalParser.IF)
            self.state = 1184
            self.match(NaturalParser.WS)
            self.state = 1185
            self.condition()
            self.state = 1189
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,175,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1186
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1191
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,175,self._ctx)

            self.state = 1193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1192
                self.match(NaturalParser.THEN)


            self.state = 1196 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1195
                self.statement()
                self.state = 1198 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0):
                    break

            self.state = 1202
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [18]:
                self.state = 1200
                self.match(NaturalParser.END_IF)
                pass
            elif token in [16]:
                self.state = 1201
                self.elseStructured()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseStructuredContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def END_IF(self):
            return self.getToken(NaturalParser.END_IF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_elseStructured




    def elseStructured(self):

        localctx = NaturalParser.ElseStructuredContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_elseStructured)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1204
            self.match(NaturalParser.ELSE)
            self.state = 1208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0 or (((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0 or (((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0 or (((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0 or (((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 140737488355327) != 0:
                self.state = 1205
                self.statement()
                self.state = 1210
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1211
            self.match(NaturalParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfElseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_ifElseStatement




    def ifElseStatement(self):

        localctx = NaturalParser.IfElseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_ifElseStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1213
            self.match(NaturalParser.IF)
            self.state = 1214
            self.match(NaturalParser.WS)
            self.state = 1215
            self.condition()
            self.state = 1222
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1216
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1217
                self.match(NaturalParser.NL)
                self.state = 1219
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1218
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1221
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1225
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1224
                self.match(NaturalParser.THEN)


            self.state = 1233
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1227
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1228
                self.match(NaturalParser.NL)
                self.state = 1230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1229
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1232
                self.match(NaturalParser.WS)
                pass
            elif token in [50]:
                pass
            else:
                pass
            self.state = 1235
            self.doStatement()
            self.state = 1242
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1236
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1237
                self.match(NaturalParser.NL)
                self.state = 1239
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1238
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1241
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1246
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
            if la_ == 1:
                self.state = 1244
                self.elseMultilinedStatement()
                pass

            elif la_ == 2:
                self.state = 1245
                self.elseSinglelinedStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfMultilinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifMultilinedStatement




    def ifMultilinedStatement(self):

        localctx = NaturalParser.IfMultilinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_ifMultilinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1248
            self.match(NaturalParser.IF)
            self.state = 1249
            self.match(NaturalParser.WS)
            self.state = 1250
            self.condition()
            self.state = 1254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                self.state = 1251
                _la = self._input.LA(1)
                if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1256
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1257
            self.match(NaturalParser.THEN)
            self.state = 1261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                self.state = 1258
                _la = self._input.LA(1)
                if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1263
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1264
            self.doStatement()
            self.state = 1276
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
            if la_ == 1:
                self.state = 1270
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,191,self._ctx)
                if la_ == 1:
                    self.state = 1265
                    self.match(NaturalParser.WS)
                    pass

                elif la_ == 2:
                    self.state = 1267
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1266
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1269
                    self.match(NaturalParser.WS)
                    pass


                self.state = 1274
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,192,self._ctx)
                if la_ == 1:
                    self.state = 1272
                    self.elseMultilinedStatement()
                    pass

                elif la_ == 2:
                    self.state = 1273
                    self.elseSinglelinedStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfSinglelinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def onelinerBody(self):
            return self.getTypedRuleContext(NaturalParser.OnelinerBodyContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifSinglelinedStatement




    def ifSinglelinedStatement(self):

        localctx = NaturalParser.IfSinglelinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_ifSinglelinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
            self.match(NaturalParser.IF)
            self.state = 1279
            self.match(NaturalParser.WS)
            self.state = 1280
            self.condition()
            self.state = 1284
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,194,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1281
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1286
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,194,self._ctx)

            self.state = 1288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1287
                self.match(NaturalParser.THEN)


            self.state = 1293
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,196,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1290
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1295
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,196,self._ctx)

            self.state = 1296
            self.onelinerBody()
            self.state = 1307
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
            if la_ == 1:
                self.state = 1300
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0:
                    self.state = 1297
                    _la = self._input.LA(1)
                    if not((((_la - 265)) & ~0x3f) == 0 and ((1 << (_la - 265)) & 6291457) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1302
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1305
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
                if la_ == 1:
                    self.state = 1303
                    self.elseMultilinedStatement()
                    pass

                elif la_ == 2:
                    self.state = 1304
                    self.elseSinglelinedStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseMultilinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_elseMultilinedStatement




    def elseMultilinedStatement(self):

        localctx = NaturalParser.ElseMultilinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_elseMultilinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1309
            self.match(NaturalParser.ELSE)
            self.state = 1316
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1310
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1311
                self.match(NaturalParser.NL)
                self.state = 1313
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1312
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1315
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1318
            self.doStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseSinglelinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def onelinerBody(self):
            return self.getTypedRuleContext(NaturalParser.OnelinerBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_elseSinglelinedStatement




    def elseSinglelinedStatement(self):

        localctx = NaturalParser.ElseSinglelinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_elseSinglelinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1320
            self.match(NaturalParser.ELSE)
            self.state = 1327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1321
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1322
                self.match(NaturalParser.NL)
                self.state = 1324
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1323
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1326
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1329
            self.onelinerBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnelinerBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(NaturalParser.StatementContext,0)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def EOF(self):
            return self.getToken(NaturalParser.EOF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_onelinerBody




    def onelinerBody(self):

        localctx = NaturalParser.OnelinerBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_onelinerBody)
        self._la = 0 # Token type
        try:
            self.state = 1347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,208,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1335
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,205,self._ctx)
                if la_ == 1:
                    self.state = 1332
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1331
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1334
                    self.match(NaturalParser.WS)


                self.state = 1337
                self.statement()
                self.state = 1338
                _la = self._input.LA(1)
                if not(_la==-1 or _la==287):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1344
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
                if la_ == 1:
                    self.state = 1341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1340
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1343
                    self.match(NaturalParser.WS)


                self.state = 1346
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def logicalOp(self):
            return self.getTypedRuleContext(NaturalParser.LogicalOpContext,0)


        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def optionalCondition(self):
            return self.getTypedRuleContext(NaturalParser.OptionalConditionContext,0)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NOT_TEXT(self):
            return self.getToken(NaturalParser.NOT_TEXT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_condition




    def condition(self):

        localctx = NaturalParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 1409
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,223,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1349
                self.operand()
                self.state = 1356
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [286]:
                    self.state = 1350
                    self.match(NaturalParser.WS)
                    pass
                elif token in [287]:
                    self.state = 1351
                    self.match(NaturalParser.NL)
                    self.state = 1353
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1352
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1355
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1361
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 292, 293]:
                    self.state = 1358
                    self.logicalOp()
                    pass
                elif token in [244, 245, 246, 247, 248, 249, 276, 277, 278, 279, 280, 281]:
                    self.state = 1359
                    self.compOp()
                    pass
                elif token in [272, 273, 274, 275]:
                    self.state = 1360
                    self.arithmaticOp()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1369
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [286]:
                    self.state = 1363
                    self.match(NaturalParser.WS)
                    pass
                elif token in [287]:
                    self.state = 1364
                    self.match(NaturalParser.NL)
                    self.state = 1366
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1365
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1368
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1371
                self.operand()
                self.state = 1381
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
                if la_ == 1:
                    self.state = 1378
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [286]:
                        self.state = 1372
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [287]:
                        self.state = 1373
                        self.match(NaturalParser.NL)
                        self.state = 1375
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==265:
                            self.state = 1374
                            self.match(NaturalParser.LINE_NUMBER)


                        self.state = 1377
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 292, 293]:
                        pass
                    else:
                        pass
                    self.state = 1380
                    self.optionalCondition()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1383
                self.operand()
                self.state = 1390
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,218,self._ctx)
                if la_ == 1:
                    self.state = 1384
                    self.match(NaturalParser.WS)

                elif la_ == 2:
                    self.state = 1385
                    self.match(NaturalParser.NL)
                    self.state = 1387
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1386
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1389
                    self.match(NaturalParser.WS)


                self.state = 1393
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,219,self._ctx)
                if la_ == 1:
                    self.state = 1392
                    self.optionalCondition()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1395
                self.match(NaturalParser.NOT_TEXT)
                self.state = 1396
                self.match(NaturalParser.WS)
                self.state = 1397
                self.operand()
                self.state = 1404
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
                if la_ == 1:
                    self.state = 1398
                    self.match(NaturalParser.WS)

                elif la_ == 2:
                    self.state = 1399
                    self.match(NaturalParser.NL)
                    self.state = 1401
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==265:
                        self.state = 1400
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1403
                    self.match(NaturalParser.WS)


                self.state = 1407
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
                if la_ == 1:
                    self.state = 1406
                    self.optionalCondition()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionalConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def logicalOp(self):
            return self.getTypedRuleContext(NaturalParser.LogicalOpContext,0)


        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def optionalCondition(self):
            return self.getTypedRuleContext(NaturalParser.OptionalConditionContext,0)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_optionalCondition




    def optionalCondition(self):

        localctx = NaturalParser.OptionalConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_optionalCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1414
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 292, 293]:
                self.state = 1411
                self.logicalOp()
                pass
            elif token in [244, 245, 246, 247, 248, 249, 276, 277, 278, 279, 280, 281]:
                self.state = 1412
                self.compOp()
                pass
            elif token in [272, 273, 274, 275]:
                self.state = 1413
                self.arithmaticOp()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1422
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [286]:
                self.state = 1416
                self.match(NaturalParser.WS)
                pass
            elif token in [287]:
                self.state = 1417
                self.match(NaturalParser.NL)
                self.state = 1419
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1418
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1421
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1424
            self.operand()
            self.state = 1431
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,228,self._ctx)
            if la_ == 1:
                self.state = 1425
                self.match(NaturalParser.WS)

            elif la_ == 2:
                self.state = 1426
                self.match(NaturalParser.NL)
                self.state = 1428
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==265:
                    self.state = 1427
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1430
                self.match(NaturalParser.WS)


            self.state = 1434
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,229,self._ctx)
            if la_ == 1:
                self.state = 1433
                self.optionalCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def FLOAT(self):
            return self.getToken(NaturalParser.FLOAT, 0)

        def naturalKeywords(self):
            return self.getTypedRuleContext(NaturalParser.NaturalKeywordsContext,0)


        def LPAREN(self):
            return self.getToken(NaturalParser.LPAREN, 0)

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def RPAREN(self):
            return self.getToken(NaturalParser.RPAREN, 0)

        def DATE_CONSTANT(self):
            return self.getToken(NaturalParser.DATE_CONSTANT, 0)

        def INPUT_PARAM(self):
            return self.getToken(NaturalParser.INPUT_PARAM, 0)

        def H_CONSTANT(self):
            return self.getToken(NaturalParser.H_CONSTANT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_operand




    def operand(self):

        localctx = NaturalParser.OperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_operand)
        try:
            self.state = 1448
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [284]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1436
                self.variable()
                pass
            elif token in [263]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1437
                self.match(NaturalParser.STRING)
                pass
            elif token in [265]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1438
                self.match(NaturalParser.LINE_NUMBER)
                pass
            elif token in [266]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1439
                self.match(NaturalParser.FLOAT)
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1440
                self.naturalKeywords()
                pass
            elif token in [282]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1441
                self.match(NaturalParser.LPAREN)
                self.state = 1442
                self.operand()
                self.state = 1443
                self.match(NaturalParser.RPAREN)
                pass
            elif token in [270]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1445
                self.match(NaturalParser.DATE_CONSTANT)
                pass
            elif token in [269]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1446
                self.match(NaturalParser.INPUT_PARAM)
                pass
            elif token in [271]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1447
                self.match(NaturalParser.H_CONSTANT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaturalKeywordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_naturalKeywords




    def naturalKeywords(self):

        localctx = NaturalParser.NaturalKeywordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_naturalKeywords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1450
            self.match(NaturalParser.POSITION)
            self.state = 1453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,231,self._ctx)
            if la_ == 1:
                self.state = 1451
                self.match(NaturalParser.WS)
                self.state = 1452
                self.match(NaturalParser.LINE_REF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND_TEXT(self):
            return self.getToken(NaturalParser.AND_TEXT, 0)

        def OR_TEXT(self):
            return self.getToken(NaturalParser.OR_TEXT, 0)

        def AND(self):
            return self.getToken(NaturalParser.AND, 0)

        def OR(self):
            return self.getToken(NaturalParser.OR, 0)

        def AND_EQ(self):
            return self.getToken(NaturalParser.AND_EQ, 0)

        def OR_RQ(self):
            return self.getToken(NaturalParser.OR_RQ, 0)

        def OR_SRQ(self):
            return self.getToken(NaturalParser.OR_SRQ, 0)

        def NOT_TEXT(self):
            return self.getToken(NaturalParser.NOT_TEXT, 0)

        def EQUAL(self):
            return self.getToken(NaturalParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(NaturalParser.NOTEQUAL, 0)

        def EQUAL_TO(self):
            return self.getToken(NaturalParser.EQUAL_TO, 0)

        def LESS_THAN(self):
            return self.getToken(NaturalParser.LESS_THAN, 0)

        def GREATER_THAN(self):
            return self.getToken(NaturalParser.GREATER_THAN, 0)

        def LESS_EQUAL(self):
            return self.getToken(NaturalParser.LESS_EQUAL, 0)

        def GREATER_EQUAL(self):
            return self.getToken(NaturalParser.GREATER_EQUAL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_logicalOp




    def logicalOp(self):

        localctx = NaturalParser.LogicalOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_logicalOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1455
            _la = self._input.LA(1)
            if not((((_la - 250)) & ~0x3f) == 0 and ((1 << (_la - 250)) & 13194139541503) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subroutineName = None # SubroutineNamesContext
            self.subroutineBody = None # BlockContentSubroutineContext

        def DEFINE_SUBROUTINE(self):
            return self.getToken(NaturalParser.DEFINE_SUBROUTINE, 0)

        def subroutineNames(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineNamesContext,0)


        def blockContentSubroutine(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentSubroutineContext,0)


        def END_SUBROUTINE(self):
            return self.getToken(NaturalParser.END_SUBROUTINE, 0)

        def RETURN(self):
            return self.getToken(NaturalParser.RETURN, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_subroutine




    def subroutine(self):

        localctx = NaturalParser.SubroutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_subroutine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1457
            self.match(NaturalParser.DEFINE_SUBROUTINE)
            self.state = 1459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1458
                self.match(NaturalParser.WS)


            self.state = 1461
            localctx.subroutineName = self.subroutineNames()
            self.state = 1463
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
            if la_ == 1:
                self.state = 1462
                self.match(NaturalParser.WS)


            self.state = 1465
            localctx.subroutineBody = self.blockContentSubroutine()
            self.state = 1466
            _la = self._input.LA(1)
            if not(_la==13 or _la==52):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContentSubroutineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subroutineStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.SubroutineStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.SubroutineStatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TRAILING_COMMENT(self):
            return self.getToken(NaturalParser.TRAILING_COMMENT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_blockContentSubroutine




    def blockContentSubroutine(self):

        localctx = NaturalParser.BlockContentSubroutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_blockContentSubroutine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1473
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,235,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1471
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,234,self._ctx)
                    if la_ == 1:
                        self.state = 1468
                        self.subroutineStatement()
                        pass

                    elif la_ == 2:
                        self.state = 1469
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 1470
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 1475
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,235,self._ctx)

            self.state = 1477
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==285:
                self.state = 1476
                self.match(NaturalParser.TRAILING_COMMENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataDefinition(self):
            return self.getTypedRuleContext(NaturalParser.DataDefinitionContext,0)


        def subroutine(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(NaturalParser.FunctionDefinitionContext,0)


        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(NaturalParser.ForStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStatementContext,0)


        def performStatement(self):
            return self.getTypedRuleContext(NaturalParser.PerformStatementContext,0)


        def callnatStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallnatStatementContext,0)


        def redefineStatement(self):
            return self.getTypedRuleContext(NaturalParser.RedefineStatementContext,0)


        def resetStatement(self):
            return self.getTypedRuleContext(NaturalParser.ResetStatementContext,0)


        def examineStatement(self):
            return self.getTypedRuleContext(NaturalParser.ExamineStatementContext,0)


        def moveStatement(self):
            return self.getTypedRuleContext(NaturalParser.MoveStatementContext,0)


        def findStatement(self):
            return self.getTypedRuleContext(NaturalParser.FindStatementContext,0)


        def readStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadStatementContext,0)


        def storeStatement(self):
            return self.getTypedRuleContext(NaturalParser.StoreStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(NaturalParser.DeleteStatementContext,0)


        def getStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetStatementsContext,0)


        def histogramStatement(self):
            return self.getTypedRuleContext(NaturalParser.HistogramStatementContext,0)


        def endTransaction(self):
            return self.getTypedRuleContext(NaturalParser.EndTransactionContext,0)


        def backoutTransaction(self):
            return self.getTypedRuleContext(NaturalParser.BackoutTransactionContext,0)


        def readworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileStatementContext,0)


        def writeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.WriteworkfileStatementContext,0)


        def closeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.CloseworkfileStatementContext,0)


        def inputStatement(self):
            return self.getTypedRuleContext(NaturalParser.InputStatementContext,0)


        def reinputStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReinputStatementContext,0)


        def calculations(self):
            return self.getTypedRuleContext(NaturalParser.CalculationsContext,0)


        def assignStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignStatementContext,0)


        def sortStatement(self):
            return self.getTypedRuleContext(NaturalParser.SortStatementContext,0)


        def compressStatement(self):
            return self.getTypedRuleContext(NaturalParser.CompressStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def repeatStatement(self):
            return self.getTypedRuleContext(NaturalParser.RepeatStatementContext,0)


        def atStartOfDataStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtStartOfDataStatementContext,0)


        def formatStatement(self):
            return self.getTypedRuleContext(NaturalParser.FormatStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,0)


        def includeStatement(self):
            return self.getTypedRuleContext(NaturalParser.IncludeStatementContext,0)


        def fetchStatement(self):
            return self.getTypedRuleContext(NaturalParser.FetchStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallStatementContext,0)


        def otherStatement(self):
            return self.getTypedRuleContext(NaturalParser.OtherStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_subroutineStatement




    def subroutineStatement(self):

        localctx = NaturalParser.SubroutineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_subroutineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1518
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,237,self._ctx)
            if la_ == 1:
                self.state = 1479
                self.dataDefinition()
                pass

            elif la_ == 2:
                self.state = 1480
                self.subroutine()
                pass

            elif la_ == 3:
                self.state = 1481
                self.functionDefinition()
                pass

            elif la_ == 4:
                self.state = 1482
                self.valueAssignment()
                pass

            elif la_ == 5:
                self.state = 1483
                self.forStatement()
                pass

            elif la_ == 6:
                self.state = 1484
                self.ifStatement()
                pass

            elif la_ == 7:
                self.state = 1485
                self.performStatement()
                pass

            elif la_ == 8:
                self.state = 1486
                self.callnatStatement()
                pass

            elif la_ == 9:
                self.state = 1487
                self.redefineStatement()
                pass

            elif la_ == 10:
                self.state = 1488
                self.resetStatement()
                pass

            elif la_ == 11:
                self.state = 1489
                self.examineStatement()
                pass

            elif la_ == 12:
                self.state = 1490
                self.moveStatement()
                pass

            elif la_ == 13:
                self.state = 1491
                self.findStatement()
                pass

            elif la_ == 14:
                self.state = 1492
                self.readStatement()
                pass

            elif la_ == 15:
                self.state = 1493
                self.storeStatement()
                pass

            elif la_ == 16:
                self.state = 1494
                self.updateStatement()
                pass

            elif la_ == 17:
                self.state = 1495
                self.deleteStatement()
                pass

            elif la_ == 18:
                self.state = 1496
                self.getStatements()
                pass

            elif la_ == 19:
                self.state = 1497
                self.histogramStatement()
                pass

            elif la_ == 20:
                self.state = 1498
                self.endTransaction()
                pass

            elif la_ == 21:
                self.state = 1499
                self.backoutTransaction()
                pass

            elif la_ == 22:
                self.state = 1500
                self.readworkfileStatement()
                pass

            elif la_ == 23:
                self.state = 1501
                self.writeworkfileStatement()
                pass

            elif la_ == 24:
                self.state = 1502
                self.closeworkfileStatement()
                pass

            elif la_ == 25:
                self.state = 1503
                self.inputStatement()
                pass

            elif la_ == 26:
                self.state = 1504
                self.reinputStatement()
                pass

            elif la_ == 27:
                self.state = 1505
                self.calculations()
                pass

            elif la_ == 28:
                self.state = 1506
                self.assignStatement()
                pass

            elif la_ == 29:
                self.state = 1507
                self.sortStatement()
                pass

            elif la_ == 30:
                self.state = 1508
                self.compressStatement()
                pass

            elif la_ == 31:
                self.state = 1509
                self.doStatement()
                pass

            elif la_ == 32:
                self.state = 1510
                self.repeatStatement()
                pass

            elif la_ == 33:
                self.state = 1511
                self.atStartOfDataStatement()
                pass

            elif la_ == 34:
                self.state = 1512
                self.formatStatement()
                pass

            elif la_ == 35:
                self.state = 1513
                self.assignmentStatement()
                pass

            elif la_ == 36:
                self.state = 1514
                self.includeStatement()
                pass

            elif la_ == 37:
                self.state = 1515
                self.fetchStatement()
                pass

            elif la_ == 38:
                self.state = 1516
                self.callStatement()
                pass

            elif la_ == 39:
                self.state = 1517
                self.otherStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.functionName = None # Token
            self.returnType = None # Token
            self.functionBody = None # BlockContentContext

        def DEFINE_FUNCTION(self):
            return self.getToken(NaturalParser.DEFINE_FUNCTION, 0)

        def RETURNS(self):
            return self.getToken(NaturalParser.RETURNS, 0)

        def END_FUNCTION(self):
            return self.getToken(NaturalParser.END_FUNCTION, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_functionDefinition




    def functionDefinition(self):

        localctx = NaturalParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1520
            self.match(NaturalParser.DEFINE_FUNCTION)
            self.state = 1522
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1521
                self.match(NaturalParser.WS)


            self.state = 1524
            localctx.functionName = self.match(NaturalParser.IDENTIFIER)
            self.state = 1526
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1525
                self.match(NaturalParser.WS)


            self.state = 1528
            self.match(NaturalParser.RETURNS)
            self.state = 1530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1529
                self.match(NaturalParser.WS)


            self.state = 1532
            localctx.returnType = self.match(NaturalParser.IDENTIFIER)
            self.state = 1534
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,241,self._ctx)
            if la_ == 1:
                self.state = 1533
                self.match(NaturalParser.WS)


            self.state = 1536
            localctx.functionBody = self.blockContent()
            self.state = 1538
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1537
                self.match(NaturalParser.WS)


            self.state = 1540
            self.match(NaturalParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TRAILING_COMMENT(self):
            return self.getToken(NaturalParser.TRAILING_COMMENT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_blockContent




    def blockContent(self):

        localctx = NaturalParser.BlockContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_blockContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1547
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,244,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1545
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,243,self._ctx)
                    if la_ == 1:
                        self.state = 1542
                        self.statement()
                        pass

                    elif la_ == 2:
                        self.state = 1543
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 1544
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 1549
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,244,self._ctx)

            self.state = 1551
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==285:
                self.state = 1550
                self.match(NaturalParser.TRAILING_COMMENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUE(self):
            return self.getToken(NaturalParser.VALUE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COMMA)
            else:
                return self.getToken(NaturalParser.COMMA, i)

        def ESCAPE_BOTTOM(self):
            return self.getToken(NaturalParser.ESCAPE_BOTTOM, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def NONE(self):
            return self.getToken(NaturalParser.NONE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_valueAssignment




    def valueAssignment(self):

        localctx = NaturalParser.ValueAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_valueAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1553
            self.match(NaturalParser.VALUE)
            self.state = 1555
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
            if la_ == 1:
                self.state = 1554
                self.match(NaturalParser.WS)


            self.state = 1558
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,247,self._ctx)
            if la_ == 1:
                self.state = 1557
                self.match(NaturalParser.STRING)


            self.state = 1561
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,248,self._ctx)
            if la_ == 1:
                self.state = 1560
                self.match(NaturalParser.WS)


            self.state = 1573
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,251,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1564
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 1563
                        self.match(NaturalParser.WS)


                    self.state = 1566
                    self.match(NaturalParser.COMMA)
                    self.state = 1568
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==286:
                        self.state = 1567
                        self.match(NaturalParser.WS)


                    self.state = 1570
                    self.match(NaturalParser.STRING) 
                self.state = 1575
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,251,self._ctx)

            self.state = 1577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,252,self._ctx)
            if la_ == 1:
                self.state = 1576
                self.match(NaturalParser.ESCAPE_BOTTOM)


            self.state = 1580
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,253,self._ctx)
            if la_ == 1:
                self.state = 1579
                self.match(NaturalParser.NL)


            self.state = 1583
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
            if la_ == 1:
                self.state = 1582
                self.match(NaturalParser.LINE_NUMBER)


            self.state = 1586
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,255,self._ctx)
            if la_ == 1:
                self.state = 1585
                self.match(NaturalParser.WS)


            self.state = 1589
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,256,self._ctx)
            if la_ == 1:
                self.state = 1588
                self.match(NaturalParser.NONE)


            self.state = 1592
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                self.state = 1591
                self.match(NaturalParser.WS)


            self.state = 1595
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,258,self._ctx)
            if la_ == 1:
                self.state = 1594
                self.match(NaturalParser.NL)


            self.state = 1598
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,259,self._ctx)
            if la_ == 1:
                self.state = 1597
                self.match(NaturalParser.WS)


            self.state = 1601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,260,self._ctx)
            if la_ == 1:
                self.state = 1600
                self.match(NaturalParser.IDENTIFIER)


            self.state = 1604
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,261,self._ctx)
            if la_ == 1:
                self.state = 1603
                self.match(NaturalParser.WS)


            self.state = 1607
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,262,self._ctx)
            if la_ == 1:
                self.state = 1606
                self.match(NaturalParser.COLON)


            self.state = 1610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,263,self._ctx)
            if la_ == 1:
                self.state = 1609
                self.match(NaturalParser.EQ)


            self.state = 1613
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
            if la_ == 1:
                self.state = 1612
                self.match(NaturalParser.WS)


            self.state = 1616
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
            if la_ == 1:
                self.state = 1615
                self.match(NaturalParser.STRING)


            self.state = 1619
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,266,self._ctx)
            if la_ == 1:
                self.state = 1618
                self.valueAssignment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(NaturalParser.ASSIGN, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_assignStatement




    def assignStatement(self):

        localctx = NaturalParser.AssignStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_assignStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1621
            self.match(NaturalParser.ASSIGN)
            self.state = 1623
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,267,self._ctx)
            if la_ == 1:
                self.state = 1622
                self.match(NaturalParser.WS)


            self.state = 1626
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==124:
                self.state = 1625
                self.match(NaturalParser.ROUNDED)


            self.state = 1629
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1628
                self.match(NaturalParser.WS)


            self.state = 1631
            self.variable()
            self.state = 1633
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1632
                self.match(NaturalParser.WS)


            self.state = 1636
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 1635
                self.match(NaturalParser.COLON)


            self.state = 1638
            self.match(NaturalParser.EQ)
            self.state = 1641 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1641
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [80, 263, 265, 266, 269, 270, 271, 282, 284]:
                        self.state = 1639
                        self.operand()
                        pass
                    elif token in [286]:
                        self.state = 1640
                        self.match(NaturalParser.WS)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 1643 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,273,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(NaturalParser.ADD, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_addOperation




    def addOperation(self):

        localctx = NaturalParser.AddOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_addOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1645
            self.match(NaturalParser.ADD)
            self.state = 1649
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,274,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1646
                    self.addContent() 
                self.state = 1651
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,274,self._ctx)

            self.state = 1653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,275,self._ctx)
            if la_ == 1:
                self.state = 1652
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplyOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTIPLY(self):
            return self.getToken(NaturalParser.MULTIPLY, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_multiplyOperation




    def multiplyOperation(self):

        localctx = NaturalParser.MultiplyOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_multiplyOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1655
            self.match(NaturalParser.MULTIPLY)
            self.state = 1659
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,276,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1656
                    self.addContent() 
                self.state = 1661
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,276,self._ctx)

            self.state = 1663
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.state = 1662
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubtractOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBTRACT(self):
            return self.getToken(NaturalParser.SUBTRACT, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_subtractOperation




    def subtractOperation(self):

        localctx = NaturalParser.SubtractOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_subtractOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1665
            self.match(NaturalParser.SUBTRACT)
            self.state = 1669
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,278,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1666
                    self.addContent() 
                self.state = 1671
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,278,self._ctx)

            self.state = 1673
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,279,self._ctx)
            if la_ == 1:
                self.state = 1672
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivideOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIVIDE(self):
            return self.getToken(NaturalParser.DIVIDE, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_divideOperation




    def divideOperation(self):

        localctx = NaturalParser.DivideOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_divideOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1675
            self.match(NaturalParser.DIVIDE)
            self.state = 1679
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,280,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1676
                    self.addContent() 
                self.state = 1681
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,280,self._ctx)

            self.state = 1683
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,281,self._ctx)
            if la_ == 1:
                self.state = 1682
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComputeOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPUTE(self):
            return self.getToken(NaturalParser.COMPUTE, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_computeOperation




    def computeOperation(self):

        localctx = NaturalParser.ComputeOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_computeOperation)
        self._la = 0 # Token type
        try:
            self.state = 1744
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,298,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1685
                self.match(NaturalParser.COMPUTE)
                self.state = 1687
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,282,self._ctx)
                if la_ == 1:
                    self.state = 1686
                    self.match(NaturalParser.WS)


                self.state = 1690
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==124:
                    self.state = 1689
                    self.match(NaturalParser.ROUNDED)


                self.state = 1693
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1692
                    self.match(NaturalParser.WS)


                self.state = 1695
                self.variable()
                self.state = 1697
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1696
                    self.match(NaturalParser.WS)


                self.state = 1700
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264:
                    self.state = 1699
                    self.match(NaturalParser.COLON)


                self.state = 1702
                self.match(NaturalParser.EQ)
                self.state = 1704
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1703
                    self.match(NaturalParser.WS)


                self.state = 1706
                self.operand()
                self.state = 1708
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1707
                    self.match(NaturalParser.WS)


                self.state = 1710
                self.arithmaticOp()
                self.state = 1712
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1711
                    self.match(NaturalParser.WS)


                self.state = 1714
                self.operand()
                self.state = 1716
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,290,self._ctx)
                if la_ == 1:
                    self.state = 1715
                    self.match(NaturalParser.WS)


                self.state = 1719
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,291,self._ctx)
                if la_ == 1:
                    self.state = 1718
                    self.optionalCompute()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1721
                self.match(NaturalParser.COMPUTE)
                self.state = 1723
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,292,self._ctx)
                if la_ == 1:
                    self.state = 1722
                    self.match(NaturalParser.WS)


                self.state = 1726
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==124:
                    self.state = 1725
                    self.match(NaturalParser.ROUNDED)


                self.state = 1729
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1728
                    self.match(NaturalParser.WS)


                self.state = 1731
                self.variable()
                self.state = 1733
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1732
                    self.match(NaturalParser.WS)


                self.state = 1736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==264:
                    self.state = 1735
                    self.match(NaturalParser.COLON)


                self.state = 1738
                self.match(NaturalParser.EQ)
                self.state = 1740
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==286:
                    self.state = 1739
                    self.match(NaturalParser.WS)


                self.state = 1742
                self.operand()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmaticOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_arithmaticOperation




    def arithmaticOperation(self):

        localctx = NaturalParser.ArithmaticOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_arithmaticOperation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1746
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1748
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1747
                self.match(NaturalParser.WS)


            self.state = 1751
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==264:
                self.state = 1750
                self.match(NaturalParser.COLON)


            self.state = 1753
            self.match(NaturalParser.EQ)
            self.state = 1755
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1754
                self.match(NaturalParser.WS)


            self.state = 1757
            self.operand()
            self.state = 1759
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1758
                self.match(NaturalParser.WS)


            self.state = 1761
            self.arithmaticOp()
            self.state = 1763
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1762
                self.match(NaturalParser.WS)


            self.state = 1765
            self.operand()
            self.state = 1767
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,304,self._ctx)
            if la_ == 1:
                self.state = 1766
                self.match(NaturalParser.WS)


            self.state = 1770
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,305,self._ctx)
            if la_ == 1:
                self.state = 1769
                self.optionalCompute()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionalComputeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_optionalCompute




    def optionalCompute(self):

        localctx = NaturalParser.OptionalComputeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_optionalCompute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1772
            self.arithmaticOp()
            self.state = 1774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==286:
                self.state = 1773
                self.match(NaturalParser.WS)


            self.state = 1776
            self.operand()
            self.state = 1778
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,307,self._ctx)
            if la_ == 1:
                self.state = 1777
                self.match(NaturalParser.WS)


            self.state = 1781
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
            if la_ == 1:
                self.state = 1780
                self.optionalCompute()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalculationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addOperation(self):
            return self.getTypedRuleContext(NaturalParser.AddOperationContext,0)


        def subtractOperation(self):
            return self.getTypedRuleContext(NaturalParser.SubtractOperationContext,0)


        def multiplyOperation(self):
            return self.getTypedRuleContext(NaturalParser.MultiplyOperationContext,0)


        def divideOperation(self):
            return self.getTypedRuleContext(NaturalParser.DivideOperationContext,0)


        def computeOperation(self):
            return self.getTypedRuleContext(NaturalParser.ComputeOperationContext,0)


        def arithmaticOperation(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOperationContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_calculations




    def calculations(self):

        localctx = NaturalParser.CalculationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_calculations)
        try:
            self.state = 1789
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1783
                self.addOperation()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1784
                self.subtractOperation()
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1785
                self.multiplyOperation()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1786
                self.divideOperation()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1787
                self.computeOperation()
                pass
            elif token in [284]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1788
                self.arithmaticOperation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LITERAL(self):
            return self.getToken(NaturalParser.LITERAL, 0)

        def FLOAT(self):
            return self.getToken(NaturalParser.FLOAT, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def GIVING(self):
            return self.getToken(NaturalParser.GIVING, 0)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_addContent




    def addContent(self):

        localctx = NaturalParser.AddContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_addContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1791
            _la = self._input.LA(1)
            if not(_la==49 or _la==96 or _la==124 or (((_la - 263)) & ~0x3f) == 0 and ((1 << (_la - 263)) & 10485789) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT_TEXT(self):
            return self.getToken(NaturalParser.GT_TEXT, 0)

        def LT_TEXT(self):
            return self.getToken(NaturalParser.LT_TEXT, 0)

        def GE_TEXT(self):
            return self.getToken(NaturalParser.GE_TEXT, 0)

        def LE_TEXT(self):
            return self.getToken(NaturalParser.LE_TEXT, 0)

        def EQ_TEXT(self):
            return self.getToken(NaturalParser.EQ_TEXT, 0)

        def NE_TEXT(self):
            return self.getToken(NaturalParser.NE_TEXT, 0)

        def GT(self):
            return self.getToken(NaturalParser.GT, 0)

        def LT(self):
            return self.getToken(NaturalParser.LT, 0)

        def GE(self):
            return self.getToken(NaturalParser.GE, 0)

        def LE(self):
            return self.getToken(NaturalParser.LE, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def NE(self):
            return self.getToken(NaturalParser.NE, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_compOp




    def compOp(self):

        localctx = NaturalParser.CompOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_compOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1793
            _la = self._input.LA(1)
            if not((((_la - 244)) & ~0x3f) == 0 and ((1 << (_la - 244)) & 270582939711) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmaticOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(NaturalParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(NaturalParser.MINUS, 0)

        def MULT(self):
            return self.getToken(NaturalParser.MULT, 0)

        def DIV(self):
            return self.getToken(NaturalParser.DIV, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_arithmaticOp




    def arithmaticOp(self):

        localctx = NaturalParser.ArithmaticOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_arithmaticOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1795
            _la = self._input.LA(1)
            if not((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & 15) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ(self):
            return self.getToken(NaturalParser.READ, 0)

        def FIND(self):
            return self.getToken(NaturalParser.FIND, 0)

        def HISTOGRAM(self):
            return self.getToken(NaturalParser.HISTOGRAM, 0)

        def GET(self):
            return self.getToken(NaturalParser.GET, 0)

        def GET_SAME(self):
            return self.getToken(NaturalParser.GET_SAME, 0)

        def PASSW(self):
            return self.getToken(NaturalParser.PASSW, 0)

        def LIMIT(self):
            return self.getToken(NaturalParser.LIMIT, 0)

        def STORE(self):
            return self.getToken(NaturalParser.STORE, 0)

        def UPDATE(self):
            return self.getToken(NaturalParser.UPDATE, 0)

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def END_TRANSACTION(self):
            return self.getToken(NaturalParser.END_TRANSACTION, 0)

        def BACKOUT_TRANSACTION(self):
            return self.getToken(NaturalParser.BACKOUT_TRANSACTION, 0)

        def GET_TRANSACTION_DATA(self):
            return self.getToken(NaturalParser.GET_TRANSACTION_DATA, 0)

        def RETRY(self):
            return self.getToken(NaturalParser.RETRY, 0)

        def AT_START_OF_DATA(self):
            return self.getToken(NaturalParser.AT_START_OF_DATA, 0)

        def AT_END_OF_DATA(self):
            return self.getToken(NaturalParser.AT_END_OF_DATA, 0)

        def AT_BREAK(self):
            return self.getToken(NaturalParser.AT_BREAK, 0)

        def BEFORE_BREAK_PROCESSING(self):
            return self.getToken(NaturalParser.BEFORE_BREAK_PROCESSING, 0)

        def PERFORM_BREAK_PROCESSING(self):
            return self.getToken(NaturalParser.PERFORM_BREAK_PROCESSING, 0)

        def CALLDBPROC(self):
            return self.getToken(NaturalParser.CALLDBPROC, 0)

        def COMMIT(self):
            return self.getToken(NaturalParser.COMMIT, 0)

        def INSERT(self):
            return self.getToken(NaturalParser.INSERT, 0)

        def PROCESS_SQL(self):
            return self.getToken(NaturalParser.PROCESS_SQL, 0)

        def READ_RESULT_SET(self):
            return self.getToken(NaturalParser.READ_RESULT_SET, 0)

        def ROLLBACK(self):
            return self.getToken(NaturalParser.ROLLBACK, 0)

        def SELECT(self):
            return self.getToken(NaturalParser.SELECT, 0)

        def COMPUTE(self):
            return self.getToken(NaturalParser.COMPUTE, 0)

        def ADD(self):
            return self.getToken(NaturalParser.ADD, 0)

        def SUBTRACT(self):
            return self.getToken(NaturalParser.SUBTRACT, 0)

        def MULTIPLY(self):
            return self.getToken(NaturalParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(NaturalParser.DIVIDE, 0)

        def MOVE(self):
            return self.getToken(NaturalParser.MOVE, 0)

        def COMPRESS(self):
            return self.getToken(NaturalParser.COMPRESS, 0)

        def SEPARATE(self):
            return self.getToken(NaturalParser.SEPARATE, 0)

        def EXAMINE(self):
            return self.getToken(NaturalParser.EXAMINE, 0)

        def RESET(self):
            return self.getToken(NaturalParser.RESET, 0)

        def ESCAPE(self):
            return self.getToken(NaturalParser.ESCAPE, 0)

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def SORT(self):
            return self.getToken(NaturalParser.SORT, 0)

        def FORMAT(self):
            return self.getToken(NaturalParser.FORMAT, 0)

        def DISPLAY(self):
            return self.getToken(NaturalParser.DISPLAY, 0)

        def WRITE(self):
            return self.getToken(NaturalParser.WRITE, 0)

        def WRITE_TITLE(self):
            return self.getToken(NaturalParser.WRITE_TITLE, 0)

        def WRITE_TRAILER(self):
            return self.getToken(NaturalParser.WRITE_TRAILER, 0)

        def AT_TOP_OF_PAGE(self):
            return self.getToken(NaturalParser.AT_TOP_OF_PAGE, 0)

        def AT_END_OF_PAGE(self):
            return self.getToken(NaturalParser.AT_END_OF_PAGE, 0)

        def EJECT(self):
            return self.getToken(NaturalParser.EJECT, 0)

        def NEWPAGE(self):
            return self.getToken(NaturalParser.NEWPAGE, 0)

        def SUSPEND_IDENTICAL_SUPPRESS(self):
            return self.getToken(NaturalParser.SUSPEND_IDENTICAL_SUPPRESS, 0)

        def DEFINE_PRINTER(self):
            return self.getToken(NaturalParser.DEFINE_PRINTER, 0)

        def CLOSE_PRINTER(self):
            return self.getToken(NaturalParser.CLOSE_PRINTER, 0)

        def INPUT(self):
            return self.getToken(NaturalParser.INPUT, 0)

        def REINPUT(self):
            return self.getToken(NaturalParser.REINPUT, 0)

        def DEFINE_WINDOW(self):
            return self.getToken(NaturalParser.DEFINE_WINDOW, 0)

        def SET_WINDOW(self):
            return self.getToken(NaturalParser.SET_WINDOW, 0)

        def PROCESS_PAGE(self):
            return self.getToken(NaturalParser.PROCESS_PAGE, 0)

        def PROCESS_PAGE_USING(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_USING, 0)

        def PROCESS_PAGE_UPDATE(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_UPDATE, 0)

        def PROCESS_PAGE_MODAL(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_MODAL, 0)

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def IF_SELECTION(self):
            return self.getToken(NaturalParser.IF_SELECTION, 0)

        def DECIDE_FOR(self):
            return self.getToken(NaturalParser.DECIDE_FOR, 0)

        def DECIDE_ON(self):
            return self.getToken(NaturalParser.DECIDE_ON, 0)

        def CALL(self):
            return self.getToken(NaturalParser.CALL, 0)

        def CALLNAT(self):
            return self.getToken(NaturalParser.CALLNAT, 0)

        def CALL_FILE(self):
            return self.getToken(NaturalParser.CALL_FILE, 0)

        def CALL_LOOP(self):
            return self.getToken(NaturalParser.CALL_LOOP, 0)

        def DEFINE_SUBROUTINE(self):
            return self.getToken(NaturalParser.DEFINE_SUBROUTINE, 0)

        def FETCH(self):
            return self.getToken(NaturalParser.FETCH, 0)

        def PERFORM(self):
            return self.getToken(NaturalParser.PERFORM, 0)

        def PROCESS_COMMAND(self):
            return self.getToken(NaturalParser.PROCESS_COMMAND, 0)

        def RUN(self):
            return self.getToken(NaturalParser.RUN, 0)

        def DEFINE_FUNCTION(self):
            return self.getToken(NaturalParser.DEFINE_FUNCTION, 0)

        def DEFINE_PROTOTYPE(self):
            return self.getToken(NaturalParser.DEFINE_PROTOTYPE, 0)

        def FUNCTION_CALL(self):
            return self.getToken(NaturalParser.FUNCTION_CALL, 0)

        def STOP(self):
            return self.getToken(NaturalParser.STOP, 0)

        def TERMINATE(self):
            return self.getToken(NaturalParser.TERMINATE, 0)

        def WRITE_WORK_FILE(self):
            return self.getToken(NaturalParser.WRITE_WORK_FILE, 0)

        def DOWNLOAD_PC_FILE(self):
            return self.getToken(NaturalParser.DOWNLOAD_PC_FILE, 0)

        def READ_WORK_FILE(self):
            return self.getToken(NaturalParser.READ_WORK_FILE, 0)

        def UPLOAD_PC_FILE(self):
            return self.getToken(NaturalParser.UPLOAD_PC_FILE, 0)

        def CLOSE_WORK_FILE(self):
            return self.getToken(NaturalParser.CLOSE_WORK_FILE, 0)

        def CLOSE_PC_FILE(self):
            return self.getToken(NaturalParser.CLOSE_PC_FILE, 0)

        def DEFINE_WORK_FILE(self):
            return self.getToken(NaturalParser.DEFINE_WORK_FILE, 0)

        def DEFINE_CLASS(self):
            return self.getToken(NaturalParser.DEFINE_CLASS, 0)

        def CREATE_OBJECT(self):
            return self.getToken(NaturalParser.CREATE_OBJECT, 0)

        def SEND_METHOD(self):
            return self.getToken(NaturalParser.SEND_METHOD, 0)

        def INTERFACE(self):
            return self.getToken(NaturalParser.INTERFACE, 0)

        def METHOD(self):
            return self.getToken(NaturalParser.METHOD, 0)

        def PROPERTY(self):
            return self.getToken(NaturalParser.PROPERTY, 0)

        def EXPAND(self):
            return self.getToken(NaturalParser.EXPAND, 0)

        def REDUCE(self):
            return self.getToken(NaturalParser.REDUCE, 0)

        def RESIZE(self):
            return self.getToken(NaturalParser.RESIZE, 0)

        def OPEN_CONVERSATION(self):
            return self.getToken(NaturalParser.OPEN_CONVERSATION, 0)

        def CLOSE_CONVERSATION(self):
            return self.getToken(NaturalParser.CLOSE_CONVERSATION, 0)

        def DEFINE_DATA_CONTEXT(self):
            return self.getToken(NaturalParser.DEFINE_DATA_CONTEXT, 0)

        def PARSE(self):
            return self.getToken(NaturalParser.PARSE, 0)

        def REQUEST_DOCUMENT(self):
            return self.getToken(NaturalParser.REQUEST_DOCUMENT, 0)

        def DEFINE_DATA(self):
            return self.getToken(NaturalParser.DEFINE_DATA, 0)

        def END(self):
            return self.getToken(NaturalParser.END, 0)

        def INCLUDE(self):
            return self.getToken(NaturalParser.INCLUDE, 0)

        def ON_ERROR(self):
            return self.getToken(NaturalParser.ON_ERROR, 0)

        def RELEASE(self):
            return self.getToken(NaturalParser.RELEASE, 0)

        def SET_CONTROL(self):
            return self.getToken(NaturalParser.SET_CONTROL, 0)

        def SET_KEY(self):
            return self.getToken(NaturalParser.SET_KEY, 0)

        def SET_GLOBALS(self):
            return self.getToken(NaturalParser.SET_GLOBALS, 0)

        def SET_TIME(self):
            return self.getToken(NaturalParser.SET_TIME, 0)

        def STACK(self):
            return self.getToken(NaturalParser.STACK, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def OBTAIN(self):
            return self.getToken(NaturalParser.OBTAIN, 0)

        def REDEFINE(self):
            return self.getToken(NaturalParser.REDEFINE, 0)

        def END_START(self):
            return self.getToken(NaturalParser.END_START, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_endStatement




    def endStatement(self):

        localctx = NaturalParser.EndStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_endStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1797
            _la = self._input.LA(1)
            if not(((_la) & ~0x3f) == 0 and ((1 << _la) & 3498452474803539712) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 6919640090553618905) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -2305843019011588099) != 0 or (((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 33585661) != 0):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IF)
            else:
                return self.getToken(NaturalParser.IF, i)

        def ELSE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ELSE)
            else:
                return self.getToken(NaturalParser.ELSE, i)

        def DECIDE_FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DECIDE_FOR)
            else:
                return self.getToken(NaturalParser.DECIDE_FOR, i)

        def DECIDE_ON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DECIDE_ON)
            else:
                return self.getToken(NaturalParser.DECIDE_ON, i)

        def DEFINE_SUBROUTINE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DEFINE_SUBROUTINE)
            else:
                return self.getToken(NaturalParser.DEFINE_SUBROUTINE, i)

        def DEFINE_FUNCTION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DEFINE_FUNCTION)
            else:
                return self.getToken(NaturalParser.DEFINE_FUNCTION, i)

        def RETURN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RETURN)
            else:
                return self.getToken(NaturalParser.RETURN, i)

        def VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VALUE)
            else:
                return self.getToken(NaturalParser.VALUE, i)

        def CALLNAT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.CALLNAT)
            else:
                return self.getToken(NaturalParser.CALLNAT, i)

        def PERFORM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PERFORM)
            else:
                return self.getToken(NaturalParser.PERFORM, i)

        def FIND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FIND)
            else:
                return self.getToken(NaturalParser.FIND, i)

        def STORE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STORE)
            else:
                return self.getToken(NaturalParser.STORE, i)

        def INPUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.INPUT)
            else:
                return self.getToken(NaturalParser.INPUT, i)

        def REINPUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.REINPUT)
            else:
                return self.getToken(NaturalParser.REINPUT, i)

        def DOEND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DOEND)
            else:
                return self.getToken(NaturalParser.DOEND, i)

        def END_IF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_IF)
            else:
                return self.getToken(NaturalParser.END_IF, i)

        def END_FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_FOR)
            else:
                return self.getToken(NaturalParser.END_FOR, i)

        def LOOP(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LOOP)
            else:
                return self.getToken(NaturalParser.LOOP, i)

        def DO(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DO)
            else:
                return self.getToken(NaturalParser.DO, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THEN)
            else:
                return self.getToken(NaturalParser.THEN, i)

        def RESET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RESET)
            else:
                return self.getToken(NaturalParser.RESET, i)

        def REDEFINE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.REDEFINE)
            else:
                return self.getToken(NaturalParser.REDEFINE, i)

        def GET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.GET)
            else:
                return self.getToken(NaturalParser.GET, i)

        def UPDATE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.UPDATE)
            else:
                return self.getToken(NaturalParser.UPDATE, i)

        def READ(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.READ)
            else:
                return self.getToken(NaturalParser.READ, i)

        def MOVE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.MOVE)
            else:
                return self.getToken(NaturalParser.MOVE, i)

        def AT_START_OF_DATA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AT_START_OF_DATA)
            else:
                return self.getToken(NaturalParser.AT_START_OF_DATA, i)

        def FORMAT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FORMAT)
            else:
                return self.getToken(NaturalParser.FORMAT, i)

        def INCLUDE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.INCLUDE)
            else:
                return self.getToken(NaturalParser.INCLUDE, i)

        def HISTOGRAM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.HISTOGRAM)
            else:
                return self.getToken(NaturalParser.HISTOGRAM, i)

        def END_HISTOGRAM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_HISTOGRAM)
            else:
                return self.getToken(NaturalParser.END_HISTOGRAM, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_otherStatement




    def otherStatement(self):

        localctx = NaturalParser.OtherStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_otherStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1800 
            self._errHandler.sync(self)
            _alt = 1+1
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1+1:
                    self.state = 1799
                    _la = self._input.LA(1)
                    if _la <= 0 or ((_la) & ~0x3f) == 0 and ((1 << _la) & -9183821663005448448) != 0 or (((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 4177) != 0 or (((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 2251799813734401) != 0 or (((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & 12289) != 0:
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 1802 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,310,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





