# Generated from NaturalParser.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,312,2046,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,
        7,6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,
        13,2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,
        20,7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,
        26,2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,
        33,7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,
        39,2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,
        46,7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,
        52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,
        59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,
        65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,
        72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,
        78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,
        85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
        91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,
        98,7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,
        1,0,1,0,1,0,1,0,4,0,213,8,0,11,0,12,0,214,1,1,1,1,3,1,219,8,1,1,
        1,1,1,1,2,3,2,224,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
        2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,
        2,268,8,2,1,3,1,3,1,4,1,4,4,4,274,8,4,11,4,12,4,275,1,4,1,4,1,5,
        1,5,5,5,282,8,5,10,5,12,5,285,9,5,1,5,1,5,1,5,4,5,290,8,5,11,5,12,
        5,291,1,5,1,5,5,5,296,8,5,10,5,12,5,299,9,5,1,5,1,5,5,5,303,8,5,
        10,5,12,5,306,9,5,1,5,3,5,309,8,5,1,6,1,6,1,6,1,6,3,6,315,8,6,1,
        6,3,6,318,8,6,1,6,1,6,3,6,322,8,6,1,6,3,6,325,8,6,1,7,1,7,1,7,1,
        7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,4,7,338,8,7,11,7,12,7,339,1,7,3,7,
        343,8,7,1,8,1,8,1,9,5,9,348,8,9,10,9,12,9,351,9,9,1,9,3,9,354,8,
        9,1,9,3,9,357,8,9,1,9,1,9,3,9,361,8,9,1,9,1,9,1,10,1,10,3,10,367,
        8,10,1,10,3,10,370,8,10,1,10,1,10,1,10,3,10,375,8,10,1,11,1,11,1,
        11,3,11,380,8,11,1,11,1,11,3,11,384,8,11,1,11,1,11,1,11,5,11,389,
        8,11,10,11,12,11,392,9,11,1,11,1,11,3,11,396,8,11,1,12,1,12,1,12,
        1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,412,
        8,12,1,13,1,13,5,13,416,8,13,10,13,12,13,419,9,13,1,13,1,13,1,14,
        1,14,1,14,1,14,1,14,1,14,1,14,1,14,4,14,431,8,14,11,14,12,14,432,
        1,14,1,14,1,15,1,15,1,16,1,16,3,16,441,8,16,1,16,1,16,1,16,4,16,
        446,8,16,11,16,12,16,447,1,16,3,16,451,8,16,1,16,1,16,1,16,4,16,
        456,8,16,11,16,12,16,457,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,
        1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,1,17,3,17,477,8,17,1,18,
        1,18,5,18,481,8,18,10,18,12,18,484,9,18,1,18,1,18,1,19,1,19,5,19,
        490,8,19,10,19,12,19,493,9,19,1,19,1,19,1,20,1,20,3,20,499,8,20,
        1,20,3,20,502,8,20,1,20,3,20,505,8,20,1,20,3,20,508,8,20,1,20,3,
        20,511,8,20,1,20,3,20,514,8,20,1,20,3,20,517,8,20,1,20,1,20,3,20,
        521,8,20,1,20,3,20,524,8,20,1,20,3,20,527,8,20,1,20,3,20,530,8,20,
        1,20,3,20,533,8,20,1,20,3,20,536,8,20,1,20,5,20,539,8,20,10,20,12,
        20,542,9,20,1,20,3,20,545,8,20,1,20,3,20,548,8,20,1,20,5,20,551,
        8,20,10,20,12,20,554,9,20,1,21,1,21,1,21,3,21,559,8,21,1,21,1,21,
        3,21,563,8,21,1,21,3,21,566,8,21,1,21,1,21,1,21,3,21,571,8,21,1,
        21,1,21,3,21,575,8,21,1,21,3,21,578,8,21,1,21,1,21,3,21,582,8,21,
        1,21,3,21,585,8,21,1,21,3,21,588,8,21,3,21,590,8,21,1,22,3,22,593,
        8,22,1,22,5,22,596,8,22,10,22,12,22,599,9,22,1,22,1,22,3,22,603,
        8,22,1,22,3,22,606,8,22,1,22,3,22,609,8,22,1,22,3,22,612,8,22,1,
        22,3,22,615,8,22,1,22,3,22,618,8,22,1,22,3,22,621,8,22,1,22,1,22,
        3,22,625,8,22,1,22,3,22,628,8,22,1,22,3,22,631,8,22,1,22,5,22,634,
        8,22,10,22,12,22,637,9,22,1,22,3,22,640,8,22,1,22,1,22,3,22,644,
        8,22,1,22,3,22,647,8,22,5,22,649,8,22,10,22,12,22,652,9,22,1,22,
        5,22,655,8,22,10,22,12,22,658,9,22,1,22,1,22,1,23,1,23,1,23,1,23,
        1,23,3,23,667,8,23,1,24,1,24,1,24,1,24,1,24,5,24,674,8,24,10,24,
        12,24,677,9,24,1,24,1,24,3,24,681,8,24,1,24,1,24,1,24,1,25,1,25,
        1,25,1,25,1,25,1,25,1,25,5,25,693,8,25,10,25,12,25,696,9,25,1,25,
        1,25,3,25,700,8,25,1,25,1,25,1,25,1,26,1,26,1,26,1,26,1,26,1,26,
        3,26,711,8,26,1,26,1,26,1,26,3,26,716,8,26,1,26,1,26,1,26,4,26,721,
        8,26,11,26,12,26,722,3,26,725,8,26,1,27,1,27,1,27,1,27,1,27,1,27,
        1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,1,27,
        1,27,1,27,1,27,1,27,1,27,1,27,5,27,752,8,27,10,27,12,27,755,9,27,
        1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,5,29,766,8,29,10,29,
        12,29,769,9,29,1,29,1,29,3,29,773,8,29,1,29,1,29,1,29,1,30,1,30,
        1,30,1,30,3,30,782,8,30,1,30,1,30,1,30,3,30,787,8,30,1,30,1,30,1,
        30,4,30,792,8,30,11,30,12,30,793,3,30,796,8,30,1,31,1,31,1,31,1,
        31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
        31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
        31,1,31,1,31,5,31,830,8,31,10,31,12,31,833,9,31,1,32,1,32,4,32,837,
        8,32,11,32,12,32,838,1,32,3,32,842,8,32,1,32,1,32,1,32,1,32,1,32,
        3,32,849,8,32,1,32,3,32,852,8,32,1,32,1,32,3,32,856,8,32,1,32,1,
        32,1,32,4,32,861,8,32,11,32,12,32,862,1,32,3,32,866,8,32,1,32,1,
        32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,878,8,32,1,32,1,
        32,1,32,1,32,3,32,884,8,32,1,32,1,32,3,32,888,8,32,1,33,1,33,3,33,
        892,8,33,1,33,3,33,895,8,33,1,33,3,33,898,8,33,1,33,3,33,901,8,33,
        1,33,3,33,904,8,33,1,33,3,33,907,8,33,1,33,3,33,910,8,33,1,33,3,
        33,913,8,33,1,34,1,34,3,34,917,8,34,1,34,3,34,920,8,34,1,35,1,35,
        1,35,3,35,925,8,35,1,36,1,36,1,36,1,36,1,36,5,36,932,8,36,10,36,
        12,36,935,9,36,1,36,1,36,3,36,939,8,36,1,36,1,36,1,37,1,37,1,38,
        1,38,4,38,947,8,38,11,38,12,38,948,1,38,1,38,1,39,1,39,3,39,955,
        8,39,1,39,3,39,958,8,39,1,39,5,39,961,8,39,10,39,12,39,964,9,39,
        1,39,1,39,1,40,1,40,5,40,970,8,40,10,40,12,40,973,9,40,1,40,1,40,
        1,41,1,41,3,41,979,8,41,1,41,1,41,1,41,1,41,5,41,985,8,41,10,41,
        12,41,988,9,41,1,41,1,41,5,41,992,8,41,10,41,12,41,995,9,41,1,41,
        3,41,998,8,41,1,41,1,41,1,42,1,42,1,42,1,42,3,42,1006,8,42,1,42,
        1,42,1,42,4,42,1011,8,42,11,42,12,42,1012,3,42,1015,8,42,1,43,1,
        43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
        43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,
        43,1,43,5,43,1046,8,43,10,43,12,43,1049,9,43,1,43,1,43,1,44,1,44,
        1,45,1,45,1,46,1,46,1,46,1,46,3,46,1061,8,46,1,46,3,46,1064,8,46,
        1,46,1,46,1,46,1,46,1,46,1,46,1,46,3,46,1073,8,46,1,46,3,46,1076,
        8,46,1,46,1,46,4,46,1080,8,46,11,46,12,46,1081,1,46,1,46,1,46,1,
        46,1,46,1,46,3,46,1090,8,46,1,46,3,46,1093,8,46,1,46,1,46,4,46,1097,
        8,46,11,46,12,46,1098,1,46,1,46,3,46,1103,8,46,1,47,1,47,1,48,1,
        48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,1,48,5,48,1119,8,
        48,10,48,12,48,1122,9,48,1,49,1,49,5,49,1126,8,49,10,49,12,49,1129,
        9,49,1,49,1,49,1,50,1,50,1,50,1,50,3,50,1137,8,50,1,50,3,50,1140,
        8,50,1,50,1,50,1,50,1,50,5,50,1146,8,50,10,50,12,50,1149,9,50,1,
        50,1,50,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,5,52,1161,8,52,10,
        52,12,52,1164,9,52,1,52,1,52,1,53,1,53,3,53,1170,8,53,1,53,3,53,
        1173,8,53,1,53,3,53,1176,8,53,1,53,1,53,3,53,1180,8,53,1,53,5,53,
        1183,8,53,10,53,12,53,1186,9,53,1,53,1,53,1,54,1,54,5,54,1192,8,
        54,10,54,12,54,1195,9,54,1,54,1,54,3,54,1199,8,54,1,54,3,54,1202,
        8,54,1,54,3,54,1205,8,54,5,54,1207,8,54,10,54,12,54,1210,9,54,1,
        55,1,55,3,55,1214,8,55,1,55,1,55,3,55,1218,8,55,1,56,1,56,1,56,1,
        56,1,57,1,57,5,57,1226,8,57,10,57,12,57,1229,9,57,1,57,1,57,3,57,
        1233,8,57,1,57,3,57,1236,8,57,1,57,3,57,1239,8,57,1,58,1,58,3,58,
        1243,8,58,1,58,1,58,1,59,1,59,1,59,5,59,1250,8,59,10,59,12,59,1253,
        9,59,1,59,1,59,1,60,1,60,3,60,1259,8,60,1,60,1,60,1,61,1,61,3,61,
        1265,8,61,1,61,1,61,3,61,1269,8,61,1,61,1,61,1,61,1,61,5,61,1275,
        8,61,10,61,12,61,1278,9,61,1,61,1,61,1,62,1,62,5,62,1284,8,62,10,
        62,12,62,1287,9,62,1,63,1,63,3,63,1291,8,63,1,63,1,63,3,63,1295,
        8,63,1,63,1,63,3,63,1299,8,63,1,63,3,63,1302,8,63,1,64,1,64,1,65,
        1,65,1,65,3,65,1309,8,65,1,65,3,65,1312,8,65,1,65,1,65,5,65,1316,
        8,65,10,65,12,65,1319,9,65,1,65,5,65,1322,8,65,10,65,12,65,1325,
        9,65,1,66,1,66,1,66,3,66,1330,8,66,1,66,3,66,1333,8,66,1,66,1,66,
        3,66,1337,8,66,1,66,3,66,1340,8,66,1,66,5,66,1343,8,66,10,66,12,
        66,1346,9,66,1,66,5,66,1349,8,66,10,66,12,66,1352,9,66,1,66,3,66,
        1355,8,66,1,66,1,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,5,67,1366,
        8,67,10,67,12,67,1369,9,67,1,67,1,67,1,68,1,68,3,68,1375,8,68,1,
        68,1,68,1,69,1,69,3,69,1381,8,69,1,69,1,69,1,69,3,69,1386,8,69,1,
        69,3,69,1389,8,69,1,69,3,69,1392,8,69,1,69,3,69,1395,8,69,3,69,1397,
        8,69,1,69,3,69,1400,8,69,1,69,3,69,1403,8,69,1,69,3,69,1406,8,69,
        1,69,1,69,1,69,5,69,1411,8,69,10,69,12,69,1414,9,69,1,69,1,69,1,
        70,1,70,1,70,1,70,1,70,3,70,1423,8,70,1,71,1,71,1,71,1,71,5,71,1429,
        8,71,10,71,12,71,1432,9,71,1,71,3,71,1435,8,71,1,71,4,71,1438,8,
        71,11,71,12,71,1439,1,71,1,71,3,71,1444,8,71,1,72,1,72,5,72,1448,
        8,72,10,72,12,72,1451,9,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,
        73,3,73,1461,8,73,1,73,3,73,1464,8,73,1,73,3,73,1467,8,73,1,73,1,
        73,1,73,3,73,1472,8,73,1,73,3,73,1475,8,73,1,73,1,73,1,73,1,73,3,
        73,1481,8,73,1,73,3,73,1484,8,73,1,73,1,73,3,73,1488,8,73,1,74,1,
        74,1,74,1,74,5,74,1494,8,74,10,74,12,74,1497,9,74,1,74,1,74,5,74,
        1501,8,74,10,74,12,74,1504,9,74,1,74,1,74,1,74,3,74,1509,8,74,1,
        74,3,74,1512,8,74,1,74,1,74,3,74,1516,8,74,3,74,1518,8,74,1,75,1,
        75,1,75,1,75,5,75,1524,8,75,10,75,12,75,1527,9,75,1,75,3,75,1530,
        8,75,1,75,5,75,1533,8,75,10,75,12,75,1536,9,75,1,75,1,75,5,75,1540,
        8,75,10,75,12,75,1543,9,75,1,75,1,75,3,75,1547,8,75,3,75,1549,8,
        75,1,76,1,76,1,76,1,76,3,76,1555,8,76,1,76,3,76,1558,8,76,1,76,1,
        76,1,77,1,77,1,77,1,77,3,77,1566,8,77,1,77,3,77,1569,8,77,1,77,1,
        77,1,78,3,78,1574,8,78,1,78,3,78,1577,8,78,1,78,1,78,1,78,1,78,3,
        78,1583,8,78,1,78,3,78,1586,8,78,1,78,3,78,1589,8,78,1,79,1,79,1,
        79,1,79,3,79,1595,8,79,1,79,3,79,1598,8,79,1,79,1,79,1,79,3,79,1603,
        8,79,1,79,1,79,1,79,3,79,1608,8,79,1,79,3,79,1611,8,79,1,79,1,79,
        1,79,1,79,3,79,1617,8,79,1,79,3,79,1620,8,79,1,79,3,79,1623,8,79,
        1,79,1,79,1,79,1,79,3,79,1629,8,79,1,79,3,79,1632,8,79,1,79,3,79,
        1635,8,79,1,79,1,79,1,79,1,79,1,79,1,79,3,79,1643,8,79,1,79,3,79,
        1646,8,79,1,79,3,79,1649,8,79,3,79,1651,8,79,1,80,1,80,1,80,3,80,
        1656,8,80,1,80,1,80,1,80,3,80,1661,8,80,1,80,3,80,1664,8,80,1,80,
        1,80,1,80,1,80,3,80,1670,8,80,1,80,3,80,1673,8,80,1,80,3,80,1676,
        8,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,
        3,81,1690,8,81,1,82,1,82,1,82,3,82,1695,8,82,1,83,1,83,1,84,1,84,
        3,84,1701,8,84,1,84,1,84,3,84,1705,8,84,1,84,1,84,1,84,1,85,1,85,
        1,85,5,85,1713,8,85,10,85,12,85,1716,9,85,1,85,3,85,1719,8,85,1,
        86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,
        86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,
        86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,1,86,3,
        86,1760,8,86,1,87,1,87,3,87,1764,8,87,1,87,1,87,3,87,1768,8,87,1,
        87,1,87,3,87,1772,8,87,1,87,1,87,3,87,1776,8,87,1,87,1,87,3,87,1780,
        8,87,1,87,1,87,1,88,1,88,1,88,5,88,1787,8,88,10,88,12,88,1790,9,
        88,1,88,3,88,1793,8,88,1,89,1,89,3,89,1797,8,89,1,89,3,89,1800,8,
        89,1,89,3,89,1803,8,89,1,89,3,89,1806,8,89,1,89,1,89,3,89,1810,8,
        89,1,89,5,89,1813,8,89,10,89,12,89,1816,9,89,1,89,3,89,1819,8,89,
        1,89,3,89,1822,8,89,1,89,3,89,1825,8,89,1,89,3,89,1828,8,89,1,89,
        3,89,1831,8,89,1,89,3,89,1834,8,89,1,89,3,89,1837,8,89,1,89,3,89,
        1840,8,89,1,89,3,89,1843,8,89,1,89,3,89,1846,8,89,1,89,3,89,1849,
        8,89,1,89,3,89,1852,8,89,1,89,3,89,1855,8,89,1,89,3,89,1858,8,89,
        1,89,3,89,1861,8,89,1,90,1,90,3,90,1865,8,90,1,90,3,90,1868,8,90,
        1,90,3,90,1871,8,90,1,90,1,90,3,90,1875,8,90,1,90,3,90,1878,8,90,
        1,90,1,90,1,90,4,90,1883,8,90,11,90,12,90,1884,1,91,1,91,5,91,1889,
        8,91,10,91,12,91,1892,9,91,1,91,3,91,1895,8,91,1,92,1,92,5,92,1899,
        8,92,10,92,12,92,1902,9,92,1,92,3,92,1905,8,92,1,93,1,93,5,93,1909,
        8,93,10,93,12,93,1912,9,93,1,93,3,93,1915,8,93,1,94,1,94,5,94,1919,
        8,94,10,94,12,94,1922,9,94,1,94,3,94,1925,8,94,1,95,1,95,3,95,1929,
        8,95,1,95,3,95,1932,8,95,1,95,3,95,1935,8,95,1,95,1,95,3,95,1939,
        8,95,1,95,3,95,1942,8,95,1,95,1,95,3,95,1946,8,95,1,95,1,95,3,95,
        1950,8,95,1,95,1,95,3,95,1954,8,95,1,95,1,95,3,95,1958,8,95,1,95,
        3,95,1961,8,95,1,95,1,95,3,95,1965,8,95,1,95,3,95,1968,8,95,1,95,
        3,95,1971,8,95,1,95,1,95,3,95,1975,8,95,1,95,3,95,1978,8,95,1,95,
        1,95,3,95,1982,8,95,1,95,1,95,3,95,1986,8,95,1,96,1,96,3,96,1990,
        8,96,1,96,3,96,1993,8,96,1,96,1,96,3,96,1997,8,96,1,96,1,96,3,96,
        2001,8,96,1,96,1,96,3,96,2005,8,96,1,96,1,96,3,96,2009,8,96,1,96,
        3,96,2012,8,96,1,97,1,97,3,97,2016,8,97,1,97,1,97,3,97,2020,8,97,
        1,97,3,97,2023,8,97,1,98,1,98,1,98,1,98,1,98,1,98,3,98,2031,8,98,
        1,99,1,99,1,100,1,100,1,101,1,101,1,102,1,102,1,103,4,103,2042,8,
        103,11,103,12,103,2043,1,103,5,597,635,1193,1227,2043,0,104,0,2,
        4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
        50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,
        94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,
        128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,
        160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,
        192,194,196,198,200,202,204,206,0,43,3,0,79,79,214,214,295,295,2,
        0,274,274,295,296,3,0,77,77,80,81,115,115,2,0,277,277,293,293,9,
        0,22,22,40,40,48,48,66,66,79,81,90,90,94,108,110,110,259,259,2,0,
        66,66,96,96,1,0,281,282,2,0,32,32,58,58,2,0,218,219,231,231,3,0,
        81,81,83,84,246,246,2,0,32,32,57,57,1,0,295,296,2,0,86,86,90,90,
        1,0,83,84,3,0,274,274,293,293,295,296,2,0,293,293,295,295,2,0,32,
        32,207,207,3,0,25,25,29,30,277,277,2,0,81,81,246,246,1,0,157,158,
        2,0,32,32,238,238,1,0,154,155,1,0,160,161,1,0,73,74,2,0,64,64,217,
        217,3,0,218,219,274,274,293,293,2,0,274,274,293,293,2,0,102,102,
        293,293,2,0,13,13,31,31,2,0,272,272,293,293,1,0,32,33,1,0,91,92,
        1,0,142,143,1,0,24,25,2,0,48,48,63,63,1,1,296,296,2,0,259,271,301,
        302,2,0,13,13,52,52,7,0,49,49,96,96,124,124,272,272,274,276,293,
        293,295,295,2,0,253,258,285,290,1,0,281,284,25,0,8,11,14,14,22,22,
        31,32,34,47,50,51,55,55,60,61,64,64,67,68,70,72,76,76,88,89,93,93,
        111,114,125,126,128,128,130,154,156,157,159,160,162,188,190,192,
        194,200,203,206,217,217,19,0,8,10,13,16,18,18,32,33,35,36,38,39,
        41,41,47,47,50,51,55,55,63,64,68,68,70,70,76,76,128,128,142,143,
        179,179,194,194,206,207,2550,0,212,1,0,0,0,2,216,1,0,0,0,4,223,1,
        0,0,0,6,269,1,0,0,0,8,271,1,0,0,0,10,279,1,0,0,0,12,324,1,0,0,0,
        14,342,1,0,0,0,16,344,1,0,0,0,18,349,1,0,0,0,20,374,1,0,0,0,22,376,
        1,0,0,0,24,411,1,0,0,0,26,413,1,0,0,0,28,422,1,0,0,0,30,436,1,0,
        0,0,32,438,1,0,0,0,34,476,1,0,0,0,36,478,1,0,0,0,38,487,1,0,0,0,
        40,496,1,0,0,0,42,589,1,0,0,0,44,592,1,0,0,0,46,666,1,0,0,0,48,668,
        1,0,0,0,50,685,1,0,0,0,52,724,1,0,0,0,54,753,1,0,0,0,56,756,1,0,
        0,0,58,760,1,0,0,0,60,795,1,0,0,0,62,831,1,0,0,0,64,887,1,0,0,0,
        66,889,1,0,0,0,68,914,1,0,0,0,70,924,1,0,0,0,72,926,1,0,0,0,74,942,
        1,0,0,0,76,944,1,0,0,0,78,952,1,0,0,0,80,967,1,0,0,0,82,976,1,0,
        0,0,84,1014,1,0,0,0,86,1047,1,0,0,0,88,1052,1,0,0,0,90,1054,1,0,
        0,0,92,1102,1,0,0,0,94,1104,1,0,0,0,96,1120,1,0,0,0,98,1123,1,0,
        0,0,100,1132,1,0,0,0,102,1152,1,0,0,0,104,1156,1,0,0,0,106,1167,
        1,0,0,0,108,1189,1,0,0,0,110,1217,1,0,0,0,112,1219,1,0,0,0,114,1223,
        1,0,0,0,116,1240,1,0,0,0,118,1251,1,0,0,0,120,1256,1,0,0,0,122,1262,
        1,0,0,0,124,1281,1,0,0,0,126,1288,1,0,0,0,128,1303,1,0,0,0,130,1305,
        1,0,0,0,132,1326,1,0,0,0,134,1358,1,0,0,0,136,1372,1,0,0,0,138,1378,
        1,0,0,0,140,1422,1,0,0,0,142,1424,1,0,0,0,144,1445,1,0,0,0,146,1454,
        1,0,0,0,148,1489,1,0,0,0,150,1519,1,0,0,0,152,1550,1,0,0,0,154,1561,
        1,0,0,0,156,1588,1,0,0,0,158,1650,1,0,0,0,160,1655,1,0,0,0,162,1689,
        1,0,0,0,164,1691,1,0,0,0,166,1696,1,0,0,0,168,1698,1,0,0,0,170,1714,
        1,0,0,0,172,1759,1,0,0,0,174,1761,1,0,0,0,176,1788,1,0,0,0,178,1794,
        1,0,0,0,180,1862,1,0,0,0,182,1886,1,0,0,0,184,1896,1,0,0,0,186,1906,
        1,0,0,0,188,1916,1,0,0,0,190,1985,1,0,0,0,192,1987,1,0,0,0,194,2013,
        1,0,0,0,196,2030,1,0,0,0,198,2032,1,0,0,0,200,2034,1,0,0,0,202,2036,
        1,0,0,0,204,2038,1,0,0,0,206,2041,1,0,0,0,208,213,3,2,1,0,209,213,
        3,4,2,0,210,213,5,295,0,0,211,213,5,296,0,0,212,208,1,0,0,0,212,
        209,1,0,0,0,212,210,1,0,0,0,212,211,1,0,0,0,213,214,1,0,0,0,214,
        212,1,0,0,0,214,215,1,0,0,0,215,1,1,0,0,0,216,218,5,274,0,0,217,
        219,5,295,0,0,218,217,1,0,0,0,218,219,1,0,0,0,219,220,1,0,0,0,220,
        221,3,4,2,0,221,3,1,0,0,0,222,224,3,6,3,0,223,222,1,0,0,0,223,224,
        1,0,0,0,224,267,1,0,0,0,225,268,3,8,4,0,226,268,3,168,84,0,227,268,
        3,174,87,0,228,268,3,104,52,0,229,268,3,138,69,0,230,268,3,178,89,
        0,231,268,3,134,67,0,232,268,3,140,70,0,233,268,3,126,63,0,234,268,
        3,122,61,0,235,268,3,28,14,0,236,268,3,32,16,0,237,268,3,46,23,0,
        238,268,3,56,28,0,239,268,3,40,20,0,240,268,3,64,32,0,241,268,3,
        68,34,0,242,268,3,70,35,0,243,268,3,80,40,0,244,268,3,88,44,0,245,
        268,3,90,45,0,246,268,3,92,46,0,247,268,3,100,50,0,248,268,3,102,
        51,0,249,268,3,14,7,0,250,268,3,22,11,0,251,268,3,196,98,0,252,268,
        3,180,90,0,253,268,3,124,62,0,254,268,3,116,58,0,255,268,3,120,60,
        0,256,268,3,26,13,0,257,268,3,10,5,0,258,268,3,38,19,0,259,268,3,
        36,18,0,260,268,3,106,53,0,261,268,3,108,54,0,262,268,3,112,56,0,
        263,268,3,114,57,0,264,268,3,130,65,0,265,268,3,132,66,0,266,268,
        3,206,103,0,267,225,1,0,0,0,267,226,1,0,0,0,267,227,1,0,0,0,267,
        228,1,0,0,0,267,229,1,0,0,0,267,230,1,0,0,0,267,231,1,0,0,0,267,
        232,1,0,0,0,267,233,1,0,0,0,267,234,1,0,0,0,267,235,1,0,0,0,267,
        236,1,0,0,0,267,237,1,0,0,0,267,238,1,0,0,0,267,239,1,0,0,0,267,
        240,1,0,0,0,267,241,1,0,0,0,267,242,1,0,0,0,267,243,1,0,0,0,267,
        244,1,0,0,0,267,245,1,0,0,0,267,246,1,0,0,0,267,247,1,0,0,0,267,
        248,1,0,0,0,267,249,1,0,0,0,267,250,1,0,0,0,267,251,1,0,0,0,267,
        252,1,0,0,0,267,253,1,0,0,0,267,254,1,0,0,0,267,255,1,0,0,0,267,
        256,1,0,0,0,267,257,1,0,0,0,267,258,1,0,0,0,267,259,1,0,0,0,267,
        260,1,0,0,0,267,261,1,0,0,0,267,262,1,0,0,0,267,263,1,0,0,0,267,
        264,1,0,0,0,267,265,1,0,0,0,267,266,1,0,0,0,268,5,1,0,0,0,269,270,
        5,312,0,0,270,7,1,0,0,0,271,273,5,192,0,0,272,274,3,4,2,0,273,272,
        1,0,0,0,274,275,1,0,0,0,275,273,1,0,0,0,275,276,1,0,0,0,276,277,
        1,0,0,0,277,278,5,193,0,0,278,9,1,0,0,0,279,283,5,72,0,0,280,282,
        7,0,0,0,281,280,1,0,0,0,282,285,1,0,0,0,283,281,1,0,0,0,283,284,
        1,0,0,0,284,289,1,0,0,0,285,283,1,0,0,0,286,290,3,162,81,0,287,290,
        5,295,0,0,288,290,5,296,0,0,289,286,1,0,0,0,289,287,1,0,0,0,289,
        288,1,0,0,0,290,291,1,0,0,0,291,289,1,0,0,0,291,292,1,0,0,0,292,
        293,1,0,0,0,293,297,5,106,0,0,294,296,7,1,0,0,295,294,1,0,0,0,296,
        299,1,0,0,0,297,295,1,0,0,0,297,298,1,0,0,0,298,300,1,0,0,0,299,
        297,1,0,0,0,300,308,3,162,81,0,301,303,7,1,0,0,302,301,1,0,0,0,303,
        306,1,0,0,0,304,302,1,0,0,0,304,305,1,0,0,0,305,307,1,0,0,0,306,
        304,1,0,0,0,307,309,3,12,6,0,308,304,1,0,0,0,308,309,1,0,0,0,309,
        11,1,0,0,0,310,325,5,215,0,0,311,325,5,216,0,0,312,317,5,90,0,0,
        313,315,5,295,0,0,314,313,1,0,0,0,314,315,1,0,0,0,315,316,1,0,0,
        0,316,318,5,29,0,0,317,314,1,0,0,0,317,318,1,0,0,0,318,319,1,0,0,
        0,319,321,5,103,0,0,320,322,5,295,0,0,321,320,1,0,0,0,321,322,1,
        0,0,0,322,323,1,0,0,0,323,325,5,272,0,0,324,310,1,0,0,0,324,311,
        1,0,0,0,324,312,1,0,0,0,325,13,1,0,0,0,326,327,5,68,0,0,327,328,
        5,295,0,0,328,343,3,18,9,0,329,337,5,68,0,0,330,338,5,272,0,0,331,
        338,3,20,10,0,332,338,3,16,8,0,333,338,5,284,0,0,334,338,5,295,0,
        0,335,338,5,274,0,0,336,338,5,296,0,0,337,330,1,0,0,0,337,331,1,
        0,0,0,337,332,1,0,0,0,337,333,1,0,0,0,337,334,1,0,0,0,337,335,1,
        0,0,0,337,336,1,0,0,0,338,339,1,0,0,0,339,337,1,0,0,0,339,340,1,
        0,0,0,340,341,1,0,0,0,341,343,5,296,0,0,342,326,1,0,0,0,342,329,
        1,0,0,0,343,15,1,0,0,0,344,345,7,2,0,0,345,17,1,0,0,0,346,348,3,
        4,2,0,347,346,1,0,0,0,348,351,1,0,0,0,349,347,1,0,0,0,349,350,1,
        0,0,0,350,353,1,0,0,0,351,349,1,0,0,0,352,354,5,66,0,0,353,352,1,
        0,0,0,353,354,1,0,0,0,354,356,1,0,0,0,355,357,5,295,0,0,356,355,
        1,0,0,0,356,357,1,0,0,0,357,358,1,0,0,0,358,360,5,69,0,0,359,361,
        5,295,0,0,360,359,1,0,0,0,360,361,1,0,0,0,361,362,1,0,0,0,362,363,
        5,272,0,0,363,19,1,0,0,0,364,369,5,293,0,0,365,367,5,295,0,0,366,
        365,1,0,0,0,366,367,1,0,0,0,367,368,1,0,0,0,368,370,7,3,0,0,369,
        366,1,0,0,0,369,370,1,0,0,0,370,375,1,0,0,0,371,372,5,293,0,0,372,
        373,5,307,0,0,373,375,5,293,0,0,374,364,1,0,0,0,374,371,1,0,0,0,
        375,21,1,0,0,0,376,379,5,76,0,0,377,378,5,295,0,0,378,380,5,79,0,
        0,379,377,1,0,0,0,379,380,1,0,0,0,380,390,1,0,0,0,381,382,5,274,
        0,0,382,384,5,295,0,0,383,381,1,0,0,0,383,384,1,0,0,0,384,385,1,
        0,0,0,385,389,3,24,12,0,386,389,5,295,0,0,387,389,5,296,0,0,388,
        383,1,0,0,0,388,386,1,0,0,0,388,387,1,0,0,0,389,392,1,0,0,0,390,
        388,1,0,0,0,390,391,1,0,0,0,391,395,1,0,0,0,392,390,1,0,0,0,393,
        394,5,295,0,0,394,396,5,82,0,0,395,393,1,0,0,0,395,396,1,0,0,0,396,
        23,1,0,0,0,397,412,5,77,0,0,398,412,5,293,0,0,399,412,5,78,0,0,400,
        401,5,77,0,0,401,402,5,295,0,0,402,403,5,80,0,0,403,404,5,295,0,
        0,404,405,5,274,0,0,405,406,5,295,0,0,406,407,5,81,0,0,407,408,5,
        295,0,0,408,412,5,293,0,0,409,412,5,65,0,0,410,412,5,272,0,0,411,
        397,1,0,0,0,411,398,1,0,0,0,411,399,1,0,0,0,411,400,1,0,0,0,411,
        409,1,0,0,0,411,410,1,0,0,0,412,25,1,0,0,0,413,417,5,126,0,0,414,
        416,3,4,2,0,415,414,1,0,0,0,416,419,1,0,0,0,417,415,1,0,0,0,417,
        418,1,0,0,0,418,420,1,0,0,0,419,417,1,0,0,0,420,421,5,127,0,0,421,
        27,1,0,0,0,422,423,5,93,0,0,423,430,5,295,0,0,424,431,3,20,10,0,
        425,431,5,272,0,0,426,431,3,30,15,0,427,431,5,274,0,0,428,431,5,
        295,0,0,429,431,5,296,0,0,430,424,1,0,0,0,430,425,1,0,0,0,430,426,
        1,0,0,0,430,427,1,0,0,0,430,428,1,0,0,0,430,429,1,0,0,0,431,432,
        1,0,0,0,432,430,1,0,0,0,432,433,1,0,0,0,433,434,1,0,0,0,434,435,
        5,296,0,0,435,29,1,0,0,0,436,437,7,4,0,0,437,31,1,0,0,0,438,440,
        5,47,0,0,439,441,5,295,0,0,440,439,1,0,0,0,440,441,1,0,0,0,441,445,
        1,0,0,0,442,446,3,34,17,0,443,446,5,295,0,0,444,446,5,296,0,0,445,
        442,1,0,0,0,445,443,1,0,0,0,445,444,1,0,0,0,446,447,1,0,0,0,447,
        445,1,0,0,0,447,448,1,0,0,0,448,450,1,0,0,0,449,451,5,49,0,0,450,
        449,1,0,0,0,450,451,1,0,0,0,451,455,1,0,0,0,452,456,3,34,17,0,453,
        456,5,295,0,0,454,456,5,296,0,0,455,452,1,0,0,0,455,453,1,0,0,0,
        455,454,1,0,0,0,456,457,1,0,0,0,457,455,1,0,0,0,457,458,1,0,0,0,
        458,33,1,0,0,0,459,477,3,162,81,0,460,461,5,287,0,0,461,462,3,162,
        81,0,462,463,5,286,0,0,463,477,1,0,0,0,464,477,5,124,0,0,465,477,
        5,94,0,0,466,477,5,116,0,0,467,477,5,117,0,0,468,477,5,118,0,0,469,
        477,5,119,0,0,470,477,5,120,0,0,471,477,5,121,0,0,472,477,5,122,
        0,0,473,477,5,123,0,0,474,477,5,29,0,0,475,477,5,109,0,0,476,459,
        1,0,0,0,476,460,1,0,0,0,476,464,1,0,0,0,476,465,1,0,0,0,476,466,
        1,0,0,0,476,467,1,0,0,0,476,468,1,0,0,0,476,469,1,0,0,0,476,470,
        1,0,0,0,476,471,1,0,0,0,476,472,1,0,0,0,476,473,1,0,0,0,476,474,
        1,0,0,0,476,475,1,0,0,0,477,35,1,0,0,0,478,482,5,31,0,0,479,481,
        3,4,2,0,480,479,1,0,0,0,481,484,1,0,0,0,482,480,1,0,0,0,482,483,
        1,0,0,0,483,485,1,0,0,0,484,482,1,0,0,0,485,486,5,32,0,0,486,37,
        1,0,0,0,487,491,5,50,0,0,488,490,3,4,2,0,489,488,1,0,0,0,490,493,
        1,0,0,0,491,489,1,0,0,0,491,492,1,0,0,0,492,494,1,0,0,0,493,491,
        1,0,0,0,494,495,5,64,0,0,495,39,1,0,0,0,496,498,5,39,0,0,497,499,
        5,295,0,0,498,497,1,0,0,0,498,499,1,0,0,0,499,501,1,0,0,0,500,502,
        5,83,0,0,501,500,1,0,0,0,501,502,1,0,0,0,502,504,1,0,0,0,503,505,
        5,295,0,0,504,503,1,0,0,0,504,505,1,0,0,0,505,507,1,0,0,0,506,508,
        5,81,0,0,507,506,1,0,0,0,507,508,1,0,0,0,508,510,1,0,0,0,509,511,
        5,295,0,0,510,509,1,0,0,0,510,511,1,0,0,0,511,513,1,0,0,0,512,514,
        5,246,0,0,513,512,1,0,0,0,513,514,1,0,0,0,514,516,1,0,0,0,515,517,
        5,295,0,0,516,515,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,520,
        5,293,0,0,519,521,5,295,0,0,520,519,1,0,0,0,520,521,1,0,0,0,521,
        523,1,0,0,0,522,524,5,296,0,0,523,522,1,0,0,0,523,524,1,0,0,0,524,
        526,1,0,0,0,525,527,5,90,0,0,526,525,1,0,0,0,526,527,1,0,0,0,527,
        529,1,0,0,0,528,530,5,86,0,0,529,528,1,0,0,0,529,530,1,0,0,0,530,
        532,1,0,0,0,531,533,5,295,0,0,532,531,1,0,0,0,532,533,1,0,0,0,533,
        535,1,0,0,0,534,536,5,296,0,0,535,534,1,0,0,0,535,536,1,0,0,0,536,
        540,1,0,0,0,537,539,3,42,21,0,538,537,1,0,0,0,539,542,1,0,0,0,540,
        538,1,0,0,0,540,541,1,0,0,0,541,544,1,0,0,0,542,540,1,0,0,0,543,
        545,5,295,0,0,544,543,1,0,0,0,544,545,1,0,0,0,545,547,1,0,0,0,546,
        548,5,296,0,0,547,546,1,0,0,0,547,548,1,0,0,0,548,552,1,0,0,0,549,
        551,3,44,22,0,550,549,1,0,0,0,551,554,1,0,0,0,552,550,1,0,0,0,552,
        553,1,0,0,0,553,41,1,0,0,0,554,552,1,0,0,0,555,556,5,244,0,0,556,
        558,5,295,0,0,557,559,5,273,0,0,558,557,1,0,0,0,558,559,1,0,0,0,
        559,560,1,0,0,0,560,562,5,285,0,0,561,563,5,295,0,0,562,561,1,0,
        0,0,562,563,1,0,0,0,563,565,1,0,0,0,564,566,3,162,81,0,565,564,1,
        0,0,0,565,566,1,0,0,0,566,590,1,0,0,0,567,568,5,245,0,0,568,570,
        5,295,0,0,569,571,5,273,0,0,570,569,1,0,0,0,570,571,1,0,0,0,571,
        572,1,0,0,0,572,574,5,285,0,0,573,575,5,295,0,0,574,573,1,0,0,0,
        574,575,1,0,0,0,575,577,1,0,0,0,576,578,3,162,81,0,577,576,1,0,0,
        0,577,578,1,0,0,0,578,590,1,0,0,0,579,581,7,5,0,0,580,582,5,295,
        0,0,581,580,1,0,0,0,581,582,1,0,0,0,582,584,1,0,0,0,583,585,5,101,
        0,0,584,583,1,0,0,0,584,585,1,0,0,0,585,587,1,0,0,0,586,588,3,162,
        81,0,587,586,1,0,0,0,587,588,1,0,0,0,588,590,1,0,0,0,589,555,1,0,
        0,0,589,567,1,0,0,0,589,579,1,0,0,0,590,43,1,0,0,0,591,593,5,274,
        0,0,592,591,1,0,0,0,592,593,1,0,0,0,593,597,1,0,0,0,594,596,5,295,
        0,0,595,594,1,0,0,0,596,599,1,0,0,0,597,598,1,0,0,0,597,595,1,0,
        0,0,598,650,1,0,0,0,599,597,1,0,0,0,600,602,3,162,81,0,601,603,5,
        295,0,0,602,601,1,0,0,0,602,603,1,0,0,0,603,605,1,0,0,0,604,606,
        5,296,0,0,605,604,1,0,0,0,605,606,1,0,0,0,606,608,1,0,0,0,607,609,
        5,274,0,0,608,607,1,0,0,0,608,609,1,0,0,0,609,611,1,0,0,0,610,612,
        5,273,0,0,611,610,1,0,0,0,611,612,1,0,0,0,612,614,1,0,0,0,613,615,
        5,296,0,0,614,613,1,0,0,0,614,615,1,0,0,0,615,617,1,0,0,0,616,618,
        5,274,0,0,617,616,1,0,0,0,617,618,1,0,0,0,618,620,1,0,0,0,619,621,
        5,295,0,0,620,619,1,0,0,0,620,621,1,0,0,0,621,622,1,0,0,0,622,624,
        5,285,0,0,623,625,5,295,0,0,624,623,1,0,0,0,624,625,1,0,0,0,625,
        627,1,0,0,0,626,628,5,296,0,0,627,626,1,0,0,0,627,628,1,0,0,0,628,
        630,1,0,0,0,629,631,5,274,0,0,630,629,1,0,0,0,630,631,1,0,0,0,631,
        635,1,0,0,0,632,634,5,295,0,0,633,632,1,0,0,0,634,637,1,0,0,0,635,
        636,1,0,0,0,635,633,1,0,0,0,636,639,1,0,0,0,637,635,1,0,0,0,638,
        640,7,6,0,0,639,638,1,0,0,0,639,640,1,0,0,0,640,641,1,0,0,0,641,
        643,3,162,81,0,642,644,5,295,0,0,643,642,1,0,0,0,643,644,1,0,0,0,
        644,646,1,0,0,0,645,647,5,296,0,0,646,645,1,0,0,0,646,647,1,0,0,
        0,647,649,1,0,0,0,648,600,1,0,0,0,649,652,1,0,0,0,650,648,1,0,0,
        0,650,651,1,0,0,0,651,656,1,0,0,0,652,650,1,0,0,0,653,655,5,295,
        0,0,654,653,1,0,0,0,655,658,1,0,0,0,656,654,1,0,0,0,656,657,1,0,
        0,0,657,659,1,0,0,0,658,656,1,0,0,0,659,660,5,296,0,0,660,45,1,0,
        0,0,661,662,3,48,24,0,662,663,3,176,88,0,663,664,7,7,0,0,664,667,
        1,0,0,0,665,667,3,50,25,0,666,661,1,0,0,0,666,665,1,0,0,0,667,47,
        1,0,0,0,668,675,5,36,0,0,669,674,3,52,26,0,670,674,5,295,0,0,671,
        674,5,296,0,0,672,674,5,274,0,0,673,669,1,0,0,0,673,670,1,0,0,0,
        673,671,1,0,0,0,673,672,1,0,0,0,674,677,1,0,0,0,675,673,1,0,0,0,
        675,676,1,0,0,0,676,678,1,0,0,0,677,675,1,0,0,0,678,680,5,293,0,
        0,679,681,5,295,0,0,680,679,1,0,0,0,680,681,1,0,0,0,681,682,1,0,
        0,0,682,683,3,54,27,0,683,684,5,296,0,0,684,49,1,0,0,0,685,686,5,
        36,0,0,686,687,5,295,0,0,687,694,5,101,0,0,688,693,3,52,26,0,689,
        693,5,295,0,0,690,693,5,296,0,0,691,693,5,274,0,0,692,688,1,0,0,
        0,692,689,1,0,0,0,692,690,1,0,0,0,692,691,1,0,0,0,693,696,1,0,0,
        0,694,692,1,0,0,0,694,695,1,0,0,0,695,697,1,0,0,0,696,694,1,0,0,
        0,697,699,5,293,0,0,698,700,5,295,0,0,699,698,1,0,0,0,699,700,1,
        0,0,0,700,701,1,0,0,0,701,702,3,54,27,0,702,703,5,296,0,0,703,51,
        1,0,0,0,704,711,5,25,0,0,705,711,5,30,0,0,706,711,5,29,0,0,707,711,
        5,293,0,0,708,711,5,277,0,0,709,711,3,20,10,0,710,704,1,0,0,0,710,
        705,1,0,0,0,710,706,1,0,0,0,710,707,1,0,0,0,710,708,1,0,0,0,710,
        709,1,0,0,0,711,725,1,0,0,0,712,715,5,232,0,0,713,714,5,295,0,0,
        714,716,7,8,0,0,715,713,1,0,0,0,715,716,1,0,0,0,716,717,1,0,0,0,
        717,718,5,295,0,0,718,725,5,274,0,0,719,721,7,9,0,0,720,719,1,0,
        0,0,721,722,1,0,0,0,722,720,1,0,0,0,722,723,1,0,0,0,723,725,1,0,
        0,0,724,710,1,0,0,0,724,712,1,0,0,0,724,720,1,0,0,0,725,53,1,0,0,
        0,726,752,3,162,81,0,727,752,5,295,0,0,728,752,5,274,0,0,729,752,
        5,296,0,0,730,752,5,244,0,0,731,752,5,245,0,0,732,752,5,90,0,0,733,
        752,5,204,0,0,734,752,5,225,0,0,735,752,5,224,0,0,736,752,5,228,
        0,0,737,752,5,220,0,0,738,752,5,222,0,0,739,752,5,223,0,0,740,752,
        5,226,0,0,741,752,5,23,0,0,742,752,5,230,0,0,743,752,5,301,0,0,744,
        752,5,49,0,0,745,752,5,211,0,0,746,752,5,116,0,0,747,752,5,117,0,
        0,748,752,5,227,0,0,749,752,3,200,100,0,750,752,3,166,83,0,751,726,
        1,0,0,0,751,727,1,0,0,0,751,728,1,0,0,0,751,729,1,0,0,0,751,730,
        1,0,0,0,751,731,1,0,0,0,751,732,1,0,0,0,751,733,1,0,0,0,751,734,
        1,0,0,0,751,735,1,0,0,0,751,736,1,0,0,0,751,737,1,0,0,0,751,738,
        1,0,0,0,751,739,1,0,0,0,751,740,1,0,0,0,751,741,1,0,0,0,751,742,
        1,0,0,0,751,743,1,0,0,0,751,744,1,0,0,0,751,745,1,0,0,0,751,746,
        1,0,0,0,751,747,1,0,0,0,751,748,1,0,0,0,751,749,1,0,0,0,751,750,
        1,0,0,0,752,755,1,0,0,0,753,751,1,0,0,0,753,754,1,0,0,0,754,55,1,
        0,0,0,755,753,1,0,0,0,756,757,3,58,29,0,757,758,3,176,88,0,758,759,
        7,10,0,0,759,57,1,0,0,0,760,767,5,35,0,0,761,766,3,60,30,0,762,766,
        5,295,0,0,763,766,5,296,0,0,764,766,5,274,0,0,765,761,1,0,0,0,765,
        762,1,0,0,0,765,763,1,0,0,0,765,764,1,0,0,0,766,769,1,0,0,0,767,
        765,1,0,0,0,767,768,1,0,0,0,768,770,1,0,0,0,769,767,1,0,0,0,770,
        772,5,293,0,0,771,773,5,295,0,0,772,771,1,0,0,0,772,773,1,0,0,0,
        773,774,1,0,0,0,774,775,3,62,31,0,775,776,5,296,0,0,776,59,1,0,0,
        0,777,782,5,29,0,0,778,782,5,293,0,0,779,782,5,277,0,0,780,782,3,
        20,10,0,781,777,1,0,0,0,781,778,1,0,0,0,781,779,1,0,0,0,781,780,
        1,0,0,0,782,796,1,0,0,0,783,786,5,232,0,0,784,785,5,295,0,0,785,
        787,7,8,0,0,786,784,1,0,0,0,786,787,1,0,0,0,787,788,1,0,0,0,788,
        789,5,295,0,0,789,796,5,274,0,0,790,792,7,9,0,0,791,790,1,0,0,0,
        792,793,1,0,0,0,793,791,1,0,0,0,793,794,1,0,0,0,794,796,1,0,0,0,
        795,781,1,0,0,0,795,783,1,0,0,0,795,791,1,0,0,0,796,61,1,0,0,0,797,
        830,3,162,81,0,798,830,5,295,0,0,799,830,5,274,0,0,800,830,5,296,
        0,0,801,830,5,244,0,0,802,830,5,245,0,0,803,830,5,90,0,0,804,830,
        5,247,0,0,805,830,5,224,0,0,806,830,5,223,0,0,807,830,5,220,0,0,
        808,830,5,249,0,0,809,830,5,250,0,0,810,830,5,251,0,0,811,830,5,
        23,0,0,812,830,5,230,0,0,813,830,5,301,0,0,814,830,5,49,0,0,815,
        830,5,211,0,0,816,830,5,116,0,0,817,830,5,117,0,0,818,830,5,81,0,
        0,819,830,5,248,0,0,820,830,5,229,0,0,821,830,5,235,0,0,822,830,
        5,236,0,0,823,830,5,237,0,0,824,830,5,233,0,0,825,830,5,234,0,0,
        826,830,5,227,0,0,827,830,3,200,100,0,828,830,3,166,83,0,829,797,
        1,0,0,0,829,798,1,0,0,0,829,799,1,0,0,0,829,800,1,0,0,0,829,801,
        1,0,0,0,829,802,1,0,0,0,829,803,1,0,0,0,829,804,1,0,0,0,829,805,
        1,0,0,0,829,806,1,0,0,0,829,807,1,0,0,0,829,808,1,0,0,0,829,809,
        1,0,0,0,829,810,1,0,0,0,829,811,1,0,0,0,829,812,1,0,0,0,829,813,
        1,0,0,0,829,814,1,0,0,0,829,815,1,0,0,0,829,816,1,0,0,0,829,817,
        1,0,0,0,829,818,1,0,0,0,829,819,1,0,0,0,829,820,1,0,0,0,829,821,
        1,0,0,0,829,822,1,0,0,0,829,823,1,0,0,0,829,824,1,0,0,0,829,825,
        1,0,0,0,829,826,1,0,0,0,829,827,1,0,0,0,829,828,1,0,0,0,830,833,
        1,0,0,0,831,829,1,0,0,0,831,832,1,0,0,0,832,63,1,0,0,0,833,831,1,
        0,0,0,834,836,3,66,33,0,835,837,7,11,0,0,836,835,1,0,0,0,837,838,
        1,0,0,0,838,836,1,0,0,0,838,839,1,0,0,0,839,841,1,0,0,0,840,842,
        7,12,0,0,841,840,1,0,0,0,841,842,1,0,0,0,842,860,1,0,0,0,843,861,
        5,295,0,0,844,861,5,296,0,0,845,861,5,274,0,0,846,848,3,162,81,0,
        847,849,5,295,0,0,848,847,1,0,0,0,848,849,1,0,0,0,849,851,1,0,0,
        0,850,852,5,273,0,0,851,850,1,0,0,0,851,852,1,0,0,0,852,853,1,0,
        0,0,853,855,5,285,0,0,854,856,5,295,0,0,855,854,1,0,0,0,855,856,
        1,0,0,0,856,857,1,0,0,0,857,858,3,162,81,0,858,861,1,0,0,0,859,861,
        3,196,98,0,860,843,1,0,0,0,860,844,1,0,0,0,860,845,1,0,0,0,860,846,
        1,0,0,0,860,859,1,0,0,0,861,862,1,0,0,0,862,860,1,0,0,0,862,863,
        1,0,0,0,863,865,1,0,0,0,864,866,5,295,0,0,865,864,1,0,0,0,865,866,
        1,0,0,0,866,867,1,0,0,0,867,868,5,296,0,0,868,888,1,0,0,0,869,870,
        3,66,33,0,870,871,5,295,0,0,871,872,5,66,0,0,872,873,5,295,0,0,873,
        874,5,87,0,0,874,875,5,295,0,0,875,877,5,83,0,0,876,878,5,295,0,
        0,877,876,1,0,0,0,877,878,1,0,0,0,878,879,1,0,0,0,879,880,5,296,
        0,0,880,888,1,0,0,0,881,883,3,66,33,0,882,884,5,295,0,0,883,882,
        1,0,0,0,883,884,1,0,0,0,884,885,1,0,0,0,885,886,5,296,0,0,886,888,
        1,0,0,0,887,834,1,0,0,0,887,869,1,0,0,0,887,881,1,0,0,0,888,65,1,
        0,0,0,889,891,5,38,0,0,890,892,5,295,0,0,891,890,1,0,0,0,891,892,
        1,0,0,0,892,894,1,0,0,0,893,895,5,83,0,0,894,893,1,0,0,0,894,895,
        1,0,0,0,895,897,1,0,0,0,896,898,5,295,0,0,897,896,1,0,0,0,897,898,
        1,0,0,0,898,900,1,0,0,0,899,901,5,81,0,0,900,899,1,0,0,0,900,901,
        1,0,0,0,901,903,1,0,0,0,902,904,5,295,0,0,903,902,1,0,0,0,903,904,
        1,0,0,0,904,906,1,0,0,0,905,907,5,85,0,0,906,905,1,0,0,0,906,907,
        1,0,0,0,907,909,1,0,0,0,908,910,5,295,0,0,909,908,1,0,0,0,909,910,
        1,0,0,0,910,912,1,0,0,0,911,913,7,3,0,0,912,911,1,0,0,0,912,913,
        1,0,0,0,913,67,1,0,0,0,914,916,5,40,0,0,915,917,5,295,0,0,916,915,
        1,0,0,0,916,917,1,0,0,0,917,919,1,0,0,0,918,920,5,277,0,0,919,918,
        1,0,0,0,919,920,1,0,0,0,920,69,1,0,0,0,921,925,3,72,36,0,922,925,
        3,76,38,0,923,925,3,78,39,0,924,921,1,0,0,0,924,922,1,0,0,0,924,
        923,1,0,0,0,925,71,1,0,0,0,926,927,5,41,0,0,927,928,5,295,0,0,928,
        933,5,293,0,0,929,932,3,74,37,0,930,932,5,295,0,0,931,929,1,0,0,
        0,931,930,1,0,0,0,932,935,1,0,0,0,933,931,1,0,0,0,933,934,1,0,0,
        0,934,936,1,0,0,0,935,933,1,0,0,0,936,938,3,20,10,0,937,939,5,295,
        0,0,938,937,1,0,0,0,938,939,1,0,0,0,939,940,1,0,0,0,940,941,5,296,
        0,0,941,73,1,0,0,0,942,943,7,13,0,0,943,75,1,0,0,0,944,946,5,88,
        0,0,945,947,7,14,0,0,946,945,1,0,0,0,947,948,1,0,0,0,948,946,1,0,
        0,0,948,949,1,0,0,0,949,950,1,0,0,0,950,951,5,296,0,0,951,77,1,0,
        0,0,952,957,5,89,0,0,953,955,5,295,0,0,954,953,1,0,0,0,954,955,1,
        0,0,0,955,956,1,0,0,0,956,958,5,277,0,0,957,954,1,0,0,0,957,958,
        1,0,0,0,958,962,1,0,0,0,959,961,7,15,0,0,960,959,1,0,0,0,961,964,
        1,0,0,0,962,960,1,0,0,0,962,963,1,0,0,0,963,965,1,0,0,0,964,962,
        1,0,0,0,965,966,5,296,0,0,966,79,1,0,0,0,967,971,3,82,41,0,968,970,
        3,4,2,0,969,968,1,0,0,0,970,973,1,0,0,0,971,969,1,0,0,0,971,972,
        1,0,0,0,972,974,1,0,0,0,973,971,1,0,0,0,974,975,7,16,0,0,975,81,
        1,0,0,0,976,978,5,206,0,0,977,979,5,295,0,0,978,977,1,0,0,0,978,
        979,1,0,0,0,979,986,1,0,0,0,980,985,3,84,42,0,981,985,5,295,0,0,
        982,985,5,296,0,0,983,985,5,274,0,0,984,980,1,0,0,0,984,981,1,0,
        0,0,984,982,1,0,0,0,984,983,1,0,0,0,985,988,1,0,0,0,986,984,1,0,
        0,0,986,987,1,0,0,0,987,989,1,0,0,0,988,986,1,0,0,0,989,993,5,293,
        0,0,990,992,5,295,0,0,991,990,1,0,0,0,992,995,1,0,0,0,993,991,1,
        0,0,0,993,994,1,0,0,0,994,997,1,0,0,0,995,993,1,0,0,0,996,998,5,
        296,0,0,997,996,1,0,0,0,997,998,1,0,0,0,998,999,1,0,0,0,999,1000,
        3,86,43,0,1000,83,1,0,0,0,1001,1015,7,17,0,0,1002,1005,5,232,0,0,
        1003,1004,5,295,0,0,1004,1006,7,8,0,0,1005,1003,1,0,0,0,1005,1006,
        1,0,0,0,1006,1007,1,0,0,0,1007,1008,5,295,0,0,1008,1015,5,274,0,
        0,1009,1011,7,18,0,0,1010,1009,1,0,0,0,1011,1012,1,0,0,0,1012,1010,
        1,0,0,0,1012,1013,1,0,0,0,1013,1015,1,0,0,0,1014,1001,1,0,0,0,1014,
        1002,1,0,0,0,1014,1010,1,0,0,0,1015,85,1,0,0,0,1016,1046,3,162,81,
        0,1017,1046,5,277,0,0,1018,1046,5,295,0,0,1019,1046,5,274,0,0,1020,
        1046,5,296,0,0,1021,1046,5,244,0,0,1022,1046,5,29,0,0,1023,1046,
        5,211,0,0,1024,1046,5,90,0,0,1025,1046,5,23,0,0,1026,1046,5,81,0,
        0,1027,1046,5,63,0,0,1028,1046,5,22,0,0,1029,1046,5,115,0,0,1030,
        1046,5,218,0,0,1031,1046,5,219,0,0,1032,1046,5,231,0,0,1033,1046,
        5,229,0,0,1034,1046,5,230,0,0,1035,1046,5,235,0,0,1036,1046,5,236,
        0,0,1037,1046,5,237,0,0,1038,1046,5,249,0,0,1039,1046,5,224,0,0,
        1040,1046,5,233,0,0,1041,1046,5,234,0,0,1042,1046,5,223,0,0,1043,
        1046,3,200,100,0,1044,1046,3,166,83,0,1045,1016,1,0,0,0,1045,1017,
        1,0,0,0,1045,1018,1,0,0,0,1045,1019,1,0,0,0,1045,1020,1,0,0,0,1045,
        1021,1,0,0,0,1045,1022,1,0,0,0,1045,1023,1,0,0,0,1045,1024,1,0,0,
        0,1045,1025,1,0,0,0,1045,1026,1,0,0,0,1045,1027,1,0,0,0,1045,1028,
        1,0,0,0,1045,1029,1,0,0,0,1045,1030,1,0,0,0,1045,1031,1,0,0,0,1045,
        1032,1,0,0,0,1045,1033,1,0,0,0,1045,1034,1,0,0,0,1045,1035,1,0,0,
        0,1045,1036,1,0,0,0,1045,1037,1,0,0,0,1045,1038,1,0,0,0,1045,1039,
        1,0,0,0,1045,1040,1,0,0,0,1045,1041,1,0,0,0,1045,1042,1,0,0,0,1045,
        1043,1,0,0,0,1045,1044,1,0,0,0,1046,1049,1,0,0,0,1047,1045,1,0,0,
        0,1047,1048,1,0,0,0,1048,1050,1,0,0,0,1049,1047,1,0,0,0,1050,1051,
        3,162,81,0,1051,87,1,0,0,0,1052,1053,5,60,0,0,1053,89,1,0,0,0,1054,
        1055,5,61,0,0,1055,91,1,0,0,0,1056,1057,7,19,0,0,1057,1058,5,295,
        0,0,1058,1063,3,94,47,0,1059,1061,5,295,0,0,1060,1059,1,0,0,0,1060,
        1061,1,0,0,0,1061,1062,1,0,0,0,1062,1064,5,241,0,0,1063,1060,1,0,
        0,0,1063,1064,1,0,0,0,1064,1065,1,0,0,0,1065,1066,3,96,48,0,1066,
        1067,3,98,49,0,1067,1103,1,0,0,0,1068,1069,7,19,0,0,1069,1070,5,
        295,0,0,1070,1075,3,94,47,0,1071,1073,5,295,0,0,1072,1071,1,0,0,
        0,1072,1073,1,0,0,0,1073,1074,1,0,0,0,1074,1076,5,241,0,0,1075,1072,
        1,0,0,0,1075,1076,1,0,0,0,1076,1077,1,0,0,0,1077,1079,3,96,48,0,
        1078,1080,3,4,2,0,1079,1078,1,0,0,0,1080,1081,1,0,0,0,1081,1079,
        1,0,0,0,1081,1082,1,0,0,0,1082,1083,1,0,0,0,1083,1084,5,62,0,0,1084,
        1103,1,0,0,0,1085,1086,7,19,0,0,1086,1087,5,295,0,0,1087,1092,3,
        94,47,0,1088,1090,5,295,0,0,1089,1088,1,0,0,0,1089,1090,1,0,0,0,
        1090,1091,1,0,0,0,1091,1093,5,241,0,0,1092,1089,1,0,0,0,1092,1093,
        1,0,0,0,1093,1094,1,0,0,0,1094,1096,3,96,48,0,1095,1097,3,4,2,0,
        1096,1095,1,0,0,0,1097,1098,1,0,0,0,1098,1096,1,0,0,0,1098,1099,
        1,0,0,0,1099,1100,1,0,0,0,1100,1101,7,20,0,0,1101,1103,1,0,0,0,1102,
        1056,1,0,0,0,1102,1068,1,0,0,0,1102,1085,1,0,0,0,1103,93,1,0,0,0,
        1104,1105,5,274,0,0,1105,95,1,0,0,0,1106,1119,3,162,81,0,1107,1119,
        5,277,0,0,1108,1119,5,295,0,0,1109,1119,5,274,0,0,1110,1119,5,296,
        0,0,1111,1119,5,83,0,0,1112,1119,5,240,0,0,1113,1119,5,239,0,0,1114,
        1119,5,301,0,0,1115,1119,5,37,0,0,1116,1119,5,96,0,0,1117,1119,5,
        100,0,0,1118,1106,1,0,0,0,1118,1107,1,0,0,0,1118,1108,1,0,0,0,1118,
        1109,1,0,0,0,1118,1110,1,0,0,0,1118,1111,1,0,0,0,1118,1112,1,0,0,
        0,1118,1113,1,0,0,0,1118,1114,1,0,0,0,1118,1115,1,0,0,0,1118,1116,
        1,0,0,0,1118,1117,1,0,0,0,1119,1122,1,0,0,0,1120,1118,1,0,0,0,1120,
        1121,1,0,0,0,1121,97,1,0,0,0,1122,1120,1,0,0,0,1123,1127,5,242,0,
        0,1124,1126,3,4,2,0,1125,1124,1,0,0,0,1126,1129,1,0,0,0,1127,1125,
        1,0,0,0,1127,1128,1,0,0,0,1128,1130,1,0,0,0,1129,1127,1,0,0,0,1130,
        1131,5,243,0,0,1131,99,1,0,0,0,1132,1133,7,21,0,0,1133,1134,5,295,
        0,0,1134,1139,3,94,47,0,1135,1137,5,295,0,0,1136,1135,1,0,0,0,1136,
        1137,1,0,0,0,1137,1138,1,0,0,0,1138,1140,5,235,0,0,1139,1136,1,0,
        0,0,1139,1140,1,0,0,0,1140,1147,1,0,0,0,1141,1146,3,162,81,0,1142,
        1146,5,274,0,0,1143,1146,5,295,0,0,1144,1146,5,296,0,0,1145,1141,
        1,0,0,0,1145,1142,1,0,0,0,1145,1143,1,0,0,0,1145,1144,1,0,0,0,1146,
        1149,1,0,0,0,1147,1145,1,0,0,0,1147,1148,1,0,0,0,1148,1150,1,0,0,
        0,1149,1147,1,0,0,0,1150,1151,5,296,0,0,1151,101,1,0,0,0,1152,1153,
        7,22,0,0,1153,1154,5,295,0,0,1154,1155,3,94,47,0,1155,103,1,0,0,
        0,1156,1157,5,14,0,0,1157,1158,5,295,0,0,1158,1162,7,23,0,0,1159,
        1161,3,4,2,0,1160,1159,1,0,0,0,1161,1164,1,0,0,0,1162,1160,1,0,0,
        0,1162,1163,1,0,0,0,1163,1165,1,0,0,0,1164,1162,1,0,0,0,1165,1166,
        5,75,0,0,1166,105,1,0,0,0,1167,1169,5,179,0,0,1168,1170,5,295,0,
        0,1169,1168,1,0,0,0,1169,1170,1,0,0,0,1170,1172,1,0,0,0,1171,1173,
        5,293,0,0,1172,1171,1,0,0,0,1172,1173,1,0,0,0,1173,1175,1,0,0,0,
        1174,1176,5,296,0,0,1175,1174,1,0,0,0,1175,1176,1,0,0,0,1176,1179,
        1,0,0,0,1177,1178,5,50,0,0,1178,1180,5,295,0,0,1179,1177,1,0,0,0,
        1179,1180,1,0,0,0,1180,1184,1,0,0,0,1181,1183,3,4,2,0,1182,1181,
        1,0,0,0,1183,1186,1,0,0,0,1184,1182,1,0,0,0,1184,1185,1,0,0,0,1185,
        1187,1,0,0,0,1186,1184,1,0,0,0,1187,1188,7,24,0,0,1188,107,1,0,0,
        0,1189,1208,3,110,55,0,1190,1192,5,295,0,0,1191,1190,1,0,0,0,1192,
        1195,1,0,0,0,1193,1194,1,0,0,0,1193,1191,1,0,0,0,1194,1196,1,0,0,
        0,1195,1193,1,0,0,0,1196,1198,3,112,56,0,1197,1199,5,295,0,0,1198,
        1197,1,0,0,0,1198,1199,1,0,0,0,1199,1201,1,0,0,0,1200,1202,5,296,
        0,0,1201,1200,1,0,0,0,1201,1202,1,0,0,0,1202,1204,1,0,0,0,1203,1205,
        5,274,0,0,1204,1203,1,0,0,0,1204,1205,1,0,0,0,1205,1207,1,0,0,0,
        1206,1193,1,0,0,0,1207,1210,1,0,0,0,1208,1206,1,0,0,0,1208,1209,
        1,0,0,0,1209,109,1,0,0,0,1210,1208,1,0,0,0,1211,1213,5,128,0,0,1212,
        1214,5,295,0,0,1213,1212,1,0,0,0,1213,1214,1,0,0,0,1214,1215,1,0,
        0,0,1215,1218,5,277,0,0,1216,1218,5,128,0,0,1217,1211,1,0,0,0,1217,
        1216,1,0,0,0,1218,111,1,0,0,0,1219,1220,5,293,0,0,1220,1221,3,200,
        100,0,1221,1222,7,25,0,0,1222,113,1,0,0,0,1223,1227,5,194,0,0,1224,
        1226,5,295,0,0,1225,1224,1,0,0,0,1226,1229,1,0,0,0,1227,1228,1,0,
        0,0,1227,1225,1,0,0,0,1228,1230,1,0,0,0,1229,1227,1,0,0,0,1230,1232,
        5,293,0,0,1231,1233,5,295,0,0,1232,1231,1,0,0,0,1232,1233,1,0,0,
        0,1233,1235,1,0,0,0,1234,1236,5,296,0,0,1235,1234,1,0,0,0,1235,1236,
        1,0,0,0,1236,1238,1,0,0,0,1237,1239,5,274,0,0,1238,1237,1,0,0,0,
        1238,1239,1,0,0,0,1239,115,1,0,0,0,1240,1242,5,8,0,0,1241,1243,5,
        295,0,0,1242,1241,1,0,0,0,1242,1243,1,0,0,0,1243,1244,1,0,0,0,1244,
        1245,3,118,59,0,1245,117,1,0,0,0,1246,1250,7,26,0,0,1247,1250,5,
        295,0,0,1248,1250,5,296,0,0,1249,1246,1,0,0,0,1249,1247,1,0,0,0,
        1249,1248,1,0,0,0,1250,1253,1,0,0,0,1251,1249,1,0,0,0,1251,1252,
        1,0,0,0,1252,1254,1,0,0,0,1253,1251,1,0,0,0,1254,1255,5,296,0,0,
        1255,119,1,0,0,0,1256,1258,5,70,0,0,1257,1259,5,295,0,0,1258,1257,
        1,0,0,0,1258,1259,1,0,0,0,1259,1260,1,0,0,0,1260,1261,3,118,59,0,
        1261,121,1,0,0,0,1262,1264,5,10,0,0,1263,1265,5,295,0,0,1264,1263,
        1,0,0,0,1264,1265,1,0,0,0,1265,1266,1,0,0,0,1266,1268,5,272,0,0,
        1267,1269,5,295,0,0,1268,1267,1,0,0,0,1268,1269,1,0,0,0,1269,1276,
        1,0,0,0,1270,1275,3,20,10,0,1271,1275,5,295,0,0,1272,1275,5,296,
        0,0,1273,1275,5,274,0,0,1274,1270,1,0,0,0,1274,1271,1,0,0,0,1274,
        1272,1,0,0,0,1274,1273,1,0,0,0,1275,1278,1,0,0,0,1276,1274,1,0,0,
        0,1276,1277,1,0,0,0,1277,1279,1,0,0,0,1278,1276,1,0,0,0,1279,1280,
        5,296,0,0,1280,123,1,0,0,0,1281,1285,5,71,0,0,1282,1284,5,295,0,
        0,1283,1282,1,0,0,0,1284,1287,1,0,0,0,1285,1283,1,0,0,0,1285,1286,
        1,0,0,0,1286,125,1,0,0,0,1287,1285,1,0,0,0,1288,1290,5,9,0,0,1289,
        1291,5,295,0,0,1290,1289,1,0,0,0,1290,1291,1,0,0,0,1291,1292,1,0,
        0,0,1292,1301,3,128,64,0,1293,1295,5,295,0,0,1294,1293,1,0,0,0,1294,
        1295,1,0,0,0,1295,1296,1,0,0,0,1296,1298,5,66,0,0,1297,1299,5,295,
        0,0,1298,1297,1,0,0,0,1298,1299,1,0,0,0,1299,1300,1,0,0,0,1300,1302,
        3,20,10,0,1301,1294,1,0,0,0,1301,1302,1,0,0,0,1302,127,1,0,0,0,1303,
        1304,7,27,0,0,1304,129,1,0,0,0,1305,1308,5,147,0,0,1306,1307,5,295,
        0,0,1307,1309,7,28,0,0,1308,1306,1,0,0,0,1308,1309,1,0,0,0,1309,
        1311,1,0,0,0,1310,1312,5,295,0,0,1311,1310,1,0,0,0,1311,1312,1,0,
        0,0,1312,1313,1,0,0,0,1313,1323,5,272,0,0,1314,1316,7,1,0,0,1315,
        1314,1,0,0,0,1316,1319,1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,
        0,1318,1320,1,0,0,0,1319,1317,1,0,0,0,1320,1322,7,29,0,0,1321,1317,
        1,0,0,0,1322,1325,1,0,0,0,1323,1321,1,0,0,0,1323,1324,1,0,0,0,1324,
        131,1,0,0,0,1325,1323,1,0,0,0,1326,1329,5,144,0,0,1327,1328,5,295,
        0,0,1328,1330,5,221,0,0,1329,1327,1,0,0,0,1329,1330,1,0,0,0,1330,
        1332,1,0,0,0,1331,1333,5,295,0,0,1332,1331,1,0,0,0,1332,1333,1,0,
        0,0,1333,1334,1,0,0,0,1334,1339,5,272,0,0,1335,1337,5,295,0,0,1336,
        1335,1,0,0,0,1336,1337,1,0,0,0,1337,1338,1,0,0,0,1338,1340,5,66,
        0,0,1339,1336,1,0,0,0,1339,1340,1,0,0,0,1340,1350,1,0,0,0,1341,1343,
        7,1,0,0,1342,1341,1,0,0,0,1343,1346,1,0,0,0,1344,1342,1,0,0,0,1344,
        1345,1,0,0,0,1345,1347,1,0,0,0,1346,1344,1,0,0,0,1347,1349,7,29,
        0,0,1348,1344,1,0,0,0,1349,1352,1,0,0,0,1350,1348,1,0,0,0,1350,1351,
        1,0,0,0,1351,1354,1,0,0,0,1352,1350,1,0,0,0,1353,1355,5,295,0,0,
        1354,1353,1,0,0,0,1354,1355,1,0,0,0,1355,1356,1,0,0,0,1356,1357,
        5,296,0,0,1357,133,1,0,0,0,1358,1359,5,22,0,0,1359,1360,5,295,0,
        0,1360,1361,3,158,79,0,1361,1362,5,49,0,0,1362,1363,5,295,0,0,1363,
        1367,3,162,81,0,1364,1366,3,4,2,0,1365,1364,1,0,0,0,1366,1369,1,
        0,0,0,1367,1365,1,0,0,0,1367,1368,1,0,0,0,1368,1370,1,0,0,0,1369,
        1367,1,0,0,0,1370,1371,7,30,0,0,1371,135,1,0,0,0,1372,1374,7,31,
        0,0,1373,1375,5,295,0,0,1374,1373,1,0,0,0,1374,1375,1,0,0,0,1375,
        1376,1,0,0,0,1376,1377,3,158,79,0,1377,137,1,0,0,0,1378,1380,7,32,
        0,0,1379,1381,5,295,0,0,1380,1379,1,0,0,0,1380,1381,1,0,0,0,1381,
        1382,1,0,0,0,1382,1396,7,33,0,0,1383,1385,5,295,0,0,1384,1386,5,
        26,0,0,1385,1384,1,0,0,0,1385,1386,1,0,0,0,1386,1388,1,0,0,0,1387,
        1389,5,295,0,0,1388,1387,1,0,0,0,1388,1389,1,0,0,0,1389,1391,1,0,
        0,0,1390,1392,5,296,0,0,1391,1390,1,0,0,0,1391,1392,1,0,0,0,1392,
        1394,1,0,0,0,1393,1395,5,274,0,0,1394,1393,1,0,0,0,1394,1395,1,0,
        0,0,1395,1397,1,0,0,0,1396,1383,1,0,0,0,1396,1397,1,0,0,0,1397,1399,
        1,0,0,0,1398,1400,7,34,0,0,1399,1398,1,0,0,0,1399,1400,1,0,0,0,1400,
        1402,1,0,0,0,1401,1403,5,295,0,0,1402,1401,1,0,0,0,1402,1403,1,0,
        0,0,1403,1405,1,0,0,0,1404,1406,5,21,0,0,1405,1404,1,0,0,0,1405,
        1406,1,0,0,0,1406,1407,1,0,0,0,1407,1408,5,295,0,0,1408,1412,5,293,
        0,0,1409,1411,3,4,2,0,1410,1409,1,0,0,0,1411,1414,1,0,0,0,1412,1410,
        1,0,0,0,1412,1413,1,0,0,0,1413,1415,1,0,0,0,1414,1412,1,0,0,0,1415,
        1416,5,20,0,0,1416,139,1,0,0,0,1417,1423,3,142,71,0,1418,1423,3,
        146,73,0,1419,1423,3,148,74,0,1420,1423,3,150,75,0,1421,1423,3,136,
        68,0,1422,1417,1,0,0,0,1422,1418,1,0,0,0,1422,1419,1,0,0,0,1422,
        1420,1,0,0,0,1422,1421,1,0,0,0,1423,141,1,0,0,0,1424,1425,5,14,0,
        0,1425,1426,5,295,0,0,1426,1430,3,158,79,0,1427,1429,7,1,0,0,1428,
        1427,1,0,0,0,1429,1432,1,0,0,0,1430,1428,1,0,0,0,1430,1431,1,0,0,
        0,1431,1434,1,0,0,0,1432,1430,1,0,0,0,1433,1435,5,15,0,0,1434,1433,
        1,0,0,0,1434,1435,1,0,0,0,1435,1437,1,0,0,0,1436,1438,3,4,2,0,1437,
        1436,1,0,0,0,1438,1439,1,0,0,0,1439,1437,1,0,0,0,1439,1440,1,0,0,
        0,1440,1443,1,0,0,0,1441,1444,5,18,0,0,1442,1444,3,144,72,0,1443,
        1441,1,0,0,0,1443,1442,1,0,0,0,1444,143,1,0,0,0,1445,1449,5,16,0,
        0,1446,1448,3,4,2,0,1447,1446,1,0,0,0,1448,1451,1,0,0,0,1449,1447,
        1,0,0,0,1449,1450,1,0,0,0,1450,1452,1,0,0,0,1451,1449,1,0,0,0,1452,
        1453,5,18,0,0,1453,145,1,0,0,0,1454,1455,5,14,0,0,1455,1456,5,295,
        0,0,1456,1463,3,158,79,0,1457,1464,5,295,0,0,1458,1460,5,296,0,0,
        1459,1461,5,274,0,0,1460,1459,1,0,0,0,1460,1461,1,0,0,0,1461,1462,
        1,0,0,0,1462,1464,5,295,0,0,1463,1457,1,0,0,0,1463,1458,1,0,0,0,
        1464,1466,1,0,0,0,1465,1467,5,15,0,0,1466,1465,1,0,0,0,1466,1467,
        1,0,0,0,1467,1474,1,0,0,0,1468,1475,5,295,0,0,1469,1471,5,296,0,
        0,1470,1472,5,274,0,0,1471,1470,1,0,0,0,1471,1472,1,0,0,0,1472,1473,
        1,0,0,0,1473,1475,5,295,0,0,1474,1468,1,0,0,0,1474,1469,1,0,0,0,
        1474,1475,1,0,0,0,1475,1476,1,0,0,0,1476,1483,3,38,19,0,1477,1484,
        5,295,0,0,1478,1480,5,296,0,0,1479,1481,5,274,0,0,1480,1479,1,0,
        0,0,1480,1481,1,0,0,0,1481,1482,1,0,0,0,1482,1484,5,295,0,0,1483,
        1477,1,0,0,0,1483,1478,1,0,0,0,1484,1487,1,0,0,0,1485,1488,3,152,
        76,0,1486,1488,3,154,77,0,1487,1485,1,0,0,0,1487,1486,1,0,0,0,1488,
        147,1,0,0,0,1489,1490,5,14,0,0,1490,1491,5,295,0,0,1491,1495,3,158,
        79,0,1492,1494,7,1,0,0,1493,1492,1,0,0,0,1494,1497,1,0,0,0,1495,
        1493,1,0,0,0,1495,1496,1,0,0,0,1496,1498,1,0,0,0,1497,1495,1,0,0,
        0,1498,1502,5,15,0,0,1499,1501,7,1,0,0,1500,1499,1,0,0,0,1501,1504,
        1,0,0,0,1502,1500,1,0,0,0,1502,1503,1,0,0,0,1503,1505,1,0,0,0,1504,
        1502,1,0,0,0,1505,1517,3,38,19,0,1506,1512,5,295,0,0,1507,1509,5,
        274,0,0,1508,1507,1,0,0,0,1508,1509,1,0,0,0,1509,1510,1,0,0,0,1510,
        1512,5,295,0,0,1511,1506,1,0,0,0,1511,1508,1,0,0,0,1512,1515,1,0,
        0,0,1513,1516,3,152,76,0,1514,1516,3,154,77,0,1515,1513,1,0,0,0,
        1515,1514,1,0,0,0,1516,1518,1,0,0,0,1517,1511,1,0,0,0,1517,1518,
        1,0,0,0,1518,149,1,0,0,0,1519,1520,5,14,0,0,1520,1521,5,295,0,0,
        1521,1525,3,158,79,0,1522,1524,7,1,0,0,1523,1522,1,0,0,0,1524,1527,
        1,0,0,0,1525,1523,1,0,0,0,1525,1526,1,0,0,0,1526,1529,1,0,0,0,1527,
        1525,1,0,0,0,1528,1530,5,15,0,0,1529,1528,1,0,0,0,1529,1530,1,0,
        0,0,1530,1534,1,0,0,0,1531,1533,7,1,0,0,1532,1531,1,0,0,0,1533,1536,
        1,0,0,0,1534,1532,1,0,0,0,1534,1535,1,0,0,0,1535,1537,1,0,0,0,1536,
        1534,1,0,0,0,1537,1548,3,156,78,0,1538,1540,7,1,0,0,1539,1538,1,
        0,0,0,1540,1543,1,0,0,0,1541,1539,1,0,0,0,1541,1542,1,0,0,0,1542,
        1546,1,0,0,0,1543,1541,1,0,0,0,1544,1547,3,152,76,0,1545,1547,3,
        154,77,0,1546,1544,1,0,0,0,1546,1545,1,0,0,0,1547,1549,1,0,0,0,1548,
        1541,1,0,0,0,1548,1549,1,0,0,0,1549,151,1,0,0,0,1550,1557,5,16,0,
        0,1551,1558,5,295,0,0,1552,1554,5,296,0,0,1553,1555,5,274,0,0,1554,
        1553,1,0,0,0,1554,1555,1,0,0,0,1555,1556,1,0,0,0,1556,1558,5,295,
        0,0,1557,1551,1,0,0,0,1557,1552,1,0,0,0,1558,1559,1,0,0,0,1559,1560,
        3,38,19,0,1560,153,1,0,0,0,1561,1568,5,16,0,0,1562,1569,5,295,0,
        0,1563,1565,5,296,0,0,1564,1566,5,274,0,0,1565,1564,1,0,0,0,1565,
        1566,1,0,0,0,1566,1567,1,0,0,0,1567,1569,5,295,0,0,1568,1562,1,0,
        0,0,1568,1563,1,0,0,0,1569,1570,1,0,0,0,1570,1571,3,156,78,0,1571,
        155,1,0,0,0,1572,1574,5,274,0,0,1573,1572,1,0,0,0,1573,1574,1,0,
        0,0,1574,1575,1,0,0,0,1575,1577,5,295,0,0,1576,1573,1,0,0,0,1576,
        1577,1,0,0,0,1577,1578,1,0,0,0,1578,1579,3,4,2,0,1579,1580,7,35,
        0,0,1580,1589,1,0,0,0,1581,1583,5,274,0,0,1582,1581,1,0,0,0,1582,
        1583,1,0,0,0,1583,1584,1,0,0,0,1584,1586,5,295,0,0,1585,1582,1,0,
        0,0,1585,1586,1,0,0,0,1586,1587,1,0,0,0,1587,1589,3,4,2,0,1588,1576,
        1,0,0,0,1588,1585,1,0,0,0,1589,157,1,0,0,0,1590,1597,3,162,81,0,
        1591,1598,5,295,0,0,1592,1594,5,296,0,0,1593,1595,5,274,0,0,1594,
        1593,1,0,0,0,1594,1595,1,0,0,0,1595,1596,1,0,0,0,1596,1598,5,295,
        0,0,1597,1591,1,0,0,0,1597,1592,1,0,0,0,1598,1602,1,0,0,0,1599,1603,
        3,166,83,0,1600,1603,3,200,100,0,1601,1603,3,202,101,0,1602,1599,
        1,0,0,0,1602,1600,1,0,0,0,1602,1601,1,0,0,0,1603,1610,1,0,0,0,1604,
        1611,5,295,0,0,1605,1607,5,296,0,0,1606,1608,5,274,0,0,1607,1606,
        1,0,0,0,1607,1608,1,0,0,0,1608,1609,1,0,0,0,1609,1611,5,295,0,0,
        1610,1604,1,0,0,0,1610,1605,1,0,0,0,1611,1612,1,0,0,0,1612,1622,
        3,162,81,0,1613,1620,5,295,0,0,1614,1616,5,296,0,0,1615,1617,5,274,
        0,0,1616,1615,1,0,0,0,1616,1617,1,0,0,0,1617,1618,1,0,0,0,1618,1620,
        5,295,0,0,1619,1613,1,0,0,0,1619,1614,1,0,0,0,1619,1620,1,0,0,0,
        1620,1621,1,0,0,0,1621,1623,3,160,80,0,1622,1619,1,0,0,0,1622,1623,
        1,0,0,0,1623,1651,1,0,0,0,1624,1631,3,162,81,0,1625,1632,5,295,0,
        0,1626,1628,5,296,0,0,1627,1629,5,274,0,0,1628,1627,1,0,0,0,1628,
        1629,1,0,0,0,1629,1630,1,0,0,0,1630,1632,5,295,0,0,1631,1625,1,0,
        0,0,1631,1626,1,0,0,0,1631,1632,1,0,0,0,1632,1634,1,0,0,0,1633,1635,
        3,160,80,0,1634,1633,1,0,0,0,1634,1635,1,0,0,0,1635,1651,1,0,0,0,
        1636,1637,5,261,0,0,1637,1638,5,295,0,0,1638,1645,3,162,81,0,1639,
        1646,5,295,0,0,1640,1642,5,296,0,0,1641,1643,5,274,0,0,1642,1641,
        1,0,0,0,1642,1643,1,0,0,0,1643,1644,1,0,0,0,1644,1646,5,295,0,0,
        1645,1639,1,0,0,0,1645,1640,1,0,0,0,1645,1646,1,0,0,0,1646,1648,
        1,0,0,0,1647,1649,3,160,80,0,1648,1647,1,0,0,0,1648,1649,1,0,0,0,
        1649,1651,1,0,0,0,1650,1590,1,0,0,0,1650,1624,1,0,0,0,1650,1636,
        1,0,0,0,1651,159,1,0,0,0,1652,1656,3,166,83,0,1653,1656,3,200,100,
        0,1654,1656,3,202,101,0,1655,1652,1,0,0,0,1655,1653,1,0,0,0,1655,
        1654,1,0,0,0,1656,1663,1,0,0,0,1657,1664,5,295,0,0,1658,1660,5,296,
        0,0,1659,1661,5,274,0,0,1660,1659,1,0,0,0,1660,1661,1,0,0,0,1661,
        1662,1,0,0,0,1662,1664,5,295,0,0,1663,1657,1,0,0,0,1663,1658,1,0,
        0,0,1664,1665,1,0,0,0,1665,1672,3,162,81,0,1666,1673,5,295,0,0,1667,
        1669,5,296,0,0,1668,1670,5,274,0,0,1669,1668,1,0,0,0,1669,1670,1,
        0,0,0,1670,1671,1,0,0,0,1671,1673,5,295,0,0,1672,1666,1,0,0,0,1672,
        1667,1,0,0,0,1672,1673,1,0,0,0,1673,1675,1,0,0,0,1674,1676,3,160,
        80,0,1675,1674,1,0,0,0,1675,1676,1,0,0,0,1676,161,1,0,0,0,1677,1690,
        3,20,10,0,1678,1690,5,272,0,0,1679,1690,5,274,0,0,1680,1690,5,275,
        0,0,1681,1690,3,164,82,0,1682,1683,5,291,0,0,1683,1684,3,162,81,
        0,1684,1685,5,292,0,0,1685,1690,1,0,0,0,1686,1690,5,279,0,0,1687,
        1690,5,278,0,0,1688,1690,5,280,0,0,1689,1677,1,0,0,0,1689,1678,1,
        0,0,0,1689,1679,1,0,0,0,1689,1680,1,0,0,0,1689,1681,1,0,0,0,1689,
        1682,1,0,0,0,1689,1686,1,0,0,0,1689,1687,1,0,0,0,1689,1688,1,0,0,
        0,1690,163,1,0,0,0,1691,1694,5,80,0,0,1692,1693,5,295,0,0,1693,1695,
        5,277,0,0,1694,1692,1,0,0,0,1694,1695,1,0,0,0,1695,165,1,0,0,0,1696,
        1697,7,36,0,0,1697,167,1,0,0,0,1698,1700,5,51,0,0,1699,1701,5,295,
        0,0,1700,1699,1,0,0,0,1700,1701,1,0,0,0,1701,1702,1,0,0,0,1702,1704,
        3,128,64,0,1703,1705,5,295,0,0,1704,1703,1,0,0,0,1704,1705,1,0,0,
        0,1705,1706,1,0,0,0,1706,1707,3,170,85,0,1707,1708,7,37,0,0,1708,
        169,1,0,0,0,1709,1713,3,172,86,0,1710,1713,5,295,0,0,1711,1713,5,
        296,0,0,1712,1709,1,0,0,0,1712,1710,1,0,0,0,1712,1711,1,0,0,0,1713,
        1716,1,0,0,0,1714,1712,1,0,0,0,1714,1715,1,0,0,0,1715,1718,1,0,0,
        0,1716,1714,1,0,0,0,1717,1719,5,294,0,0,1718,1717,1,0,0,0,1718,1719,
        1,0,0,0,1719,171,1,0,0,0,1720,1760,3,8,4,0,1721,1760,3,168,84,0,
        1722,1760,3,174,87,0,1723,1760,3,178,89,0,1724,1760,3,134,67,0,1725,
        1760,3,140,70,0,1726,1760,3,126,63,0,1727,1760,3,122,61,0,1728,1760,
        3,116,58,0,1729,1760,3,120,60,0,1730,1760,3,28,14,0,1731,1760,3,
        32,16,0,1732,1760,3,46,23,0,1733,1760,3,56,28,0,1734,1760,3,40,20,
        0,1735,1760,3,64,32,0,1736,1760,3,68,34,0,1737,1760,3,70,35,0,1738,
        1760,3,80,40,0,1739,1760,3,88,44,0,1740,1760,3,90,45,0,1741,1760,
        3,92,46,0,1742,1760,3,100,50,0,1743,1760,3,102,51,0,1744,1760,3,
        14,7,0,1745,1760,3,22,11,0,1746,1760,3,196,98,0,1747,1760,3,180,
        90,0,1748,1760,3,26,13,0,1749,1760,3,10,5,0,1750,1760,3,38,19,0,
        1751,1760,3,36,18,0,1752,1760,3,106,53,0,1753,1760,3,108,54,0,1754,
        1760,3,112,56,0,1755,1760,3,114,57,0,1756,1760,3,130,65,0,1757,1760,
        3,132,66,0,1758,1760,3,206,103,0,1759,1720,1,0,0,0,1759,1721,1,0,
        0,0,1759,1722,1,0,0,0,1759,1723,1,0,0,0,1759,1724,1,0,0,0,1759,1725,
        1,0,0,0,1759,1726,1,0,0,0,1759,1727,1,0,0,0,1759,1728,1,0,0,0,1759,
        1729,1,0,0,0,1759,1730,1,0,0,0,1759,1731,1,0,0,0,1759,1732,1,0,0,
        0,1759,1733,1,0,0,0,1759,1734,1,0,0,0,1759,1735,1,0,0,0,1759,1736,
        1,0,0,0,1759,1737,1,0,0,0,1759,1738,1,0,0,0,1759,1739,1,0,0,0,1759,
        1740,1,0,0,0,1759,1741,1,0,0,0,1759,1742,1,0,0,0,1759,1743,1,0,0,
        0,1759,1744,1,0,0,0,1759,1745,1,0,0,0,1759,1746,1,0,0,0,1759,1747,
        1,0,0,0,1759,1748,1,0,0,0,1759,1749,1,0,0,0,1759,1750,1,0,0,0,1759,
        1751,1,0,0,0,1759,1752,1,0,0,0,1759,1753,1,0,0,0,1759,1754,1,0,0,
        0,1759,1755,1,0,0,0,1759,1756,1,0,0,0,1759,1757,1,0,0,0,1759,1758,
        1,0,0,0,1760,173,1,0,0,0,1761,1763,5,55,0,0,1762,1764,5,295,0,0,
        1763,1762,1,0,0,0,1763,1764,1,0,0,0,1764,1765,1,0,0,0,1765,1767,
        5,293,0,0,1766,1768,5,295,0,0,1767,1766,1,0,0,0,1767,1768,1,0,0,
        0,1768,1769,1,0,0,0,1769,1771,5,3,0,0,1770,1772,5,295,0,0,1771,1770,
        1,0,0,0,1771,1772,1,0,0,0,1772,1773,1,0,0,0,1773,1775,5,293,0,0,
        1774,1776,5,295,0,0,1775,1774,1,0,0,0,1775,1776,1,0,0,0,1776,1777,
        1,0,0,0,1777,1779,3,176,88,0,1778,1780,5,295,0,0,1779,1778,1,0,0,
        0,1779,1780,1,0,0,0,1780,1781,1,0,0,0,1781,1782,5,56,0,0,1782,175,
        1,0,0,0,1783,1787,3,4,2,0,1784,1787,5,295,0,0,1785,1787,5,296,0,
        0,1786,1783,1,0,0,0,1786,1784,1,0,0,0,1786,1785,1,0,0,0,1787,1790,
        1,0,0,0,1788,1786,1,0,0,0,1788,1789,1,0,0,0,1789,1792,1,0,0,0,1790,
        1788,1,0,0,0,1791,1793,5,294,0,0,1792,1791,1,0,0,0,1792,1793,1,0,
        0,0,1793,177,1,0,0,0,1794,1796,5,63,0,0,1795,1797,5,295,0,0,1796,
        1795,1,0,0,0,1796,1797,1,0,0,0,1797,1799,1,0,0,0,1798,1800,5,272,
        0,0,1799,1798,1,0,0,0,1799,1800,1,0,0,0,1800,1802,1,0,0,0,1801,1803,
        5,295,0,0,1802,1801,1,0,0,0,1802,1803,1,0,0,0,1803,1814,1,0,0,0,
        1804,1806,5,295,0,0,1805,1804,1,0,0,0,1805,1806,1,0,0,0,1806,1807,
        1,0,0,0,1807,1809,5,299,0,0,1808,1810,5,295,0,0,1809,1808,1,0,0,
        0,1809,1810,1,0,0,0,1810,1811,1,0,0,0,1811,1813,5,272,0,0,1812,1805,
        1,0,0,0,1813,1816,1,0,0,0,1814,1812,1,0,0,0,1814,1815,1,0,0,0,1815,
        1818,1,0,0,0,1816,1814,1,0,0,0,1817,1819,5,12,0,0,1818,1817,1,0,
        0,0,1818,1819,1,0,0,0,1819,1821,1,0,0,0,1820,1822,5,296,0,0,1821,
        1820,1,0,0,0,1821,1822,1,0,0,0,1822,1824,1,0,0,0,1823,1825,5,274,
        0,0,1824,1823,1,0,0,0,1824,1825,1,0,0,0,1825,1827,1,0,0,0,1826,1828,
        5,295,0,0,1827,1826,1,0,0,0,1827,1828,1,0,0,0,1828,1830,1,0,0,0,
        1829,1831,5,28,0,0,1830,1829,1,0,0,0,1830,1831,1,0,0,0,1831,1833,
        1,0,0,0,1832,1834,5,295,0,0,1833,1832,1,0,0,0,1833,1834,1,0,0,0,
        1834,1836,1,0,0,0,1835,1837,5,296,0,0,1836,1835,1,0,0,0,1836,1837,
        1,0,0,0,1837,1839,1,0,0,0,1838,1840,5,295,0,0,1839,1838,1,0,0,0,
        1839,1840,1,0,0,0,1840,1842,1,0,0,0,1841,1843,5,293,0,0,1842,1841,
        1,0,0,0,1842,1843,1,0,0,0,1843,1845,1,0,0,0,1844,1846,5,295,0,0,
        1845,1844,1,0,0,0,1845,1846,1,0,0,0,1846,1848,1,0,0,0,1847,1849,
        5,273,0,0,1848,1847,1,0,0,0,1848,1849,1,0,0,0,1849,1851,1,0,0,0,
        1850,1852,5,285,0,0,1851,1850,1,0,0,0,1851,1852,1,0,0,0,1852,1854,
        1,0,0,0,1853,1855,5,295,0,0,1854,1853,1,0,0,0,1854,1855,1,0,0,0,
        1855,1857,1,0,0,0,1856,1858,5,272,0,0,1857,1856,1,0,0,0,1857,1858,
        1,0,0,0,1858,1860,1,0,0,0,1859,1861,3,178,89,0,1860,1859,1,0,0,0,
        1860,1861,1,0,0,0,1861,179,1,0,0,0,1862,1864,5,213,0,0,1863,1865,
        5,295,0,0,1864,1863,1,0,0,0,1864,1865,1,0,0,0,1865,1867,1,0,0,0,
        1866,1868,5,124,0,0,1867,1866,1,0,0,0,1867,1868,1,0,0,0,1868,1870,
        1,0,0,0,1869,1871,5,295,0,0,1870,1869,1,0,0,0,1870,1871,1,0,0,0,
        1871,1872,1,0,0,0,1872,1874,3,20,10,0,1873,1875,5,295,0,0,1874,1873,
        1,0,0,0,1874,1875,1,0,0,0,1875,1877,1,0,0,0,1876,1878,5,273,0,0,
        1877,1876,1,0,0,0,1877,1878,1,0,0,0,1878,1879,1,0,0,0,1879,1882,
        5,285,0,0,1880,1883,3,162,81,0,1881,1883,5,295,0,0,1882,1880,1,0,
        0,0,1882,1881,1,0,0,0,1883,1884,1,0,0,0,1884,1882,1,0,0,0,1884,1885,
        1,0,0,0,1885,181,1,0,0,0,1886,1890,5,43,0,0,1887,1889,3,198,99,0,
        1888,1887,1,0,0,0,1889,1892,1,0,0,0,1890,1888,1,0,0,0,1890,1891,
        1,0,0,0,1891,1894,1,0,0,0,1892,1890,1,0,0,0,1893,1895,5,296,0,0,
        1894,1893,1,0,0,0,1894,1895,1,0,0,0,1895,183,1,0,0,0,1896,1900,5,
        45,0,0,1897,1899,3,198,99,0,1898,1897,1,0,0,0,1899,1902,1,0,0,0,
        1900,1898,1,0,0,0,1900,1901,1,0,0,0,1901,1904,1,0,0,0,1902,1900,
        1,0,0,0,1903,1905,5,296,0,0,1904,1903,1,0,0,0,1904,1905,1,0,0,0,
        1905,185,1,0,0,0,1906,1910,5,44,0,0,1907,1909,3,198,99,0,1908,1907,
        1,0,0,0,1909,1912,1,0,0,0,1910,1908,1,0,0,0,1910,1911,1,0,0,0,1911,
        1914,1,0,0,0,1912,1910,1,0,0,0,1913,1915,5,296,0,0,1914,1913,1,0,
        0,0,1914,1915,1,0,0,0,1915,187,1,0,0,0,1916,1920,5,46,0,0,1917,1919,
        3,198,99,0,1918,1917,1,0,0,0,1919,1922,1,0,0,0,1920,1918,1,0,0,0,
        1920,1921,1,0,0,0,1921,1924,1,0,0,0,1922,1920,1,0,0,0,1923,1925,
        5,296,0,0,1924,1923,1,0,0,0,1924,1925,1,0,0,0,1925,189,1,0,0,0,1926,
        1928,5,67,0,0,1927,1929,5,295,0,0,1928,1927,1,0,0,0,1928,1929,1,
        0,0,0,1929,1931,1,0,0,0,1930,1932,5,124,0,0,1931,1930,1,0,0,0,1931,
        1932,1,0,0,0,1932,1934,1,0,0,0,1933,1935,5,295,0,0,1934,1933,1,0,
        0,0,1934,1935,1,0,0,0,1935,1936,1,0,0,0,1936,1938,3,20,10,0,1937,
        1939,5,295,0,0,1938,1937,1,0,0,0,1938,1939,1,0,0,0,1939,1941,1,0,
        0,0,1940,1942,5,273,0,0,1941,1940,1,0,0,0,1941,1942,1,0,0,0,1942,
        1943,1,0,0,0,1943,1945,5,285,0,0,1944,1946,5,295,0,0,1945,1944,1,
        0,0,0,1945,1946,1,0,0,0,1946,1947,1,0,0,0,1947,1949,3,162,81,0,1948,
        1950,5,295,0,0,1949,1948,1,0,0,0,1949,1950,1,0,0,0,1950,1951,1,0,
        0,0,1951,1953,3,202,101,0,1952,1954,5,295,0,0,1953,1952,1,0,0,0,
        1953,1954,1,0,0,0,1954,1955,1,0,0,0,1955,1957,3,162,81,0,1956,1958,
        5,295,0,0,1957,1956,1,0,0,0,1957,1958,1,0,0,0,1958,1960,1,0,0,0,
        1959,1961,3,194,97,0,1960,1959,1,0,0,0,1960,1961,1,0,0,0,1961,1986,
        1,0,0,0,1962,1964,5,67,0,0,1963,1965,5,295,0,0,1964,1963,1,0,0,0,
        1964,1965,1,0,0,0,1965,1967,1,0,0,0,1966,1968,5,124,0,0,1967,1966,
        1,0,0,0,1967,1968,1,0,0,0,1968,1970,1,0,0,0,1969,1971,5,295,0,0,
        1970,1969,1,0,0,0,1970,1971,1,0,0,0,1971,1972,1,0,0,0,1972,1974,
        3,20,10,0,1973,1975,5,295,0,0,1974,1973,1,0,0,0,1974,1975,1,0,0,
        0,1975,1977,1,0,0,0,1976,1978,5,273,0,0,1977,1976,1,0,0,0,1977,1978,
        1,0,0,0,1978,1979,1,0,0,0,1979,1981,5,285,0,0,1980,1982,5,295,0,
        0,1981,1980,1,0,0,0,1981,1982,1,0,0,0,1982,1983,1,0,0,0,1983,1984,
        3,162,81,0,1984,1986,1,0,0,0,1985,1926,1,0,0,0,1985,1962,1,0,0,0,
        1986,191,1,0,0,0,1987,1989,5,293,0,0,1988,1990,5,295,0,0,1989,1988,
        1,0,0,0,1989,1990,1,0,0,0,1990,1992,1,0,0,0,1991,1993,5,273,0,0,
        1992,1991,1,0,0,0,1992,1993,1,0,0,0,1993,1994,1,0,0,0,1994,1996,
        5,285,0,0,1995,1997,5,295,0,0,1996,1995,1,0,0,0,1996,1997,1,0,0,
        0,1997,1998,1,0,0,0,1998,2000,3,162,81,0,1999,2001,5,295,0,0,2000,
        1999,1,0,0,0,2000,2001,1,0,0,0,2001,2002,1,0,0,0,2002,2004,3,202,
        101,0,2003,2005,5,295,0,0,2004,2003,1,0,0,0,2004,2005,1,0,0,0,2005,
        2006,1,0,0,0,2006,2008,3,162,81,0,2007,2009,5,295,0,0,2008,2007,
        1,0,0,0,2008,2009,1,0,0,0,2009,2011,1,0,0,0,2010,2012,3,194,97,0,
        2011,2010,1,0,0,0,2011,2012,1,0,0,0,2012,193,1,0,0,0,2013,2015,3,
        202,101,0,2014,2016,5,295,0,0,2015,2014,1,0,0,0,2015,2016,1,0,0,
        0,2016,2017,1,0,0,0,2017,2019,3,162,81,0,2018,2020,5,295,0,0,2019,
        2018,1,0,0,0,2019,2020,1,0,0,0,2020,2022,1,0,0,0,2021,2023,3,194,
        97,0,2022,2021,1,0,0,0,2022,2023,1,0,0,0,2023,195,1,0,0,0,2024,2031,
        3,182,91,0,2025,2031,3,186,93,0,2026,2031,3,184,92,0,2027,2031,3,
        188,94,0,2028,2031,3,190,95,0,2029,2031,3,192,96,0,2030,2024,1,0,
        0,0,2030,2025,1,0,0,0,2030,2026,1,0,0,0,2030,2027,1,0,0,0,2030,2028,
        1,0,0,0,2030,2029,1,0,0,0,2031,197,1,0,0,0,2032,2033,7,38,0,0,2033,
        199,1,0,0,0,2034,2035,7,39,0,0,2035,201,1,0,0,0,2036,2037,7,40,0,
        0,2037,203,1,0,0,0,2038,2039,7,41,0,0,2039,205,1,0,0,0,2040,2042,
        8,42,0,0,2041,2040,1,0,0,0,2042,2043,1,0,0,0,2043,2044,1,0,0,0,2043,
        2041,1,0,0,0,2044,207,1,0,0,0,357,212,214,218,223,267,275,283,289,
        291,297,304,308,314,317,321,324,337,339,342,349,353,356,360,366,
        369,374,379,383,388,390,395,411,417,430,432,440,445,447,450,455,
        457,476,482,491,498,501,504,507,510,513,516,520,523,526,529,532,
        535,540,544,547,552,558,562,565,570,574,577,581,584,587,589,592,
        597,602,605,608,611,614,617,620,624,627,630,635,639,643,646,650,
        656,666,673,675,680,692,694,699,710,715,722,724,751,753,765,767,
        772,781,786,793,795,829,831,838,841,848,851,855,860,862,865,877,
        883,887,891,894,897,900,903,906,909,912,916,919,924,931,933,938,
        948,954,957,962,971,978,984,986,993,997,1005,1012,1014,1045,1047,
        1060,1063,1072,1075,1081,1089,1092,1098,1102,1118,1120,1127,1136,
        1139,1145,1147,1162,1169,1172,1175,1179,1184,1193,1198,1201,1204,
        1208,1213,1217,1227,1232,1235,1238,1242,1249,1251,1258,1264,1268,
        1274,1276,1285,1290,1294,1298,1301,1308,1311,1317,1323,1329,1332,
        1336,1339,1344,1350,1354,1367,1374,1380,1385,1388,1391,1394,1396,
        1399,1402,1405,1412,1422,1430,1434,1439,1443,1449,1460,1463,1466,
        1471,1474,1480,1483,1487,1495,1502,1508,1511,1515,1517,1525,1529,
        1534,1541,1546,1548,1554,1557,1565,1568,1573,1576,1582,1585,1588,
        1594,1597,1602,1607,1610,1616,1619,1622,1628,1631,1634,1642,1645,
        1648,1650,1655,1660,1663,1669,1672,1675,1689,1694,1700,1704,1712,
        1714,1718,1759,1763,1767,1771,1775,1779,1786,1788,1792,1796,1799,
        1802,1805,1809,1814,1818,1821,1824,1827,1830,1833,1836,1839,1842,
        1845,1848,1851,1854,1857,1860,1864,1867,1870,1874,1877,1882,1884,
        1890,1894,1900,1904,1910,1914,1920,1924,1928,1931,1934,1938,1941,
        1945,1949,1953,1957,1960,1964,1967,1970,1974,1977,1981,1985,1989,
        1992,1996,2000,2004,2008,2011,2015,2019,2022,2030,2043
    ]

class NaturalParser ( Parser ):

    grammarFileName = "NaturalParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'DEFINE'", "'FUNCTION'", "'RETURNS'", 
                     "'DATA'", "'LOCAL'", "'GLOBAL'", "'PARAMETER'", "'REDEFINE'", 
                     "'PERFORM'", "'CALLNAT'", "'ESCAPE'", "'ESCAPE BOTTOM'", 
                     "'RETURN'", "'IF'", "'THEN'", "'ELSE'", "'ELSE IF'", 
                     "'END-IF'", "'DECIDE'", "'END-DECIDE'", "'WHEN'", "'FOR'", 
                     "'THRU'", "'EVERY'", "'FIRST'", "'CONDITION'", "'ANY'", 
                     "'NONE'", "'ALL'", "'UNIQUE'", "'REPEAT'", "<INVALID>", 
                     "'END-FOR'", "'END'", "'READ'", "<INVALID>", "'SELECT'", 
                     "<INVALID>", "'STORE'", "<INVALID>", "'GET'", "'OBTAIN'", 
                     "'ADD'", "'SUBTRACT'", "'MULTIPLY'", "'DIVIDE'", "'MOVE'", 
                     "'VALUE OF'", "'TO'", "'DO'", "'DEFINE SUBROUTINE'", 
                     "'END-SUBROUTINE'", "'DEFINE SUBPROGRAM'", "'END-SUBPROGRAM'", 
                     "'DEFINE FUNCTION'", "'END-FUNCTION'", "'END-READ'", 
                     "'END-FIND'", "'END-SELECT'", "'END TRANSACTION'", 
                     "'BACKOUT TRANSACTION'", "'END-ALL'", "'VALUE'", "'DOEND'", 
                     "'USING HELP'", "'USING'", "'COMPUTE'", "'INPUT'", 
                     "'MAP'", "'RESET'", "'SET KEY'", "'COMPRESS'", "'NO RECORDS FOUND'", 
                     "'NO RECORD FOUND'", "'END-NOREC'", "'REINPUT'", "'MARK'", 
                     "'WITH TEXT'", "'FULL'", "'POSITION'", "'IN'", "'ALARM'", 
                     "'RECORD'", "'RECORDS'", "'STATEMENT'", "'SET'", "'SAME'", 
                     "'GET TRANSACTION DATA'", "'GET SAME'", "'WITH'", "'ACCEPT IF'", 
                     "'REJECT IF'", "'EXAMINE'", "'SUBSTRING'", "'REPLACE'", 
                     "'GIVING'", "'ABSOLUTE'", "'CHARPOSITION'", "'CHARLENGTH'", 
                     "'LENGTH'", "'NUMBER'", "'TRANSLATE'", "'DELIMITER'", 
                     "'UPPPER CASE'", "'LOWER CASE'", "'INTO'", "'INVERTED'", 
                     "'INDEX'", "'INDEXED'", "'PATTERN'", "'DISPLAY'", "'WRITE'", 
                     "'WRITE TITLE'", "'WRITE TRAILER'", "'FIELD'", "'BY NAME'", 
                     "'BY POSITION'", "'EDITED'", "'LEFT'", "'RIGHT'", "'JUSTIFIED'", 
                     "'NORMALIZED'", "'ENCODED'", "'ROUNDED'", "'SEPARATE'", 
                     "'SORT'", "'END-SORT'", "'FORMAT'", "'SKIP'", "'EJECT'", 
                     "'NEWPAGE'", "'SUSPEND IDENTICAL SUPPRESS'", "'DEFINE PRINTER'", 
                     "'CLOSE PRINTER'", "'DEFINE WINDOW'", "'SET WINDOW'", 
                     "'PROCESS PAGE'", "'PROCESS PAGE USING'", "'PROCESS PAGE UPDATE'", 
                     "'PROCESS PAGE MODAL'", "'IF SELECTION'", "'DECIDE FOR'", 
                     "'DECIDE ON'", "'CALL'", "'CALL FILE'", "'CALL LOOP'", 
                     "'FETCH'", "'PROCESS COMMAND'", "'RUN'", "'DEFINE PROTOTYPE'", 
                     "'Function Call'", "'STOP'", "'TERMINATE'", "'WRITE WORK FILE'", 
                     "'WRITE WORK'", "'DOWNLOAD PC FILE'", "'READ WORK FILE'", 
                     "'READ WORK'", "'UPLOAD PC FILE'", "'CLOSE WORK FILE'", 
                     "'CLOSE WORK'", "'CLOSE PC FILE'", "'DEFINE WORK FILE'", 
                     "'DEFINE CLASS'", "'CREATE OBJECT'", "'SEND METHOD'", 
                     "'INTERFACE'", "'METHOD'", "'PROPERTY'", "'EXPAND'", 
                     "'REDUCE'", "'RESIZE'", "'OPEN CONVERSATION'", "'CLOSE CONVERSATION'", 
                     "'DEFINE DATA CONTEXT'", "'PARSE'", "'REQUEST DOCUMENT'", 
                     "'RETRY'", "'AT START OF DATA'", "'AT END OF DATA'", 
                     "'AT BREAK'", "'BEFORE BREAK PROCESSING'", "'PERFORM BREAK PROCESSING'", 
                     "'CALLDBPROC'", "'COMMIT'", "'PROCESS SQL'", "'READ RESULT SET'", 
                     "'ROLLBACK'", "'WRITE / PRINT'", "'AT TOP OF PAGE'", 
                     "'AT END OF PAGE'", "'DEFINE DATA'", "'END-DEFINE'", 
                     "'INCLUDE'", "'ON ERROR'", "'RELEASE'", "'SET CONTROL'", 
                     "'SET GLOBALS'", "'SET TIME'", "'STACK'", "'ACCEPT'", 
                     "'REJECT'", "'PASSW'", "'LIMIT'", "'INSERT'", "<INVALID>", 
                     "'END-HISTOGRAM'", "'THEN_DO'", "'IGNORE'", "'FRAC'", 
                     "'FROM'", "'VIEW'", "'ASSIGN'", "'NUMERIC'", "'LEAVING SPACE'", 
                     "<INVALID>", "'END-START'", "'ON'", "'OFF'", "'BY'", 
                     "'INTERFACE4'", "'RETAIN AS'", "'WHERE'", "'STARTING WITH'", 
                     "'COUPLED'", "'VIA'", "'BUT'", "'SORTED'", "'ASCENDING'", 
                     "'DESCENDING'", "'OF'", "'MULTI-FETCH'", "'STARTING FROM'", 
                     "'ENDING AT'", "'VARIABLE'", "'DYNAMIC'", "'SEQUENCE'", 
                     "'END-WORK'", "'OFFSET'", "'FILLER'", "'ONCE'", "'AT END OF FILE'", 
                     "'END-ENDFILE'", "'PASSWORD'", "'CIPHER'", "'FILE'", 
                     "'REPOSITION'", "'PHYSICAL'", "'STARTING'", "'ENDING'", 
                     "'AT'", "'AS'", "'GT'", "'LT'", "'GE'", "'LE'", "'EQ'", 
                     "'NE'", "'AND'", "'OR'", "'NOT'", "'AND='", "'OR='", 
                     "'OR ='", "'EQUAL'", "'NOTEQUAL'", "'EQUAL TO'", "'LESS THAN'", 
                     "'GREATER THAN'", "'LESS EQUAL'", "'GREATER EQUAL'", 
                     "<INVALID>", "':'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'+'", "'-'", "'*'", "'/'", "'='", "'>'", "'<'", "'>='", 
                     "'<='", "'!='", "'('", "')'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','", "'%'", "'&'", "'|'", "'^'", "'!'", "'~'", "'?'", 
                     "'.'", "'['", "']'", "'{'", "'}'", "'DUMMY_TEXT'" ]

    symbolicNames = [ "<INVALID>", "DEFINE", "FUNCTION", "RETURNS", "DATA", 
                      "LOCAL", "GLOBAL", "PARAMETER", "REDEFINE", "PERFORM", 
                      "CALLNAT", "ESCAPE", "ESCAPE_BOTTOM", "RETURN", "IF", 
                      "THEN", "ELSE", "ELSE_IF", "END_IF", "DECIDE", "END_DECIDE", 
                      "WHEN", "FOR", "THRU", "EVERY", "FIRST", "CONDITION", 
                      "ANY", "NONE", "ALL", "UNIQUE_LEX", "REPEAT", "LOOP", 
                      "END_FOR", "END", "READ", "FIND", "SELECT", "UPDATE", 
                      "STORE", "DELETE", "GET", "OBTAIN", "ADD", "SUBTRACT", 
                      "MULTIPLY", "DIVIDE", "MOVE", "VALUE_OF", "TO", "DO", 
                      "DEFINE_SUBROUTINE", "END_SUBROUTINE", "DEFINE_SUBPROGRAM", 
                      "END_SUBPROGRAM", "DEFINE_FUNCTION", "END_FUNCTION", 
                      "END_READ", "END_FIND", "END_SELECT", "END_TRANSACTION", 
                      "BACKOUT_TRANSACTION", "END_ALL", "VALUE", "DOEND", 
                      "USING_HELP", "USING", "COMPUTE", "INPUT", "MAP", 
                      "RESET", "SET_KEY", "COMPRESS", "NO_RECORDS_FOUND", 
                      "NO_RECORD_FOUND", "END_NOREC", "REINPUT", "MARK", 
                      "WITH_TEXT", "FULL", "POSITION", "IN", "ALARM", "RECORD", 
                      "RECORDS", "STATEMENT", "SET", "SAME", "GET_TRANSACTION_DATA", 
                      "GET_SAME", "WITH", "ACCEPT_IF", "REJECT_IF", "EXAMINE", 
                      "SUBSTRING", "REPLACE", "GIVING", "ABSOLUTE", "CHARPOSITION", 
                      "CHARLENGTH", "LENGTH", "NUMBER", "TRANSLATE", "DELIMITER", 
                      "UPPPER_CASE", "LOWER_CASE", "INTO", "INVERTED", "INDEX", 
                      "INDEXED", "PATTERN", "DISPLAY", "WRITE", "WRITE_TITLE", 
                      "WRITE_TRAILER", "FIELD", "BY_NAME", "BY_POSITION", 
                      "EDITED", "LEFT", "RIGHT", "JUSTIFIED", "NORMALIZED", 
                      "ENCODED", "ROUNDED", "SEPARATE", "SORT", "END_SORT", 
                      "FORMAT", "SKIP_LEX", "EJECT", "NEWPAGE", "SUSPEND_IDENTICAL_SUPPRESS", 
                      "DEFINE_PRINTER", "CLOSE_PRINTER", "DEFINE_WINDOW", 
                      "SET_WINDOW", "PROCESS_PAGE", "PROCESS_PAGE_USING", 
                      "PROCESS_PAGE_UPDATE", "PROCESS_PAGE_MODAL", "IF_SELECTION", 
                      "DECIDE_FOR", "DECIDE_ON", "CALL", "CALL_FILE", "CALL_LOOP", 
                      "FETCH", "PROCESS_COMMAND", "RUN", "DEFINE_PROTOTYPE", 
                      "FUNCTION_CALL", "STOP", "TERMINATE", "WRITE_WORK_FILE", 
                      "WRITE_WORK", "DOWNLOAD_PC_FILE", "READ_WORK_FILE", 
                      "READ_WORK", "UPLOAD_PC_FILE", "CLOSE_WORK_FILE", 
                      "CLOSE_WORK", "CLOSE_PC_FILE", "DEFINE_WORK_FILE", 
                      "DEFINE_CLASS", "CREATE_OBJECT", "SEND_METHOD", "INTERFACE", 
                      "METHOD", "PROPERTY", "EXPAND", "REDUCE", "RESIZE", 
                      "OPEN_CONVERSATION", "CLOSE_CONVERSATION", "DEFINE_DATA_CONTEXT", 
                      "PARSE", "REQUEST_DOCUMENT", "RETRY", "AT_START_OF_DATA", 
                      "AT_END_OF_DATA", "AT_BREAK", "BEFORE_BREAK_PROCESSING", 
                      "PERFORM_BREAK_PROCESSING", "CALLDBPROC", "COMMIT", 
                      "PROCESS_SQL", "READ_RESULT_SET", "ROLLBACK", "WRITE_PRINT", 
                      "AT_TOP_OF_PAGE", "AT_END_OF_PAGE", "DEFINE_DATA", 
                      "END_DEFINE", "INCLUDE", "ON_ERROR", "RELEASE", "SET_CONTROL", 
                      "SET_GLOBALS", "SET_TIME", "STACK", "ACCEPT", "REJECT", 
                      "PASSW", "LIMIT", "INSERT", "HISTOGRAM", "END_HISTOGRAM", 
                      "THEN_DO", "IGNORE", "FRAC", "FROM", "VIEW", "ASSIGN", 
                      "NUMERIC", "LEAVING_SPACE", "LEAVING_NO_SPACE", "END_START", 
                      "ON", "OFF", "BY", "INTERFACE4", "RETAIN_AS", "WHERE", 
                      "STARTING_WITH", "COUPLED", "VIA", "BUT", "SORTED", 
                      "ASCENDING", "DESCENDING", "OF", "MULTI_FETCH", "STARTING_FROM", 
                      "ENDING_AT", "VARIABLE", "DYNAMIC", "SEQUENCE", "END_WORK", 
                      "OFFSET", "FILLER", "ONCE", "AT_END_OF_FILE", "END_ENDFILE", 
                      "PASSWORD", "CIPHER", "FILE", "REPOSITION", "PHYSICAL", 
                      "STARTING", "ENDING", "AT", "AS", "GT_TEXT", "LT_TEXT", 
                      "GE_TEXT", "LE_TEXT", "EQ_TEXT", "NE_TEXT", "AND_TEXT", 
                      "OR_TEXT", "NOT_TEXT", "AND_EQ", "OR_RQ", "OR_SRQ", 
                      "EQUAL", "NOTEQUAL", "EQUAL_TO", "LESS_THAN", "GREATER_THAN", 
                      "LESS_EQUAL", "GREATER_EQUAL", "STRING", "COLON", 
                      "LINE_NUMBER", "FLOAT", "LITERAL", "LINE_REF", "INPUT_PARAM", 
                      "DATE_CONSTANT", "H_CONSTANT", "PLUS", "MINUS", "MULT", 
                      "DIV", "EQ", "GT", "LT", "GE", "LE", "NE", "LPAREN", 
                      "RPAREN", "IDENTIFIER", "TRAILING_COMMENT", "WS", 
                      "NL", "WS_C", "NL_C", "COMMA", "MOD", "AND", "OR", 
                      "XOR", "NOT", "TILDE", "QUESTION", "DOT", "LBRACK", 
                      "RBRACK", "LBRACE", "RBRACE", "LABEL" ]

    RULE_program = 0
    RULE_lineNumberStatement = 1
    RULE_statement = 2
    RULE_label = 3
    RULE_dataDefinition = 4
    RULE_compressStatement = 5
    RULE_compressEnd = 6
    RULE_inputStatement = 7
    RULE_inputOptions = 8
    RULE_inputUsingMap = 9
    RULE_variable = 10
    RULE_reinputStatement = 11
    RULE_reinputOptions = 12
    RULE_sortStatement = 13
    RULE_examineStatement = 14
    RULE_examineOptions = 15
    RULE_moveStatement = 16
    RULE_moveOptions = 17
    RULE_repeatStatement = 18
    RULE_doStatement = 19
    RULE_storeStatement = 20
    RULE_storePreview2 = 21
    RULE_storeCondition = 22
    RULE_findStatement = 23
    RULE_findQuery = 24
    RULE_findNumber = 25
    RULE_findPreview1 = 26
    RULE_findPreview2 = 27
    RULE_readStatement = 28
    RULE_readQuery = 29
    RULE_readPreview1 = 30
    RULE_readPreview2 = 31
    RULE_updateStatement = 32
    RULE_updateStartline = 33
    RULE_deleteStatement = 34
    RULE_getStatements = 35
    RULE_getTabledStatements = 36
    RULE_getTabledOptions = 37
    RULE_getTransactionStatement = 38
    RULE_getSameStatement = 39
    RULE_histogramStatement = 40
    RULE_histogramQuery = 41
    RULE_histogramPreview = 42
    RULE_histogramOptions = 43
    RULE_endTransaction = 44
    RULE_backoutTransaction = 45
    RULE_readworkfileStatement = 46
    RULE_workfilenumberOption = 47
    RULE_readworkfileOptions = 48
    RULE_atEndOfFileStatement = 49
    RULE_writeworkfileStatement = 50
    RULE_closeworkfileStatement = 51
    RULE_noRecordsFoundStatement = 52
    RULE_atStartOfDataStatement = 53
    RULE_formatStatement = 54
    RULE_formatOptions = 55
    RULE_assignmentStatement = 56
    RULE_includeStatement = 57
    RULE_redefineStatement = 58
    RULE_redefineBody = 59
    RULE_resetStatement = 60
    RULE_callnatStatement = 61
    RULE_setkeyStatement = 62
    RULE_performStatement = 63
    RULE_subroutineNames = 64
    RULE_fetchStatement = 65
    RULE_callStatement = 66
    RULE_forStatement = 67
    RULE_acceptRejectIfStatement = 68
    RULE_decisionStatement = 69
    RULE_ifStatement = 70
    RULE_ifStructuredStatement = 71
    RULE_elseStructured = 72
    RULE_ifElseStatement = 73
    RULE_ifMultilinedStatement = 74
    RULE_ifSinglelinedStatement = 75
    RULE_elseMultilinedStatement = 76
    RULE_elseSinglelinedStatement = 77
    RULE_onelinerBody = 78
    RULE_condition = 79
    RULE_optionalCondition = 80
    RULE_operand = 81
    RULE_naturalKeywords = 82
    RULE_logicalOp = 83
    RULE_subroutine = 84
    RULE_blockContentSubroutine = 85
    RULE_subroutineStatement = 86
    RULE_functionDefinition = 87
    RULE_blockContent = 88
    RULE_valueAssignment = 89
    RULE_assignStatement = 90
    RULE_addOperation = 91
    RULE_multiplyOperation = 92
    RULE_subtractOperation = 93
    RULE_divideOperation = 94
    RULE_computeOperation = 95
    RULE_arithmaticOperation = 96
    RULE_optionalCompute = 97
    RULE_calculations = 98
    RULE_addContent = 99
    RULE_compOp = 100
    RULE_arithmaticOp = 101
    RULE_endStatement = 102
    RULE_otherStatement = 103

    ruleNames =  [ "program", "lineNumberStatement", "statement", "label", 
                   "dataDefinition", "compressStatement", "compressEnd", 
                   "inputStatement", "inputOptions", "inputUsingMap", "variable", 
                   "reinputStatement", "reinputOptions", "sortStatement", 
                   "examineStatement", "examineOptions", "moveStatement", 
                   "moveOptions", "repeatStatement", "doStatement", "storeStatement", 
                   "storePreview2", "storeCondition", "findStatement", "findQuery", 
                   "findNumber", "findPreview1", "findPreview2", "readStatement", 
                   "readQuery", "readPreview1", "readPreview2", "updateStatement", 
                   "updateStartline", "deleteStatement", "getStatements", 
                   "getTabledStatements", "getTabledOptions", "getTransactionStatement", 
                   "getSameStatement", "histogramStatement", "histogramQuery", 
                   "histogramPreview", "histogramOptions", "endTransaction", 
                   "backoutTransaction", "readworkfileStatement", "workfilenumberOption", 
                   "readworkfileOptions", "atEndOfFileStatement", "writeworkfileStatement", 
                   "closeworkfileStatement", "noRecordsFoundStatement", 
                   "atStartOfDataStatement", "formatStatement", "formatOptions", 
                   "assignmentStatement", "includeStatement", "redefineStatement", 
                   "redefineBody", "resetStatement", "callnatStatement", 
                   "setkeyStatement", "performStatement", "subroutineNames", 
                   "fetchStatement", "callStatement", "forStatement", "acceptRejectIfStatement", 
                   "decisionStatement", "ifStatement", "ifStructuredStatement", 
                   "elseStructured", "ifElseStatement", "ifMultilinedStatement", 
                   "ifSinglelinedStatement", "elseMultilinedStatement", 
                   "elseSinglelinedStatement", "onelinerBody", "condition", 
                   "optionalCondition", "operand", "naturalKeywords", "logicalOp", 
                   "subroutine", "blockContentSubroutine", "subroutineStatement", 
                   "functionDefinition", "blockContent", "valueAssignment", 
                   "assignStatement", "addOperation", "multiplyOperation", 
                   "subtractOperation", "divideOperation", "computeOperation", 
                   "arithmaticOperation", "optionalCompute", "calculations", 
                   "addContent", "compOp", "arithmaticOp", "endStatement", 
                   "otherStatement" ]

    EOF = Token.EOF
    DEFINE=1
    FUNCTION=2
    RETURNS=3
    DATA=4
    LOCAL=5
    GLOBAL=6
    PARAMETER=7
    REDEFINE=8
    PERFORM=9
    CALLNAT=10
    ESCAPE=11
    ESCAPE_BOTTOM=12
    RETURN=13
    IF=14
    THEN=15
    ELSE=16
    ELSE_IF=17
    END_IF=18
    DECIDE=19
    END_DECIDE=20
    WHEN=21
    FOR=22
    THRU=23
    EVERY=24
    FIRST=25
    CONDITION=26
    ANY=27
    NONE=28
    ALL=29
    UNIQUE_LEX=30
    REPEAT=31
    LOOP=32
    END_FOR=33
    END=34
    READ=35
    FIND=36
    SELECT=37
    UPDATE=38
    STORE=39
    DELETE=40
    GET=41
    OBTAIN=42
    ADD=43
    SUBTRACT=44
    MULTIPLY=45
    DIVIDE=46
    MOVE=47
    VALUE_OF=48
    TO=49
    DO=50
    DEFINE_SUBROUTINE=51
    END_SUBROUTINE=52
    DEFINE_SUBPROGRAM=53
    END_SUBPROGRAM=54
    DEFINE_FUNCTION=55
    END_FUNCTION=56
    END_READ=57
    END_FIND=58
    END_SELECT=59
    END_TRANSACTION=60
    BACKOUT_TRANSACTION=61
    END_ALL=62
    VALUE=63
    DOEND=64
    USING_HELP=65
    USING=66
    COMPUTE=67
    INPUT=68
    MAP=69
    RESET=70
    SET_KEY=71
    COMPRESS=72
    NO_RECORDS_FOUND=73
    NO_RECORD_FOUND=74
    END_NOREC=75
    REINPUT=76
    MARK=77
    WITH_TEXT=78
    FULL=79
    POSITION=80
    IN=81
    ALARM=82
    RECORD=83
    RECORDS=84
    STATEMENT=85
    SET=86
    SAME=87
    GET_TRANSACTION_DATA=88
    GET_SAME=89
    WITH=90
    ACCEPT_IF=91
    REJECT_IF=92
    EXAMINE=93
    SUBSTRING=94
    REPLACE=95
    GIVING=96
    ABSOLUTE=97
    CHARPOSITION=98
    CHARLENGTH=99
    LENGTH=100
    NUMBER=101
    TRANSLATE=102
    DELIMITER=103
    UPPPER_CASE=104
    LOWER_CASE=105
    INTO=106
    INVERTED=107
    INDEX=108
    INDEXED=109
    PATTERN=110
    DISPLAY=111
    WRITE=112
    WRITE_TITLE=113
    WRITE_TRAILER=114
    FIELD=115
    BY_NAME=116
    BY_POSITION=117
    EDITED=118
    LEFT=119
    RIGHT=120
    JUSTIFIED=121
    NORMALIZED=122
    ENCODED=123
    ROUNDED=124
    SEPARATE=125
    SORT=126
    END_SORT=127
    FORMAT=128
    SKIP_LEX=129
    EJECT=130
    NEWPAGE=131
    SUSPEND_IDENTICAL_SUPPRESS=132
    DEFINE_PRINTER=133
    CLOSE_PRINTER=134
    DEFINE_WINDOW=135
    SET_WINDOW=136
    PROCESS_PAGE=137
    PROCESS_PAGE_USING=138
    PROCESS_PAGE_UPDATE=139
    PROCESS_PAGE_MODAL=140
    IF_SELECTION=141
    DECIDE_FOR=142
    DECIDE_ON=143
    CALL=144
    CALL_FILE=145
    CALL_LOOP=146
    FETCH=147
    PROCESS_COMMAND=148
    RUN=149
    DEFINE_PROTOTYPE=150
    FUNCTION_CALL=151
    STOP=152
    TERMINATE=153
    WRITE_WORK_FILE=154
    WRITE_WORK=155
    DOWNLOAD_PC_FILE=156
    READ_WORK_FILE=157
    READ_WORK=158
    UPLOAD_PC_FILE=159
    CLOSE_WORK_FILE=160
    CLOSE_WORK=161
    CLOSE_PC_FILE=162
    DEFINE_WORK_FILE=163
    DEFINE_CLASS=164
    CREATE_OBJECT=165
    SEND_METHOD=166
    INTERFACE=167
    METHOD=168
    PROPERTY=169
    EXPAND=170
    REDUCE=171
    RESIZE=172
    OPEN_CONVERSATION=173
    CLOSE_CONVERSATION=174
    DEFINE_DATA_CONTEXT=175
    PARSE=176
    REQUEST_DOCUMENT=177
    RETRY=178
    AT_START_OF_DATA=179
    AT_END_OF_DATA=180
    AT_BREAK=181
    BEFORE_BREAK_PROCESSING=182
    PERFORM_BREAK_PROCESSING=183
    CALLDBPROC=184
    COMMIT=185
    PROCESS_SQL=186
    READ_RESULT_SET=187
    ROLLBACK=188
    WRITE_PRINT=189
    AT_TOP_OF_PAGE=190
    AT_END_OF_PAGE=191
    DEFINE_DATA=192
    END_DEFINE=193
    INCLUDE=194
    ON_ERROR=195
    RELEASE=196
    SET_CONTROL=197
    SET_GLOBALS=198
    SET_TIME=199
    STACK=200
    ACCEPT=201
    REJECT=202
    PASSW=203
    LIMIT=204
    INSERT=205
    HISTOGRAM=206
    END_HISTOGRAM=207
    THEN_DO=208
    IGNORE=209
    FRAC=210
    FROM=211
    VIEW=212
    ASSIGN=213
    NUMERIC=214
    LEAVING_SPACE=215
    LEAVING_NO_SPACE=216
    END_START=217
    ON=218
    OFF=219
    BY=220
    INTERFACE4=221
    RETAIN_AS=222
    WHERE=223
    STARTING_WITH=224
    COUPLED=225
    VIA=226
    BUT=227
    SORTED=228
    ASCENDING=229
    DESCENDING=230
    OF=231
    MULTI_FETCH=232
    STARTING_FROM=233
    ENDING_AT=234
    VARIABLE=235
    DYNAMIC=236
    SEQUENCE=237
    END_WORK=238
    OFFSET=239
    FILLER=240
    ONCE=241
    AT_END_OF_FILE=242
    END_ENDFILE=243
    PASSWORD=244
    CIPHER=245
    FILE=246
    REPOSITION=247
    PHYSICAL=248
    STARTING=249
    ENDING=250
    AT=251
    AS=252
    GT_TEXT=253
    LT_TEXT=254
    GE_TEXT=255
    LE_TEXT=256
    EQ_TEXT=257
    NE_TEXT=258
    AND_TEXT=259
    OR_TEXT=260
    NOT_TEXT=261
    AND_EQ=262
    OR_RQ=263
    OR_SRQ=264
    EQUAL=265
    NOTEQUAL=266
    EQUAL_TO=267
    LESS_THAN=268
    GREATER_THAN=269
    LESS_EQUAL=270
    GREATER_EQUAL=271
    STRING=272
    COLON=273
    LINE_NUMBER=274
    FLOAT=275
    LITERAL=276
    LINE_REF=277
    INPUT_PARAM=278
    DATE_CONSTANT=279
    H_CONSTANT=280
    PLUS=281
    MINUS=282
    MULT=283
    DIV=284
    EQ=285
    GT=286
    LT=287
    GE=288
    LE=289
    NE=290
    LPAREN=291
    RPAREN=292
    IDENTIFIER=293
    TRAILING_COMMENT=294
    WS=295
    NL=296
    WS_C=297
    NL_C=298
    COMMA=299
    MOD=300
    AND=301
    OR=302
    XOR=303
    NOT=304
    TILDE=305
    QUESTION=306
    DOT=307
    LBRACK=308
    RBRACK=309
    LBRACE=310
    RBRACE=311
    LABEL=312

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def lineNumberStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LineNumberStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LineNumberStatementContext,i)


        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_program

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = NaturalParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 212
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 208
                    self.lineNumberStatement()
                    pass

                elif la_ == 2:
                    self.state = 209
                    self.statement()
                    pass

                elif la_ == 3:
                    self.state = 210
                    self.match(NaturalParser.WS)
                    pass

                elif la_ == 4:
                    self.state = 211
                    self.match(NaturalParser.NL)
                    pass


                self.state = 214 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LineNumberStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def statement(self):
            return self.getTypedRuleContext(NaturalParser.StatementContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_lineNumberStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLineNumberStatement" ):
                return visitor.visitLineNumberStatement(self)
            else:
                return visitor.visitChildren(self)




    def lineNumberStatement(self):

        localctx = NaturalParser.LineNumberStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_lineNumberStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(NaturalParser.LINE_NUMBER)
            self.state = 218
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                self.state = 217
                self.match(NaturalParser.WS)


            self.state = 220
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataDefinition(self):
            return self.getTypedRuleContext(NaturalParser.DataDefinitionContext,0)


        def subroutine(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(NaturalParser.FunctionDefinitionContext,0)


        def noRecordsFoundStatement(self):
            return self.getTypedRuleContext(NaturalParser.NoRecordsFoundStatementContext,0)


        def decisionStatement(self):
            return self.getTypedRuleContext(NaturalParser.DecisionStatementContext,0)


        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(NaturalParser.ForStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStatementContext,0)


        def performStatement(self):
            return self.getTypedRuleContext(NaturalParser.PerformStatementContext,0)


        def callnatStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallnatStatementContext,0)


        def examineStatement(self):
            return self.getTypedRuleContext(NaturalParser.ExamineStatementContext,0)


        def moveStatement(self):
            return self.getTypedRuleContext(NaturalParser.MoveStatementContext,0)


        def findStatement(self):
            return self.getTypedRuleContext(NaturalParser.FindStatementContext,0)


        def readStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadStatementContext,0)


        def storeStatement(self):
            return self.getTypedRuleContext(NaturalParser.StoreStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(NaturalParser.DeleteStatementContext,0)


        def getStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetStatementsContext,0)


        def histogramStatement(self):
            return self.getTypedRuleContext(NaturalParser.HistogramStatementContext,0)


        def endTransaction(self):
            return self.getTypedRuleContext(NaturalParser.EndTransactionContext,0)


        def backoutTransaction(self):
            return self.getTypedRuleContext(NaturalParser.BackoutTransactionContext,0)


        def readworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileStatementContext,0)


        def writeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.WriteworkfileStatementContext,0)


        def closeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.CloseworkfileStatementContext,0)


        def inputStatement(self):
            return self.getTypedRuleContext(NaturalParser.InputStatementContext,0)


        def reinputStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReinputStatementContext,0)


        def calculations(self):
            return self.getTypedRuleContext(NaturalParser.CalculationsContext,0)


        def assignStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignStatementContext,0)


        def setkeyStatement(self):
            return self.getTypedRuleContext(NaturalParser.SetkeyStatementContext,0)


        def redefineStatement(self):
            return self.getTypedRuleContext(NaturalParser.RedefineStatementContext,0)


        def resetStatement(self):
            return self.getTypedRuleContext(NaturalParser.ResetStatementContext,0)


        def sortStatement(self):
            return self.getTypedRuleContext(NaturalParser.SortStatementContext,0)


        def compressStatement(self):
            return self.getTypedRuleContext(NaturalParser.CompressStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def repeatStatement(self):
            return self.getTypedRuleContext(NaturalParser.RepeatStatementContext,0)


        def atStartOfDataStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtStartOfDataStatementContext,0)


        def formatStatement(self):
            return self.getTypedRuleContext(NaturalParser.FormatStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,0)


        def includeStatement(self):
            return self.getTypedRuleContext(NaturalParser.IncludeStatementContext,0)


        def fetchStatement(self):
            return self.getTypedRuleContext(NaturalParser.FetchStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallStatementContext,0)


        def otherStatement(self):
            return self.getTypedRuleContext(NaturalParser.OtherStatementContext,0)


        def label(self):
            return self.getTypedRuleContext(NaturalParser.LabelContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_statement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = NaturalParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 222
                self.label()


            self.state = 267
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 225
                self.dataDefinition()
                pass

            elif la_ == 2:
                self.state = 226
                self.subroutine()
                pass

            elif la_ == 3:
                self.state = 227
                self.functionDefinition()
                pass

            elif la_ == 4:
                self.state = 228
                self.noRecordsFoundStatement()
                pass

            elif la_ == 5:
                self.state = 229
                self.decisionStatement()
                pass

            elif la_ == 6:
                self.state = 230
                self.valueAssignment()
                pass

            elif la_ == 7:
                self.state = 231
                self.forStatement()
                pass

            elif la_ == 8:
                self.state = 232
                self.ifStatement()
                pass

            elif la_ == 9:
                self.state = 233
                self.performStatement()
                pass

            elif la_ == 10:
                self.state = 234
                self.callnatStatement()
                pass

            elif la_ == 11:
                self.state = 235
                self.examineStatement()
                pass

            elif la_ == 12:
                self.state = 236
                self.moveStatement()
                pass

            elif la_ == 13:
                self.state = 237
                self.findStatement()
                pass

            elif la_ == 14:
                self.state = 238
                self.readStatement()
                pass

            elif la_ == 15:
                self.state = 239
                self.storeStatement()
                pass

            elif la_ == 16:
                self.state = 240
                self.updateStatement()
                pass

            elif la_ == 17:
                self.state = 241
                self.deleteStatement()
                pass

            elif la_ == 18:
                self.state = 242
                self.getStatements()
                pass

            elif la_ == 19:
                self.state = 243
                self.histogramStatement()
                pass

            elif la_ == 20:
                self.state = 244
                self.endTransaction()
                pass

            elif la_ == 21:
                self.state = 245
                self.backoutTransaction()
                pass

            elif la_ == 22:
                self.state = 246
                self.readworkfileStatement()
                pass

            elif la_ == 23:
                self.state = 247
                self.writeworkfileStatement()
                pass

            elif la_ == 24:
                self.state = 248
                self.closeworkfileStatement()
                pass

            elif la_ == 25:
                self.state = 249
                self.inputStatement()
                pass

            elif la_ == 26:
                self.state = 250
                self.reinputStatement()
                pass

            elif la_ == 27:
                self.state = 251
                self.calculations()
                pass

            elif la_ == 28:
                self.state = 252
                self.assignStatement()
                pass

            elif la_ == 29:
                self.state = 253
                self.setkeyStatement()
                pass

            elif la_ == 30:
                self.state = 254
                self.redefineStatement()
                pass

            elif la_ == 31:
                self.state = 255
                self.resetStatement()
                pass

            elif la_ == 32:
                self.state = 256
                self.sortStatement()
                pass

            elif la_ == 33:
                self.state = 257
                self.compressStatement()
                pass

            elif la_ == 34:
                self.state = 258
                self.doStatement()
                pass

            elif la_ == 35:
                self.state = 259
                self.repeatStatement()
                pass

            elif la_ == 36:
                self.state = 260
                self.atStartOfDataStatement()
                pass

            elif la_ == 37:
                self.state = 261
                self.formatStatement()
                pass

            elif la_ == 38:
                self.state = 262
                self.assignmentStatement()
                pass

            elif la_ == 39:
                self.state = 263
                self.includeStatement()
                pass

            elif la_ == 40:
                self.state = 264
                self.fetchStatement()
                pass

            elif la_ == 41:
                self.state = 265
                self.callStatement()
                pass

            elif la_ == 42:
                self.state = 266
                self.otherStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LabelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LABEL(self):
            return self.getToken(NaturalParser.LABEL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_label

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLabel" ):
                return visitor.visitLabel(self)
            else:
                return visitor.visitChildren(self)




    def label(self):

        localctx = NaturalParser.LabelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 269
            self.match(NaturalParser.LABEL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DataDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFINE_DATA(self):
            return self.getToken(NaturalParser.DEFINE_DATA, 0)

        def END_DEFINE(self):
            return self.getToken(NaturalParser.END_DEFINE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_dataDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDataDefinition" ):
                return visitor.visitDataDefinition(self)
            else:
                return visitor.visitChildren(self)




    def dataDefinition(self):

        localctx = NaturalParser.DataDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_dataDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 271
            self.match(NaturalParser.DEFINE_DATA)
            self.state = 273 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 272
                    self.statement()

                else:
                    raise NoViableAltException(self)
                self.state = 275 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 277
            self.match(NaturalParser.END_DEFINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompressStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPRESS(self):
            return self.getToken(NaturalParser.COMPRESS, 0)

        def INTO(self):
            return self.getToken(NaturalParser.INTO, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def compressEnd(self):
            return self.getTypedRuleContext(NaturalParser.CompressEndContext,0)


        def NUMERIC(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NUMERIC)
            else:
                return self.getToken(NaturalParser.NUMERIC, i)

        def FULL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FULL)
            else:
                return self.getToken(NaturalParser.FULL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_compressStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompressStatement" ):
                return visitor.visitCompressStatement(self)
            else:
                return visitor.visitChildren(self)




    def compressStatement(self):

        localctx = NaturalParser.CompressStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_compressStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 279
            self.match(NaturalParser.COMPRESS)
            self.state = 283
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 280
                    _la = self._input.LA(1)
                    if not(_la==79 or _la==214 or _la==295):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 285
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 289 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 289
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [80, 272, 274, 275, 278, 279, 280, 291, 293]:
                    self.state = 286
                    self.operand()
                    pass
                elif token in [295]:
                    self.state = 287
                    self.match(NaturalParser.WS)
                    pass
                elif token in [296]:
                    self.state = 288
                    self.match(NaturalParser.NL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 291 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==80 or ((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & 27787725) != 0)):
                    break

            self.state = 293
            self.match(NaturalParser.INTO)
            self.state = 297
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 294
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 299
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 300
            self.operand()
            self.state = 308
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 304
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                    self.state = 301
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 306
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 307
                self.compressEnd()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompressEndContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEAVING_SPACE(self):
            return self.getToken(NaturalParser.LEAVING_SPACE, 0)

        def LEAVING_NO_SPACE(self):
            return self.getToken(NaturalParser.LEAVING_NO_SPACE, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def DELIMITER(self):
            return self.getToken(NaturalParser.DELIMITER, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_compressEnd

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompressEnd" ):
                return visitor.visitCompressEnd(self)
            else:
                return visitor.visitChildren(self)




    def compressEnd(self):

        localctx = NaturalParser.CompressEndContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_compressEnd)
        self._la = 0 # Token type
        try:
            self.state = 324
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [215]:
                self.enterOuterAlt(localctx, 1)
                self.state = 310
                self.match(NaturalParser.LEAVING_SPACE)
                pass
            elif token in [216]:
                self.enterOuterAlt(localctx, 2)
                self.state = 311
                self.match(NaturalParser.LEAVING_NO_SPACE)
                pass
            elif token in [90]:
                self.enterOuterAlt(localctx, 3)
                self.state = 312
                self.match(NaturalParser.WITH)
                self.state = 317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==29 or _la==295:
                    self.state = 314
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 313
                        self.match(NaturalParser.WS)


                    self.state = 316
                    self.match(NaturalParser.ALL)


                self.state = 319
                self.match(NaturalParser.DELIMITER)
                self.state = 321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 320
                    self.match(NaturalParser.WS)


                self.state = 323
                self.match(NaturalParser.STRING)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INPUT(self):
            return self.getToken(NaturalParser.INPUT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def inputUsingMap(self):
            return self.getTypedRuleContext(NaturalParser.InputUsingMapContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def inputOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.InputOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.InputOptionsContext,i)


        def DIV(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DIV)
            else:
                return self.getToken(NaturalParser.DIV, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputStatement" ):
                return visitor.visitInputStatement(self)
            else:
                return visitor.visitChildren(self)




    def inputStatement(self):

        localctx = NaturalParser.InputStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_inputStatement)
        try:
            self.state = 342
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 326
                self.match(NaturalParser.INPUT)
                self.state = 327
                self.match(NaturalParser.WS)
                self.state = 328
                self.inputUsingMap()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 329
                self.match(NaturalParser.INPUT)
                self.state = 337 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 337
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [272]:
                            self.state = 330
                            self.match(NaturalParser.STRING)
                            pass
                        elif token in [293]:
                            self.state = 331
                            self.variable()
                            pass
                        elif token in [77, 80, 81, 115]:
                            self.state = 332
                            self.inputOptions()
                            pass
                        elif token in [284]:
                            self.state = 333
                            self.match(NaturalParser.DIV)
                            pass
                        elif token in [295]:
                            self.state = 334
                            self.match(NaturalParser.WS)
                            pass
                        elif token in [274]:
                            self.state = 335
                            self.match(NaturalParser.LINE_NUMBER)
                            pass
                        elif token in [296]:
                            self.state = 336
                            self.match(NaturalParser.NL)
                            pass
                        else:
                            raise NoViableAltException(self)


                    else:
                        raise NoViableAltException(self)
                    self.state = 339 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

                self.state = 341
                self.match(NaturalParser.NL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MARK(self):
            return self.getToken(NaturalParser.MARK, 0)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def FIELD(self):
            return self.getToken(NaturalParser.FIELD, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputOptions" ):
                return visitor.visitInputOptions(self)
            else:
                return visitor.visitChildren(self)




    def inputOptions(self):

        localctx = NaturalParser.InputOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_inputOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 344
            _la = self._input.LA(1)
            if not(((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & 274877906969) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InputUsingMapContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(NaturalParser.MAP, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_inputUsingMap

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInputUsingMap" ):
                return visitor.visitInputUsingMap(self)
            else:
                return visitor.visitChildren(self)




    def inputUsingMap(self):

        localctx = NaturalParser.InputUsingMapContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_inputUsingMap)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 349
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 346
                    self.statement() 
                self.state = 351
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,19,self._ctx)

            self.state = 353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==66:
                self.state = 352
                self.match(NaturalParser.USING)


            self.state = 356
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 355
                self.match(NaturalParser.WS)


            self.state = 358
            self.match(NaturalParser.MAP)
            self.state = 360
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 359
                self.match(NaturalParser.WS)


            self.state = 362
            self.match(NaturalParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def DOT(self):
            return self.getToken(NaturalParser.DOT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_variable

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = NaturalParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variable)
        self._la = 0 # Token type
        try:
            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 364
                self.match(NaturalParser.IDENTIFIER)
                self.state = 369
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                if la_ == 1:
                    self.state = 366
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 365
                        self.match(NaturalParser.WS)


                    self.state = 368
                    _la = self._input.LA(1)
                    if not(_la==277 or _la==293):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 371
                self.match(NaturalParser.IDENTIFIER)
                self.state = 372
                self.match(NaturalParser.DOT)
                self.state = 373
                self.match(NaturalParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReinputStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REINPUT(self):
            return self.getToken(NaturalParser.REINPUT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def FULL(self):
            return self.getToken(NaturalParser.FULL, 0)

        def reinputOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.ReinputOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.ReinputOptionsContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def ALARM(self):
            return self.getToken(NaturalParser.ALARM, 0)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_reinputStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReinputStatement" ):
                return visitor.visitReinputStatement(self)
            else:
                return visitor.visitChildren(self)




    def reinputStatement(self):

        localctx = NaturalParser.ReinputStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_reinputStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(NaturalParser.REINPUT)
            self.state = 379
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 377
                self.match(NaturalParser.WS)
                self.state = 378
                self.match(NaturalParser.FULL)


            self.state = 390
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 388
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [65, 77, 78, 272, 274, 293]:
                        self.state = 383
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==274:
                            self.state = 381
                            self.match(NaturalParser.LINE_NUMBER)
                            self.state = 382
                            self.match(NaturalParser.WS)


                        self.state = 385
                        self.reinputOptions()
                        pass
                    elif token in [295]:
                        self.state = 386
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 387
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 392
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

            self.state = 395
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.state = 393
                self.match(NaturalParser.WS)
                self.state = 394
                self.match(NaturalParser.ALARM)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReinputOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MARK(self):
            return self.getToken(NaturalParser.MARK, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WITH_TEXT(self):
            return self.getToken(NaturalParser.WITH_TEXT, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def USING_HELP(self):
            return self.getToken(NaturalParser.USING_HELP, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_reinputOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReinputOptions" ):
                return visitor.visitReinputOptions(self)
            else:
                return visitor.visitChildren(self)




    def reinputOptions(self):

        localctx = NaturalParser.ReinputOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_reinputOptions)
        try:
            self.state = 411
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 397
                self.match(NaturalParser.MARK)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 398
                self.match(NaturalParser.IDENTIFIER)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 399
                self.match(NaturalParser.WITH_TEXT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 400
                self.match(NaturalParser.MARK)
                self.state = 401
                self.match(NaturalParser.WS)
                self.state = 402
                self.match(NaturalParser.POSITION)
                self.state = 403
                self.match(NaturalParser.WS)
                self.state = 404
                self.match(NaturalParser.LINE_NUMBER)
                self.state = 405
                self.match(NaturalParser.WS)
                self.state = 406
                self.match(NaturalParser.IN)
                self.state = 407
                self.match(NaturalParser.WS)
                self.state = 408
                self.match(NaturalParser.IDENTIFIER)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 409
                self.match(NaturalParser.USING_HELP)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 410
                self.match(NaturalParser.STRING)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SORT(self):
            return self.getToken(NaturalParser.SORT, 0)

        def END_SORT(self):
            return self.getToken(NaturalParser.END_SORT, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_sortStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSortStatement" ):
                return visitor.visitSortStatement(self)
            else:
                return visitor.visitChildren(self)




    def sortStatement(self):

        localctx = NaturalParser.SortStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_sortStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self.match(NaturalParser.SORT)
            self.state = 417
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,32,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 414
                    self.statement() 
                self.state = 419
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,32,self._ctx)

            self.state = 420
            self.match(NaturalParser.END_SORT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExamineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXAMINE(self):
            return self.getToken(NaturalParser.EXAMINE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def examineOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.ExamineOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.ExamineOptionsContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_examineStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExamineStatement" ):
                return visitor.visitExamineStatement(self)
            else:
                return visitor.visitChildren(self)




    def examineStatement(self):

        localctx = NaturalParser.ExamineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_examineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 422
            self.match(NaturalParser.EXAMINE)
            self.state = 423
            self.match(NaturalParser.WS)
            self.state = 430 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 430
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [293]:
                        self.state = 424
                        self.variable()
                        pass
                    elif token in [272]:
                        self.state = 425
                        self.match(NaturalParser.STRING)
                        pass
                    elif token in [22, 40, 48, 66, 79, 80, 81, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 110, 259]:
                        self.state = 426
                        self.examineOptions()
                        pass
                    elif token in [274]:
                        self.state = 427
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    elif token in [295]:
                        self.state = 428
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 429
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 432 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

            self.state = 434
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExamineOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def AND_TEXT(self):
            return self.getToken(NaturalParser.AND_TEXT, 0)

        def FULL(self):
            return self.getToken(NaturalParser.FULL, 0)

        def SUBSTRING(self):
            return self.getToken(NaturalParser.SUBSTRING, 0)

        def REPLACE(self):
            return self.getToken(NaturalParser.REPLACE, 0)

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def GIVING(self):
            return self.getToken(NaturalParser.GIVING, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def ABSOLUTE(self):
            return self.getToken(NaturalParser.ABSOLUTE, 0)

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def CHARPOSITION(self):
            return self.getToken(NaturalParser.CHARPOSITION, 0)

        def CHARLENGTH(self):
            return self.getToken(NaturalParser.CHARLENGTH, 0)

        def LENGTH(self):
            return self.getToken(NaturalParser.LENGTH, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def NUMBER(self):
            return self.getToken(NaturalParser.NUMBER, 0)

        def TRANSLATE(self):
            return self.getToken(NaturalParser.TRANSLATE, 0)

        def DELIMITER(self):
            return self.getToken(NaturalParser.DELIMITER, 0)

        def UPPPER_CASE(self):
            return self.getToken(NaturalParser.UPPPER_CASE, 0)

        def LOWER_CASE(self):
            return self.getToken(NaturalParser.LOWER_CASE, 0)

        def INTO(self):
            return self.getToken(NaturalParser.INTO, 0)

        def INVERTED(self):
            return self.getToken(NaturalParser.INVERTED, 0)

        def INDEX(self):
            return self.getToken(NaturalParser.INDEX, 0)

        def PATTERN(self):
            return self.getToken(NaturalParser.PATTERN, 0)

        def VALUE_OF(self):
            return self.getToken(NaturalParser.VALUE_OF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_examineOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExamineOptions" ):
                return visitor.visitExamineOptions(self)
            else:
                return visitor.visitChildren(self)




    def examineOptions(self):

        localctx = NaturalParser.ExamineOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_examineOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 436
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 282574492532736) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 26388027465729) != 0) or _la==259):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MOVE(self):
            return self.getToken(NaturalParser.MOVE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def moveOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.MoveOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.MoveOptionsContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_moveStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMoveStatement" ):
                return visitor.visitMoveStatement(self)
            else:
                return visitor.visitChildren(self)




    def moveStatement(self):

        localctx = NaturalParser.MoveStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_moveStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(NaturalParser.MOVE)
            self.state = 440
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.state = 439
                self.match(NaturalParser.WS)


            self.state = 445 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 445
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [29, 80, 94, 109, 116, 117, 118, 119, 120, 121, 122, 123, 124, 272, 274, 275, 278, 279, 280, 287, 291, 293]:
                        self.state = 442
                        self.moveOptions()
                        pass
                    elif token in [295]:
                        self.state = 443
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 444
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 447 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,37,self._ctx)

            self.state = 450
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==49:
                self.state = 449
                self.match(NaturalParser.TO)


            self.state = 455 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 455
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [29, 80, 94, 109, 116, 117, 118, 119, 120, 121, 122, 123, 124, 272, 274, 275, 278, 279, 280, 287, 291, 293]:
                        self.state = 452
                        self.moveOptions()
                        pass
                    elif token in [295]:
                        self.state = 453
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 454
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 457 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MoveOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def LT(self):
            return self.getToken(NaturalParser.LT, 0)

        def GT(self):
            return self.getToken(NaturalParser.GT, 0)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def SUBSTRING(self):
            return self.getToken(NaturalParser.SUBSTRING, 0)

        def BY_NAME(self):
            return self.getToken(NaturalParser.BY_NAME, 0)

        def BY_POSITION(self):
            return self.getToken(NaturalParser.BY_POSITION, 0)

        def EDITED(self):
            return self.getToken(NaturalParser.EDITED, 0)

        def LEFT(self):
            return self.getToken(NaturalParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(NaturalParser.RIGHT, 0)

        def JUSTIFIED(self):
            return self.getToken(NaturalParser.JUSTIFIED, 0)

        def NORMALIZED(self):
            return self.getToken(NaturalParser.NORMALIZED, 0)

        def ENCODED(self):
            return self.getToken(NaturalParser.ENCODED, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def INDEXED(self):
            return self.getToken(NaturalParser.INDEXED, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_moveOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMoveOptions" ):
                return visitor.visitMoveOptions(self)
            else:
                return visitor.visitChildren(self)




    def moveOptions(self):

        localctx = NaturalParser.MoveOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_moveOptions)
        try:
            self.state = 476
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [80, 272, 274, 275, 278, 279, 280, 291, 293]:
                self.enterOuterAlt(localctx, 1)
                self.state = 459
                self.operand()
                pass
            elif token in [287]:
                self.enterOuterAlt(localctx, 2)
                self.state = 460
                self.match(NaturalParser.LT)
                self.state = 461
                self.operand()
                self.state = 462
                self.match(NaturalParser.GT)
                pass
            elif token in [124]:
                self.enterOuterAlt(localctx, 3)
                self.state = 464
                self.match(NaturalParser.ROUNDED)
                pass
            elif token in [94]:
                self.enterOuterAlt(localctx, 4)
                self.state = 465
                self.match(NaturalParser.SUBSTRING)
                pass
            elif token in [116]:
                self.enterOuterAlt(localctx, 5)
                self.state = 466
                self.match(NaturalParser.BY_NAME)
                pass
            elif token in [117]:
                self.enterOuterAlt(localctx, 6)
                self.state = 467
                self.match(NaturalParser.BY_POSITION)
                pass
            elif token in [118]:
                self.enterOuterAlt(localctx, 7)
                self.state = 468
                self.match(NaturalParser.EDITED)
                pass
            elif token in [119]:
                self.enterOuterAlt(localctx, 8)
                self.state = 469
                self.match(NaturalParser.LEFT)
                pass
            elif token in [120]:
                self.enterOuterAlt(localctx, 9)
                self.state = 470
                self.match(NaturalParser.RIGHT)
                pass
            elif token in [121]:
                self.enterOuterAlt(localctx, 10)
                self.state = 471
                self.match(NaturalParser.JUSTIFIED)
                pass
            elif token in [122]:
                self.enterOuterAlt(localctx, 11)
                self.state = 472
                self.match(NaturalParser.NORMALIZED)
                pass
            elif token in [123]:
                self.enterOuterAlt(localctx, 12)
                self.state = 473
                self.match(NaturalParser.ENCODED)
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 13)
                self.state = 474
                self.match(NaturalParser.ALL)
                pass
            elif token in [109]:
                self.enterOuterAlt(localctx, 14)
                self.state = 475
                self.match(NaturalParser.INDEXED)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RepeatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_repeatStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRepeatStatement" ):
                return visitor.visitRepeatStatement(self)
            else:
                return visitor.visitChildren(self)




    def repeatStatement(self):

        localctx = NaturalParser.RepeatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_repeatStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 478
            self.match(NaturalParser.REPEAT)
            self.state = 482
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0):
                self.state = 479
                self.statement()
                self.state = 484
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 485
            self.match(NaturalParser.LOOP)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DoStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_doStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDoStatement" ):
                return visitor.visitDoStatement(self)
            else:
                return visitor.visitChildren(self)




    def doStatement(self):

        localctx = NaturalParser.DoStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_doStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.match(NaturalParser.DO)
            self.state = 491
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0):
                self.state = 488
                self.statement()
                self.state = 493
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 494
            self.match(NaturalParser.DOEND)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token

        def STORE(self):
            return self.getToken(NaturalParser.STORE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def FILE(self):
            return self.getToken(NaturalParser.FILE, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def SET(self):
            return self.getToken(NaturalParser.SET, 0)

        def storePreview2(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StorePreview2Context)
            else:
                return self.getTypedRuleContext(NaturalParser.StorePreview2Context,i)


        def storeCondition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StoreConditionContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StoreConditionContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_storeStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStoreStatement" ):
                return visitor.visitStoreStatement(self)
            else:
                return visitor.visitChildren(self)




    def storeStatement(self):

        localctx = NaturalParser.StoreStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_storeStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 496
            self.match(NaturalParser.STORE)
            self.state = 498
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.state = 497
                self.match(NaturalParser.WS)


            self.state = 501
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==83:
                self.state = 500
                self.match(NaturalParser.RECORD)


            self.state = 504
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,46,self._ctx)
            if la_ == 1:
                self.state = 503
                self.match(NaturalParser.WS)


            self.state = 507
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 506
                self.match(NaturalParser.IN)


            self.state = 510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 509
                self.match(NaturalParser.WS)


            self.state = 513
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==246:
                self.state = 512
                self.match(NaturalParser.FILE)


            self.state = 516
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 515
                self.match(NaturalParser.WS)


            self.state = 518
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,51,self._ctx)
            if la_ == 1:
                self.state = 519
                self.match(NaturalParser.WS)


            self.state = 523
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.state = 522
                self.match(NaturalParser.NL)


            self.state = 526
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.state = 525
                self.match(NaturalParser.WITH)


            self.state = 529
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.state = 528
                self.match(NaturalParser.SET)


            self.state = 532
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                self.state = 531
                self.match(NaturalParser.WS)


            self.state = 535
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,56,self._ctx)
            if la_ == 1:
                self.state = 534
                self.match(NaturalParser.NL)


            self.state = 540
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,57,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 537
                    self.storePreview2() 
                self.state = 542
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,57,self._ctx)

            self.state = 544
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 543
                self.match(NaturalParser.WS)


            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 546
                self.match(NaturalParser.NL)


            self.state = 552
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,60,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 549
                    self.storeCondition() 
                self.state = 554
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,60,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StorePreview2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASSWORD(self):
            return self.getToken(NaturalParser.PASSWORD, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def CIPHER(self):
            return self.getToken(NaturalParser.CIPHER, 0)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def GIVING(self):
            return self.getToken(NaturalParser.GIVING, 0)

        def NUMBER(self):
            return self.getToken(NaturalParser.NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_storePreview2

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStorePreview2" ):
                return visitor.visitStorePreview2(self)
            else:
                return visitor.visitChildren(self)




    def storePreview2(self):

        localctx = NaturalParser.StorePreview2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_storePreview2)
        self._la = 0 # Token type
        try:
            self.state = 589
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [244]:
                self.enterOuterAlt(localctx, 1)
                self.state = 555
                self.match(NaturalParser.PASSWORD)
                self.state = 556
                self.match(NaturalParser.WS)
                self.state = 558
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==273:
                    self.state = 557
                    self.match(NaturalParser.COLON)


                self.state = 560
                self.match(NaturalParser.EQ)
                self.state = 562
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 561
                    self.match(NaturalParser.WS)


                self.state = 565
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,63,self._ctx)
                if la_ == 1:
                    self.state = 564
                    self.operand()


                pass
            elif token in [245]:
                self.enterOuterAlt(localctx, 2)
                self.state = 567
                self.match(NaturalParser.CIPHER)
                self.state = 568
                self.match(NaturalParser.WS)
                self.state = 570
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==273:
                    self.state = 569
                    self.match(NaturalParser.COLON)


                self.state = 572
                self.match(NaturalParser.EQ)
                self.state = 574
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 573
                    self.match(NaturalParser.WS)


                self.state = 577
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
                if la_ == 1:
                    self.state = 576
                    self.operand()


                pass
            elif token in [66, 96]:
                self.enterOuterAlt(localctx, 3)
                self.state = 579
                _la = self._input.LA(1)
                if not(_la==66 or _la==96):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 581
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
                if la_ == 1:
                    self.state = 580
                    self.match(NaturalParser.WS)


                self.state = 584
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,68,self._ctx)
                if la_ == 1:
                    self.state = 583
                    self.match(NaturalParser.NUMBER)


                self.state = 587
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
                if la_ == 1:
                    self.state = 586
                    self.operand()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StoreConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.EQ)
            else:
                return self.getToken(NaturalParser.EQ, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COLON)
            else:
                return self.getToken(NaturalParser.COLON, i)

        def PLUS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PLUS)
            else:
                return self.getToken(NaturalParser.PLUS, i)

        def MINUS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.MINUS)
            else:
                return self.getToken(NaturalParser.MINUS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_storeCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStoreCondition" ):
                return visitor.visitStoreCondition(self)
            else:
                return visitor.visitChildren(self)




    def storeCondition(self):

        localctx = NaturalParser.StoreConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_storeCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
            if la_ == 1:
                self.state = 591
                self.match(NaturalParser.LINE_NUMBER)


            self.state = 597
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,72,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 594
                    self.match(NaturalParser.WS) 
                self.state = 599
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,72,self._ctx)

            self.state = 650
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==80 or ((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & 2621901) != 0):
                self.state = 600
                self.operand()
                self.state = 602
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 601
                    self.match(NaturalParser.WS)


                self.state = 605
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 604
                    self.match(NaturalParser.NL)


                self.state = 608
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
                if la_ == 1:
                    self.state = 607
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 611
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==273:
                    self.state = 610
                    self.match(NaturalParser.COLON)


                self.state = 614
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==296:
                    self.state = 613
                    self.match(NaturalParser.NL)


                self.state = 617
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 616
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 620
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 619
                    self.match(NaturalParser.WS)


                self.state = 622
                self.match(NaturalParser.EQ)
                self.state = 624
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
                if la_ == 1:
                    self.state = 623
                    self.match(NaturalParser.WS)


                self.state = 627
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==296:
                    self.state = 626
                    self.match(NaturalParser.NL)


                self.state = 630
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                if la_ == 1:
                    self.state = 629
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 635
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,83,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 632
                        self.match(NaturalParser.WS) 
                    self.state = 637
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,83,self._ctx)

                self.state = 639
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==281 or _la==282:
                    self.state = 638
                    _la = self._input.LA(1)
                    if not(_la==281 or _la==282):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 641
                self.operand()
                self.state = 643
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
                if la_ == 1:
                    self.state = 642
                    self.match(NaturalParser.WS)


                self.state = 646
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,86,self._ctx)
                if la_ == 1:
                    self.state = 645
                    self.match(NaturalParser.NL)


                self.state = 652
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==295:
                self.state = 653
                self.match(NaturalParser.WS)
                self.state = 658
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 659
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.endBlock = None # Token

        def findQuery(self):
            return self.getTypedRuleContext(NaturalParser.FindQueryContext,0)


        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_FIND(self):
            return self.getToken(NaturalParser.END_FIND, 0)

        def findNumber(self):
            return self.getTypedRuleContext(NaturalParser.FindNumberContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_findStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindStatement" ):
                return visitor.visitFindStatement(self)
            else:
                return visitor.visitChildren(self)




    def findStatement(self):

        localctx = NaturalParser.FindStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_findStatement)
        self._la = 0 # Token type
        try:
            self.state = 666
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 661
                self.findQuery()
                self.state = 662
                self.blockContent()
                self.state = 663
                localctx.endBlock = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==32 or _la==58):
                    localctx.endBlock = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 665
                self.findNumber()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token

        def FIND(self):
            return self.getToken(NaturalParser.FIND, 0)

        def findPreview2(self):
            return self.getTypedRuleContext(NaturalParser.FindPreview2Context,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def findPreview1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.FindPreview1Context)
            else:
                return self.getTypedRuleContext(NaturalParser.FindPreview1Context,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_findQuery

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindQuery" ):
                return visitor.visitFindQuery(self)
            else:
                return visitor.visitChildren(self)




    def findQuery(self):

        localctx = NaturalParser.FindQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_findQuery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 668
            self.match(NaturalParser.FIND)
            self.state = 675
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,91,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 673
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [25, 29, 30, 81, 83, 84, 232, 246, 277, 293]:
                        self.state = 669
                        self.findPreview1()
                        pass
                    elif token in [295]:
                        self.state = 670
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 671
                        self.match(NaturalParser.NL)
                        pass
                    elif token in [274]:
                        self.state = 672
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 677
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,91,self._ctx)

            self.state = 678
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 680
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,92,self._ctx)
            if la_ == 1:
                self.state = 679
                self.match(NaturalParser.WS)


            self.state = 682
            self.findPreview2()
            self.state = 683
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindNumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token

        def FIND(self):
            return self.getToken(NaturalParser.FIND, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NUMBER(self):
            return self.getToken(NaturalParser.NUMBER, 0)

        def findPreview2(self):
            return self.getTypedRuleContext(NaturalParser.FindPreview2Context,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def findPreview1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.FindPreview1Context)
            else:
                return self.getTypedRuleContext(NaturalParser.FindPreview1Context,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_findNumber

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindNumber" ):
                return visitor.visitFindNumber(self)
            else:
                return visitor.visitChildren(self)




    def findNumber(self):

        localctx = NaturalParser.FindNumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_findNumber)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(NaturalParser.FIND)
            self.state = 686
            self.match(NaturalParser.WS)
            self.state = 687
            self.match(NaturalParser.NUMBER)
            self.state = 694
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,94,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 692
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [25, 29, 30, 81, 83, 84, 232, 246, 277, 293]:
                        self.state = 688
                        self.findPreview1()
                        pass
                    elif token in [295]:
                        self.state = 689
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 690
                        self.match(NaturalParser.NL)
                        pass
                    elif token in [274]:
                        self.state = 691
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 696
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

            self.state = 697
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 699
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                self.state = 698
                self.match(NaturalParser.WS)


            self.state = 701
            self.findPreview2()
            self.state = 702
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindPreview1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST(self):
            return self.getToken(NaturalParser.FIRST, 0)

        def UNIQUE_LEX(self):
            return self.getToken(NaturalParser.UNIQUE_LEX, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def MULTI_FETCH(self):
            return self.getToken(NaturalParser.MULTI_FETCH, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def OF(self):
            return self.getToken(NaturalParser.OF, 0)

        def ON(self):
            return self.getToken(NaturalParser.ON, 0)

        def OFF(self):
            return self.getToken(NaturalParser.OFF, 0)

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORD)
            else:
                return self.getToken(NaturalParser.RECORD, i)

        def RECORDS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORDS)
            else:
                return self.getToken(NaturalParser.RECORDS, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def FILE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FILE)
            else:
                return self.getToken(NaturalParser.FILE, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_findPreview1

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindPreview1" ):
                return visitor.visitFindPreview1(self)
            else:
                return visitor.visitChildren(self)




    def findPreview1(self):

        localctx = NaturalParser.FindPreview1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_findPreview1)
        self._la = 0 # Token type
        try:
            self.state = 724
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25, 29, 30, 277, 293]:
                self.enterOuterAlt(localctx, 1)
                self.state = 710
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,96,self._ctx)
                if la_ == 1:
                    self.state = 704
                    self.match(NaturalParser.FIRST)
                    pass

                elif la_ == 2:
                    self.state = 705
                    self.match(NaturalParser.UNIQUE_LEX)
                    pass

                elif la_ == 3:
                    self.state = 706
                    self.match(NaturalParser.ALL)
                    pass

                elif la_ == 4:
                    self.state = 707
                    self.match(NaturalParser.IDENTIFIER)
                    pass

                elif la_ == 5:
                    self.state = 708
                    self.match(NaturalParser.LINE_REF)
                    pass

                elif la_ == 6:
                    self.state = 709
                    self.variable()
                    pass


                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 2)
                self.state = 712
                self.match(NaturalParser.MULTI_FETCH)
                self.state = 715
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 713
                    self.match(NaturalParser.WS)
                    self.state = 714
                    _la = self._input.LA(1)
                    if not(((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 8195) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 717
                self.match(NaturalParser.WS)
                self.state = 718
                self.match(NaturalParser.LINE_NUMBER)
                pass
            elif token in [81, 83, 84, 246]:
                self.enterOuterAlt(localctx, 3)
                self.state = 720 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 719
                        _la = self._input.LA(1)
                        if not(((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 13) != 0) or _la==246):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 722 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,98,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FindPreview2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def PASSWORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PASSWORD)
            else:
                return self.getToken(NaturalParser.PASSWORD, i)

        def CIPHER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.CIPHER)
            else:
                return self.getToken(NaturalParser.CIPHER, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WITH)
            else:
                return self.getToken(NaturalParser.WITH, i)

        def LIMIT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LIMIT)
            else:
                return self.getToken(NaturalParser.LIMIT, i)

        def COUPLED(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COUPLED)
            else:
                return self.getToken(NaturalParser.COUPLED, i)

        def STARTING_WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_WITH)
            else:
                return self.getToken(NaturalParser.STARTING_WITH, i)

        def SORTED(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SORTED)
            else:
                return self.getToken(NaturalParser.SORTED, i)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY)
            else:
                return self.getToken(NaturalParser.BY, i)

        def RETAIN_AS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RETAIN_AS)
            else:
                return self.getToken(NaturalParser.RETAIN_AS, i)

        def WHERE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WHERE)
            else:
                return self.getToken(NaturalParser.WHERE, i)

        def VIA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VIA)
            else:
                return self.getToken(NaturalParser.VIA, i)

        def THRU(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THRU)
            else:
                return self.getToken(NaturalParser.THRU, i)

        def DESCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DESCENDING)
            else:
                return self.getToken(NaturalParser.DESCENDING, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AND)
            else:
                return self.getToken(NaturalParser.AND, i)

        def TO(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.TO)
            else:
                return self.getToken(NaturalParser.TO, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FROM)
            else:
                return self.getToken(NaturalParser.FROM, i)

        def BY_NAME(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_NAME)
            else:
                return self.getToken(NaturalParser.BY_NAME, i)

        def BY_POSITION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_POSITION)
            else:
                return self.getToken(NaturalParser.BY_POSITION, i)

        def BUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BUT)
            else:
                return self.getToken(NaturalParser.BUT, i)

        def compOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CompOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CompOpContext,i)


        def logicalOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LogicalOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LogicalOpContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_findPreview2

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFindPreview2" ):
                return visitor.visitFindPreview2(self)
            else:
                return visitor.visitChildren(self)




    def findPreview2(self):

        localctx = NaturalParser.FindPreview2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_findPreview2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,101,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 751
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
                    if la_ == 1:
                        self.state = 726
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 727
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 728
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 4:
                        self.state = 729
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 5:
                        self.state = 730
                        self.match(NaturalParser.PASSWORD)
                        pass

                    elif la_ == 6:
                        self.state = 731
                        self.match(NaturalParser.CIPHER)
                        pass

                    elif la_ == 7:
                        self.state = 732
                        self.match(NaturalParser.WITH)
                        pass

                    elif la_ == 8:
                        self.state = 733
                        self.match(NaturalParser.LIMIT)
                        pass

                    elif la_ == 9:
                        self.state = 734
                        self.match(NaturalParser.COUPLED)
                        pass

                    elif la_ == 10:
                        self.state = 735
                        self.match(NaturalParser.STARTING_WITH)
                        pass

                    elif la_ == 11:
                        self.state = 736
                        self.match(NaturalParser.SORTED)
                        pass

                    elif la_ == 12:
                        self.state = 737
                        self.match(NaturalParser.BY)
                        pass

                    elif la_ == 13:
                        self.state = 738
                        self.match(NaturalParser.RETAIN_AS)
                        pass

                    elif la_ == 14:
                        self.state = 739
                        self.match(NaturalParser.WHERE)
                        pass

                    elif la_ == 15:
                        self.state = 740
                        self.match(NaturalParser.VIA)
                        pass

                    elif la_ == 16:
                        self.state = 741
                        self.match(NaturalParser.THRU)
                        pass

                    elif la_ == 17:
                        self.state = 742
                        self.match(NaturalParser.DESCENDING)
                        pass

                    elif la_ == 18:
                        self.state = 743
                        self.match(NaturalParser.AND)
                        pass

                    elif la_ == 19:
                        self.state = 744
                        self.match(NaturalParser.TO)
                        pass

                    elif la_ == 20:
                        self.state = 745
                        self.match(NaturalParser.FROM)
                        pass

                    elif la_ == 21:
                        self.state = 746
                        self.match(NaturalParser.BY_NAME)
                        pass

                    elif la_ == 22:
                        self.state = 747
                        self.match(NaturalParser.BY_POSITION)
                        pass

                    elif la_ == 23:
                        self.state = 748
                        self.match(NaturalParser.BUT)
                        pass

                    elif la_ == 24:
                        self.state = 749
                        self.compOp()
                        pass

                    elif la_ == 25:
                        self.state = 750
                        self.logicalOp()
                        pass

             
                self.state = 755
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,101,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.endBlock = None # Token

        def readQuery(self):
            return self.getTypedRuleContext(NaturalParser.ReadQueryContext,0)


        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_READ(self):
            return self.getToken(NaturalParser.END_READ, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_readStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadStatement" ):
                return visitor.visitReadStatement(self)
            else:
                return visitor.visitChildren(self)




    def readStatement(self):

        localctx = NaturalParser.ReadStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_readStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 756
            self.readQuery()
            self.state = 757
            self.blockContent()
            self.state = 758
            localctx.endBlock = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==32 or _la==57):
                localctx.endBlock = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token

        def READ(self):
            return self.getToken(NaturalParser.READ, 0)

        def readPreview2(self):
            return self.getTypedRuleContext(NaturalParser.ReadPreview2Context,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def readPreview1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.ReadPreview1Context)
            else:
                return self.getTypedRuleContext(NaturalParser.ReadPreview1Context,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_readQuery

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadQuery" ):
                return visitor.visitReadQuery(self)
            else:
                return visitor.visitChildren(self)




    def readQuery(self):

        localctx = NaturalParser.ReadQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_readQuery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 760
            self.match(NaturalParser.READ)
            self.state = 767
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,103,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 765
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [29, 81, 83, 84, 232, 246, 277, 293]:
                        self.state = 761
                        self.readPreview1()
                        pass
                    elif token in [295]:
                        self.state = 762
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 763
                        self.match(NaturalParser.NL)
                        pass
                    elif token in [274]:
                        self.state = 764
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 769
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,103,self._ctx)

            self.state = 770
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 772
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.state = 771
                self.match(NaturalParser.WS)


            self.state = 774
            self.readPreview2()
            self.state = 775
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadPreview1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def MULTI_FETCH(self):
            return self.getToken(NaturalParser.MULTI_FETCH, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def OF(self):
            return self.getToken(NaturalParser.OF, 0)

        def ON(self):
            return self.getToken(NaturalParser.ON, 0)

        def OFF(self):
            return self.getToken(NaturalParser.OFF, 0)

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORD)
            else:
                return self.getToken(NaturalParser.RECORD, i)

        def RECORDS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORDS)
            else:
                return self.getToken(NaturalParser.RECORDS, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def FILE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FILE)
            else:
                return self.getToken(NaturalParser.FILE, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_readPreview1

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadPreview1" ):
                return visitor.visitReadPreview1(self)
            else:
                return visitor.visitChildren(self)




    def readPreview1(self):

        localctx = NaturalParser.ReadPreview1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_readPreview1)
        self._la = 0 # Token type
        try:
            self.state = 795
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [29, 277, 293]:
                self.enterOuterAlt(localctx, 1)
                self.state = 781
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
                if la_ == 1:
                    self.state = 777
                    self.match(NaturalParser.ALL)
                    pass

                elif la_ == 2:
                    self.state = 778
                    self.match(NaturalParser.IDENTIFIER)
                    pass

                elif la_ == 3:
                    self.state = 779
                    self.match(NaturalParser.LINE_REF)
                    pass

                elif la_ == 4:
                    self.state = 780
                    self.variable()
                    pass


                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 2)
                self.state = 783
                self.match(NaturalParser.MULTI_FETCH)
                self.state = 786
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
                if la_ == 1:
                    self.state = 784
                    self.match(NaturalParser.WS)
                    self.state = 785
                    _la = self._input.LA(1)
                    if not(((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 8195) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 788
                self.match(NaturalParser.WS)
                self.state = 789
                self.match(NaturalParser.LINE_NUMBER)
                pass
            elif token in [81, 83, 84, 246]:
                self.enterOuterAlt(localctx, 3)
                self.state = 791 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 790
                        _la = self._input.LA(1)
                        if not(((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 13) != 0) or _la==246):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 793 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,107,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadPreview2Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def PASSWORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PASSWORD)
            else:
                return self.getToken(NaturalParser.PASSWORD, i)

        def CIPHER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.CIPHER)
            else:
                return self.getToken(NaturalParser.CIPHER, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WITH)
            else:
                return self.getToken(NaturalParser.WITH, i)

        def REPOSITION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.REPOSITION)
            else:
                return self.getToken(NaturalParser.REPOSITION, i)

        def STARTING_WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_WITH)
            else:
                return self.getToken(NaturalParser.STARTING_WITH, i)

        def WHERE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WHERE)
            else:
                return self.getToken(NaturalParser.WHERE, i)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY)
            else:
                return self.getToken(NaturalParser.BY, i)

        def STARTING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING)
            else:
                return self.getToken(NaturalParser.STARTING, i)

        def ENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ENDING)
            else:
                return self.getToken(NaturalParser.ENDING, i)

        def AT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AT)
            else:
                return self.getToken(NaturalParser.AT, i)

        def THRU(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THRU)
            else:
                return self.getToken(NaturalParser.THRU, i)

        def DESCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DESCENDING)
            else:
                return self.getToken(NaturalParser.DESCENDING, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AND)
            else:
                return self.getToken(NaturalParser.AND, i)

        def TO(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.TO)
            else:
                return self.getToken(NaturalParser.TO, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FROM)
            else:
                return self.getToken(NaturalParser.FROM, i)

        def BY_NAME(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_NAME)
            else:
                return self.getToken(NaturalParser.BY_NAME, i)

        def BY_POSITION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BY_POSITION)
            else:
                return self.getToken(NaturalParser.BY_POSITION, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def PHYSICAL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PHYSICAL)
            else:
                return self.getToken(NaturalParser.PHYSICAL, i)

        def ASCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ASCENDING)
            else:
                return self.getToken(NaturalParser.ASCENDING, i)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VARIABLE)
            else:
                return self.getToken(NaturalParser.VARIABLE, i)

        def DYNAMIC(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DYNAMIC)
            else:
                return self.getToken(NaturalParser.DYNAMIC, i)

        def SEQUENCE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SEQUENCE)
            else:
                return self.getToken(NaturalParser.SEQUENCE, i)

        def STARTING_FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_FROM)
            else:
                return self.getToken(NaturalParser.STARTING_FROM, i)

        def ENDING_AT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ENDING_AT)
            else:
                return self.getToken(NaturalParser.ENDING_AT, i)

        def BUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.BUT)
            else:
                return self.getToken(NaturalParser.BUT, i)

        def compOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CompOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CompOpContext,i)


        def logicalOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LogicalOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LogicalOpContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_readPreview2

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadPreview2" ):
                return visitor.visitReadPreview2(self)
            else:
                return visitor.visitChildren(self)




    def readPreview2(self):

        localctx = NaturalParser.ReadPreview2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_readPreview2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 831
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,110,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 829
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                    if la_ == 1:
                        self.state = 797
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 798
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 799
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 4:
                        self.state = 800
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 5:
                        self.state = 801
                        self.match(NaturalParser.PASSWORD)
                        pass

                    elif la_ == 6:
                        self.state = 802
                        self.match(NaturalParser.CIPHER)
                        pass

                    elif la_ == 7:
                        self.state = 803
                        self.match(NaturalParser.WITH)
                        pass

                    elif la_ == 8:
                        self.state = 804
                        self.match(NaturalParser.REPOSITION)
                        pass

                    elif la_ == 9:
                        self.state = 805
                        self.match(NaturalParser.STARTING_WITH)
                        pass

                    elif la_ == 10:
                        self.state = 806
                        self.match(NaturalParser.WHERE)
                        pass

                    elif la_ == 11:
                        self.state = 807
                        self.match(NaturalParser.BY)
                        pass

                    elif la_ == 12:
                        self.state = 808
                        self.match(NaturalParser.STARTING)
                        pass

                    elif la_ == 13:
                        self.state = 809
                        self.match(NaturalParser.ENDING)
                        pass

                    elif la_ == 14:
                        self.state = 810
                        self.match(NaturalParser.AT)
                        pass

                    elif la_ == 15:
                        self.state = 811
                        self.match(NaturalParser.THRU)
                        pass

                    elif la_ == 16:
                        self.state = 812
                        self.match(NaturalParser.DESCENDING)
                        pass

                    elif la_ == 17:
                        self.state = 813
                        self.match(NaturalParser.AND)
                        pass

                    elif la_ == 18:
                        self.state = 814
                        self.match(NaturalParser.TO)
                        pass

                    elif la_ == 19:
                        self.state = 815
                        self.match(NaturalParser.FROM)
                        pass

                    elif la_ == 20:
                        self.state = 816
                        self.match(NaturalParser.BY_NAME)
                        pass

                    elif la_ == 21:
                        self.state = 817
                        self.match(NaturalParser.BY_POSITION)
                        pass

                    elif la_ == 22:
                        self.state = 818
                        self.match(NaturalParser.IN)
                        pass

                    elif la_ == 23:
                        self.state = 819
                        self.match(NaturalParser.PHYSICAL)
                        pass

                    elif la_ == 24:
                        self.state = 820
                        self.match(NaturalParser.ASCENDING)
                        pass

                    elif la_ == 25:
                        self.state = 821
                        self.match(NaturalParser.VARIABLE)
                        pass

                    elif la_ == 26:
                        self.state = 822
                        self.match(NaturalParser.DYNAMIC)
                        pass

                    elif la_ == 27:
                        self.state = 823
                        self.match(NaturalParser.SEQUENCE)
                        pass

                    elif la_ == 28:
                        self.state = 824
                        self.match(NaturalParser.STARTING_FROM)
                        pass

                    elif la_ == 29:
                        self.state = 825
                        self.match(NaturalParser.ENDING_AT)
                        pass

                    elif la_ == 30:
                        self.state = 826
                        self.match(NaturalParser.BUT)
                        pass

                    elif la_ == 31:
                        self.state = 827
                        self.compOp()
                        pass

                    elif la_ == 32:
                        self.state = 828
                        self.logicalOp()
                        pass

             
                self.state = 833
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def updateStartline(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStartlineContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.EQ)
            else:
                return self.getToken(NaturalParser.EQ, i)

        def calculations(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CalculationsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CalculationsContext,i)


        def SET(self):
            return self.getToken(NaturalParser.SET, 0)

        def WITH(self):
            return self.getToken(NaturalParser.WITH, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COLON)
            else:
                return self.getToken(NaturalParser.COLON, i)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def SAME(self):
            return self.getToken(NaturalParser.SAME, 0)

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_updateStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateStatement" ):
                return visitor.visitUpdateStatement(self)
            else:
                return visitor.visitChildren(self)




    def updateStatement(self):

        localctx = NaturalParser.UpdateStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_updateStatement)
        self._la = 0 # Token type
        try:
            self.state = 887
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,121,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 834
                self.updateStartline()
                self.state = 836 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 835
                        _la = self._input.LA(1)
                        if not(_la==295 or _la==296):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 838 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,111,self._ctx)

                self.state = 841
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==86 or _la==90:
                    self.state = 840
                    _la = self._input.LA(1)
                    if not(_la==86 or _la==90):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 860 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 860
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                        if la_ == 1:
                            self.state = 843
                            self.match(NaturalParser.WS)
                            pass

                        elif la_ == 2:
                            self.state = 844
                            self.match(NaturalParser.NL)
                            pass

                        elif la_ == 3:
                            self.state = 845
                            self.match(NaturalParser.LINE_NUMBER)
                            pass

                        elif la_ == 4:
                            self.state = 846
                            self.operand()
                            self.state = 848
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==295:
                                self.state = 847
                                self.match(NaturalParser.WS)


                            self.state = 851
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==273:
                                self.state = 850
                                self.match(NaturalParser.COLON)


                            self.state = 853
                            self.match(NaturalParser.EQ)
                            self.state = 855
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==295:
                                self.state = 854
                                self.match(NaturalParser.WS)


                            self.state = 857
                            self.operand()
                            pass

                        elif la_ == 5:
                            self.state = 859
                            self.calculations()
                            pass



                    else:
                        raise NoViableAltException(self)
                    self.state = 862 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,117,self._ctx)

                self.state = 865
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 864
                    self.match(NaturalParser.WS)


                self.state = 867
                self.match(NaturalParser.NL)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 869
                self.updateStartline()
                self.state = 870
                self.match(NaturalParser.WS)
                self.state = 871
                self.match(NaturalParser.USING)
                self.state = 872
                self.match(NaturalParser.WS)
                self.state = 873
                self.match(NaturalParser.SAME)
                self.state = 874
                self.match(NaturalParser.WS)
                self.state = 875
                self.match(NaturalParser.RECORD)
                self.state = 877
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 876
                    self.match(NaturalParser.WS)


                self.state = 879
                self.match(NaturalParser.NL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 881
                self.updateStartline()
                self.state = 883
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 882
                    self.match(NaturalParser.WS)


                self.state = 885
                self.match(NaturalParser.NL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpdateStartlineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE(self):
            return self.getToken(NaturalParser.UPDATE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def IN(self):
            return self.getToken(NaturalParser.IN, 0)

        def STATEMENT(self):
            return self.getToken(NaturalParser.STATEMENT, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_updateStartline

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdateStartline" ):
                return visitor.visitUpdateStartline(self)
            else:
                return visitor.visitChildren(self)




    def updateStartline(self):

        localctx = NaturalParser.UpdateStartlineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_updateStartline)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 889
            self.match(NaturalParser.UPDATE)
            self.state = 891
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
            if la_ == 1:
                self.state = 890
                self.match(NaturalParser.WS)


            self.state = 894
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==83:
                self.state = 893
                self.match(NaturalParser.RECORD)


            self.state = 897
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
            if la_ == 1:
                self.state = 896
                self.match(NaturalParser.WS)


            self.state = 900
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==81:
                self.state = 899
                self.match(NaturalParser.IN)


            self.state = 903
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
            if la_ == 1:
                self.state = 902
                self.match(NaturalParser.WS)


            self.state = 906
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==85:
                self.state = 905
                self.match(NaturalParser.STATEMENT)


            self.state = 909
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,128,self._ctx)
            if la_ == 1:
                self.state = 908
                self.match(NaturalParser.WS)


            self.state = 912
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==277 or _la==293:
                self.state = 911
                _la = self._input.LA(1)
                if not(_la==277 or _la==293):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeleteStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_deleteStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeleteStatement" ):
                return visitor.visitDeleteStatement(self)
            else:
                return visitor.visitChildren(self)




    def deleteStatement(self):

        localctx = NaturalParser.DeleteStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_deleteStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 914
            self.match(NaturalParser.DELETE)
            self.state = 916
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
            if la_ == 1:
                self.state = 915
                self.match(NaturalParser.WS)


            self.state = 919
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
            if la_ == 1:
                self.state = 918
                self.match(NaturalParser.LINE_REF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getTabledStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetTabledStatementsContext,0)


        def getTransactionStatement(self):
            return self.getTypedRuleContext(NaturalParser.GetTransactionStatementContext,0)


        def getSameStatement(self):
            return self.getTypedRuleContext(NaturalParser.GetSameStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_getStatements

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetStatements" ):
                return visitor.visitGetStatements(self)
            else:
                return visitor.visitChildren(self)




    def getStatements(self):

        localctx = NaturalParser.GetStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_getStatements)
        try:
            self.state = 924
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [41]:
                self.enterOuterAlt(localctx, 1)
                self.state = 921
                self.getTabledStatements()
                pass
            elif token in [88]:
                self.enterOuterAlt(localctx, 2)
                self.state = 922
                self.getTransactionStatement()
                pass
            elif token in [89]:
                self.enterOuterAlt(localctx, 3)
                self.state = 923
                self.getSameStatement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTabledStatementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token
            self.filterCondition = None # VariableContext

        def GET(self):
            return self.getToken(NaturalParser.GET, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def getTabledOptions(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.GetTabledOptionsContext)
            else:
                return self.getTypedRuleContext(NaturalParser.GetTabledOptionsContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_getTabledStatements

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetTabledStatements" ):
                return visitor.visitGetTabledStatements(self)
            else:
                return visitor.visitChildren(self)




    def getTabledStatements(self):

        localctx = NaturalParser.GetTabledStatementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_getTabledStatements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 926
            self.match(NaturalParser.GET)
            self.state = 927
            self.match(NaturalParser.WS)
            self.state = 928
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 933
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==83 or _la==84 or _la==295:
                self.state = 931
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [83, 84]:
                    self.state = 929
                    self.getTabledOptions()
                    pass
                elif token in [295]:
                    self.state = 930
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 935
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 936
            localctx.filterCondition = self.variable()
            self.state = 938
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 937
                self.match(NaturalParser.WS)


            self.state = 940
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTabledOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECORD(self):
            return self.getToken(NaturalParser.RECORD, 0)

        def RECORDS(self):
            return self.getToken(NaturalParser.RECORDS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_getTabledOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetTabledOptions" ):
                return visitor.visitGetTabledOptions(self)
            else:
                return visitor.visitChildren(self)




    def getTabledOptions(self):

        localctx = NaturalParser.GetTabledOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_getTabledOptions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            _la = self._input.LA(1)
            if not(_la==83 or _la==84):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetTransactionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_TRANSACTION_DATA(self):
            return self.getToken(NaturalParser.GET_TRANSACTION_DATA, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_getTransactionStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetTransactionStatement" ):
                return visitor.visitGetTransactionStatement(self)
            else:
                return visitor.visitChildren(self)




    def getTransactionStatement(self):

        localctx = NaturalParser.GetTransactionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_getTransactionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self.match(NaturalParser.GET_TRANSACTION_DATA)
            self.state = 946 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 945
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6815745) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 948 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,136,self._ctx)

            self.state = 950
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetSameStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GET_SAME(self):
            return self.getToken(NaturalParser.GET_SAME, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_getSameStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetSameStatement" ):
                return visitor.visitGetSameStatement(self)
            else:
                return visitor.visitChildren(self)




    def getSameStatement(self):

        localctx = NaturalParser.GetSameStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_getSameStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 952
            self.match(NaturalParser.GET_SAME)
            self.state = 957
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,138,self._ctx)
            if la_ == 1:
                self.state = 954
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 953
                    self.match(NaturalParser.WS)


                self.state = 956
                self.match(NaturalParser.LINE_REF)


            self.state = 962
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==293 or _la==295:
                self.state = 959
                _la = self._input.LA(1)
                if not(_la==293 or _la==295):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 964
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 965
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.endBlock = None # Token

        def histogramQuery(self):
            return self.getTypedRuleContext(NaturalParser.HistogramQueryContext,0)


        def END_HISTOGRAM(self):
            return self.getToken(NaturalParser.END_HISTOGRAM, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_histogramStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramStatement" ):
                return visitor.visitHistogramStatement(self)
            else:
                return visitor.visitChildren(self)




    def histogramStatement(self):

        localctx = NaturalParser.HistogramStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_histogramStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 967
            self.histogramQuery()
            self.state = 971
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0):
                self.state = 968
                self.statement()
                self.state = 973
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 974
            localctx.endBlock = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==32 or _la==207):
                localctx.endBlock = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tableName = None # Token

        def HISTOGRAM(self):
            return self.getToken(NaturalParser.HISTOGRAM, 0)

        def histogramOptions(self):
            return self.getTypedRuleContext(NaturalParser.HistogramOptionsContext,0)


        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def histogramPreview(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.HistogramPreviewContext)
            else:
                return self.getTypedRuleContext(NaturalParser.HistogramPreviewContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_histogramQuery

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramQuery" ):
                return visitor.visitHistogramQuery(self)
            else:
                return visitor.visitChildren(self)




    def histogramQuery(self):

        localctx = NaturalParser.HistogramQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_histogramQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            self.match(NaturalParser.HISTOGRAM)
            self.state = 978
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,141,self._ctx)
            if la_ == 1:
                self.state = 977
                self.match(NaturalParser.WS)


            self.state = 986
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 25)) & ~0x3f) == 0 and ((1 << (_la - 25)) & 72057594037927985) != 0) or ((((_la - 232)) & ~0x3f) == 0 and ((1 << (_la - 232)) & -9223332454436159487) != 0) or _la==296:
                self.state = 984
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [25, 29, 30, 81, 232, 246, 277]:
                    self.state = 980
                    self.histogramPreview()
                    pass
                elif token in [295]:
                    self.state = 981
                    self.match(NaturalParser.WS)
                    pass
                elif token in [296]:
                    self.state = 982
                    self.match(NaturalParser.NL)
                    pass
                elif token in [274]:
                    self.state = 983
                    self.match(NaturalParser.LINE_NUMBER)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 988
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 989
            localctx.tableName = self.match(NaturalParser.IDENTIFIER)
            self.state = 993
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,144,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 990
                    self.match(NaturalParser.WS) 
                self.state = 995
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,144,self._ctx)

            self.state = 997
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,145,self._ctx)
            if la_ == 1:
                self.state = 996
                self.match(NaturalParser.NL)


            self.state = 999
            self.histogramOptions()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramPreviewContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FIRST(self):
            return self.getToken(NaturalParser.FIRST, 0)

        def UNIQUE_LEX(self):
            return self.getToken(NaturalParser.UNIQUE_LEX, 0)

        def ALL(self):
            return self.getToken(NaturalParser.ALL, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def MULTI_FETCH(self):
            return self.getToken(NaturalParser.MULTI_FETCH, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def OF(self):
            return self.getToken(NaturalParser.OF, 0)

        def ON(self):
            return self.getToken(NaturalParser.ON, 0)

        def OFF(self):
            return self.getToken(NaturalParser.OFF, 0)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def FILE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FILE)
            else:
                return self.getToken(NaturalParser.FILE, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_histogramPreview

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramPreview" ):
                return visitor.visitHistogramPreview(self)
            else:
                return visitor.visitChildren(self)




    def histogramPreview(self):

        localctx = NaturalParser.HistogramPreviewContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_histogramPreview)
        self._la = 0 # Token type
        try:
            self.state = 1014
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [25, 29, 30, 277]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1001
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 1644167168) != 0) or _la==277):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [232]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1002
                self.match(NaturalParser.MULTI_FETCH)
                self.state = 1005
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,146,self._ctx)
                if la_ == 1:
                    self.state = 1003
                    self.match(NaturalParser.WS)
                    self.state = 1004
                    _la = self._input.LA(1)
                    if not(((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 8195) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1007
                self.match(NaturalParser.WS)
                self.state = 1008
                self.match(NaturalParser.LINE_NUMBER)
                pass
            elif token in [81, 246]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1010 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1009
                        _la = self._input.LA(1)
                        if not(_la==81 or _la==246):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1012 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,147,self._ctx)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HistogramOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_REF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_REF)
            else:
                return self.getToken(NaturalParser.LINE_REF, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def PASSWORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PASSWORD)
            else:
                return self.getToken(NaturalParser.PASSWORD, i)

        def ALL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ALL)
            else:
                return self.getToken(NaturalParser.ALL, i)

        def FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FROM)
            else:
                return self.getToken(NaturalParser.FROM, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WITH)
            else:
                return self.getToken(NaturalParser.WITH, i)

        def THRU(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THRU)
            else:
                return self.getToken(NaturalParser.THRU, i)

        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IN)
            else:
                return self.getToken(NaturalParser.IN, i)

        def VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VALUE)
            else:
                return self.getToken(NaturalParser.VALUE, i)

        def FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FOR)
            else:
                return self.getToken(NaturalParser.FOR, i)

        def FIELD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FIELD)
            else:
                return self.getToken(NaturalParser.FIELD, i)

        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ON)
            else:
                return self.getToken(NaturalParser.ON, i)

        def OFF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OFF)
            else:
                return self.getToken(NaturalParser.OFF, i)

        def OF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OF)
            else:
                return self.getToken(NaturalParser.OF, i)

        def ASCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ASCENDING)
            else:
                return self.getToken(NaturalParser.ASCENDING, i)

        def DESCENDING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DESCENDING)
            else:
                return self.getToken(NaturalParser.DESCENDING, i)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VARIABLE)
            else:
                return self.getToken(NaturalParser.VARIABLE, i)

        def DYNAMIC(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DYNAMIC)
            else:
                return self.getToken(NaturalParser.DYNAMIC, i)

        def SEQUENCE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SEQUENCE)
            else:
                return self.getToken(NaturalParser.SEQUENCE, i)

        def STARTING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING)
            else:
                return self.getToken(NaturalParser.STARTING, i)

        def STARTING_WITH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_WITH)
            else:
                return self.getToken(NaturalParser.STARTING_WITH, i)

        def STARTING_FROM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STARTING_FROM)
            else:
                return self.getToken(NaturalParser.STARTING_FROM, i)

        def ENDING_AT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ENDING_AT)
            else:
                return self.getToken(NaturalParser.ENDING_AT, i)

        def WHERE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WHERE)
            else:
                return self.getToken(NaturalParser.WHERE, i)

        def compOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.CompOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.CompOpContext,i)


        def logicalOp(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.LogicalOpContext)
            else:
                return self.getTypedRuleContext(NaturalParser.LogicalOpContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_histogramOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHistogramOptions" ):
                return visitor.visitHistogramOptions(self)
            else:
                return visitor.visitChildren(self)




    def histogramOptions(self):

        localctx = NaturalParser.HistogramOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_histogramOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1047
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,150,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1045
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
                    if la_ == 1:
                        self.state = 1016
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 1017
                        self.match(NaturalParser.LINE_REF)
                        pass

                    elif la_ == 3:
                        self.state = 1018
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 1019
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 5:
                        self.state = 1020
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 6:
                        self.state = 1021
                        self.match(NaturalParser.PASSWORD)
                        pass

                    elif la_ == 7:
                        self.state = 1022
                        self.match(NaturalParser.ALL)
                        pass

                    elif la_ == 8:
                        self.state = 1023
                        self.match(NaturalParser.FROM)
                        pass

                    elif la_ == 9:
                        self.state = 1024
                        self.match(NaturalParser.WITH)
                        pass

                    elif la_ == 10:
                        self.state = 1025
                        self.match(NaturalParser.THRU)
                        pass

                    elif la_ == 11:
                        self.state = 1026
                        self.match(NaturalParser.IN)
                        pass

                    elif la_ == 12:
                        self.state = 1027
                        self.match(NaturalParser.VALUE)
                        pass

                    elif la_ == 13:
                        self.state = 1028
                        self.match(NaturalParser.FOR)
                        pass

                    elif la_ == 14:
                        self.state = 1029
                        self.match(NaturalParser.FIELD)
                        pass

                    elif la_ == 15:
                        self.state = 1030
                        self.match(NaturalParser.ON)
                        pass

                    elif la_ == 16:
                        self.state = 1031
                        self.match(NaturalParser.OFF)
                        pass

                    elif la_ == 17:
                        self.state = 1032
                        self.match(NaturalParser.OF)
                        pass

                    elif la_ == 18:
                        self.state = 1033
                        self.match(NaturalParser.ASCENDING)
                        pass

                    elif la_ == 19:
                        self.state = 1034
                        self.match(NaturalParser.DESCENDING)
                        pass

                    elif la_ == 20:
                        self.state = 1035
                        self.match(NaturalParser.VARIABLE)
                        pass

                    elif la_ == 21:
                        self.state = 1036
                        self.match(NaturalParser.DYNAMIC)
                        pass

                    elif la_ == 22:
                        self.state = 1037
                        self.match(NaturalParser.SEQUENCE)
                        pass

                    elif la_ == 23:
                        self.state = 1038
                        self.match(NaturalParser.STARTING)
                        pass

                    elif la_ == 24:
                        self.state = 1039
                        self.match(NaturalParser.STARTING_WITH)
                        pass

                    elif la_ == 25:
                        self.state = 1040
                        self.match(NaturalParser.STARTING_FROM)
                        pass

                    elif la_ == 26:
                        self.state = 1041
                        self.match(NaturalParser.ENDING_AT)
                        pass

                    elif la_ == 27:
                        self.state = 1042
                        self.match(NaturalParser.WHERE)
                        pass

                    elif la_ == 28:
                        self.state = 1043
                        self.compOp()
                        pass

                    elif la_ == 29:
                        self.state = 1044
                        self.logicalOp()
                        pass

             
                self.state = 1049
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,150,self._ctx)

            self.state = 1050
            self.operand()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndTransactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def END_TRANSACTION(self):
            return self.getToken(NaturalParser.END_TRANSACTION, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_endTransaction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndTransaction" ):
                return visitor.visitEndTransaction(self)
            else:
                return visitor.visitChildren(self)




    def endTransaction(self):

        localctx = NaturalParser.EndTransactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_endTransaction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1052
            self.match(NaturalParser.END_TRANSACTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BackoutTransactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BACKOUT_TRANSACTION(self):
            return self.getToken(NaturalParser.BACKOUT_TRANSACTION, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_backoutTransaction

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBackoutTransaction" ):
                return visitor.visitBackoutTransaction(self)
            else:
                return visitor.visitChildren(self)




    def backoutTransaction(self):

        localctx = NaturalParser.BackoutTransactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_backoutTransaction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1054
            self.match(NaturalParser.BACKOUT_TRANSACTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def readworkfileOptions(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileOptionsContext,0)


        def atEndOfFileStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtEndOfFileStatementContext,0)


        def READ_WORK_FILE(self):
            return self.getToken(NaturalParser.READ_WORK_FILE, 0)

        def READ_WORK(self):
            return self.getToken(NaturalParser.READ_WORK, 0)

        def ONCE(self):
            return self.getToken(NaturalParser.ONCE, 0)

        def END_ALL(self):
            return self.getToken(NaturalParser.END_ALL, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def END_WORK(self):
            return self.getToken(NaturalParser.END_WORK, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_readworkfileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadworkfileStatement" ):
                return visitor.visitReadworkfileStatement(self)
            else:
                return visitor.visitChildren(self)




    def readworkfileStatement(self):

        localctx = NaturalParser.ReadworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_readworkfileStatement)
        self._la = 0 # Token type
        try:
            self.state = 1102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,159,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1056
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1057
                self.match(NaturalParser.WS)
                self.state = 1058
                self.workfilenumberOption()
                self.state = 1063
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,152,self._ctx)
                if la_ == 1:
                    self.state = 1060
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 1059
                        self.match(NaturalParser.WS)


                    self.state = 1062
                    self.match(NaturalParser.ONCE)


                self.state = 1065
                self.readworkfileOptions()
                self.state = 1066
                self.atEndOfFileStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1068
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1069
                self.match(NaturalParser.WS)
                self.state = 1070
                self.workfilenumberOption()
                self.state = 1075
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,154,self._ctx)
                if la_ == 1:
                    self.state = 1072
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 1071
                        self.match(NaturalParser.WS)


                    self.state = 1074
                    self.match(NaturalParser.ONCE)


                self.state = 1077
                self.readworkfileOptions()
                self.state = 1079 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1078
                        self.statement()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1081 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,155,self._ctx)

                self.state = 1083
                self.match(NaturalParser.END_ALL)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1085
                _la = self._input.LA(1)
                if not(_la==157 or _la==158):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1086
                self.match(NaturalParser.WS)
                self.state = 1087
                self.workfilenumberOption()
                self.state = 1092
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
                if la_ == 1:
                    self.state = 1089
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 1088
                        self.match(NaturalParser.WS)


                    self.state = 1091
                    self.match(NaturalParser.ONCE)


                self.state = 1094
                self.readworkfileOptions()
                self.state = 1096 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 1095
                        self.statement()

                    else:
                        raise NoViableAltException(self)
                    self.state = 1098 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,158,self._ctx)

                self.state = 1100
                _la = self._input.LA(1)
                if not(_la==32 or _la==238):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WorkfilenumberOptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_workfilenumberOption

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWorkfilenumberOption" ):
                return visitor.visitWorkfilenumberOption(self)
            else:
                return visitor.visitChildren(self)




    def workfilenumberOption(self):

        localctx = NaturalParser.WorkfilenumberOptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_workfilenumberOption)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1104
            self.match(NaturalParser.LINE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadworkfileOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_REF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_REF)
            else:
                return self.getToken(NaturalParser.LINE_REF, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def RECORD(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RECORD)
            else:
                return self.getToken(NaturalParser.RECORD, i)

        def FILLER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FILLER)
            else:
                return self.getToken(NaturalParser.FILLER, i)

        def OFFSET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.OFFSET)
            else:
                return self.getToken(NaturalParser.OFFSET, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AND)
            else:
                return self.getToken(NaturalParser.AND, i)

        def SELECT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.SELECT)
            else:
                return self.getToken(NaturalParser.SELECT, i)

        def GIVING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.GIVING)
            else:
                return self.getToken(NaturalParser.GIVING, i)

        def LENGTH(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LENGTH)
            else:
                return self.getToken(NaturalParser.LENGTH, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_readworkfileOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReadworkfileOptions" ):
                return visitor.visitReadworkfileOptions(self)
            else:
                return visitor.visitChildren(self)




    def readworkfileOptions(self):

        localctx = NaturalParser.ReadworkfileOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_readworkfileOptions)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1120
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,161,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1118
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,160,self._ctx)
                    if la_ == 1:
                        self.state = 1106
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 1107
                        self.match(NaturalParser.LINE_REF)
                        pass

                    elif la_ == 3:
                        self.state = 1108
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 1109
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 5:
                        self.state = 1110
                        self.match(NaturalParser.NL)
                        pass

                    elif la_ == 6:
                        self.state = 1111
                        self.match(NaturalParser.RECORD)
                        pass

                    elif la_ == 7:
                        self.state = 1112
                        self.match(NaturalParser.FILLER)
                        pass

                    elif la_ == 8:
                        self.state = 1113
                        self.match(NaturalParser.OFFSET)
                        pass

                    elif la_ == 9:
                        self.state = 1114
                        self.match(NaturalParser.AND)
                        pass

                    elif la_ == 10:
                        self.state = 1115
                        self.match(NaturalParser.SELECT)
                        pass

                    elif la_ == 11:
                        self.state = 1116
                        self.match(NaturalParser.GIVING)
                        pass

                    elif la_ == 12:
                        self.state = 1117
                        self.match(NaturalParser.LENGTH)
                        pass

             
                self.state = 1122
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,161,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtEndOfFileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_END_OF_FILE(self):
            return self.getToken(NaturalParser.AT_END_OF_FILE, 0)

        def END_ENDFILE(self):
            return self.getToken(NaturalParser.END_ENDFILE, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_atEndOfFileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtEndOfFileStatement" ):
                return visitor.visitAtEndOfFileStatement(self)
            else:
                return visitor.visitChildren(self)




    def atEndOfFileStatement(self):

        localctx = NaturalParser.AtEndOfFileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_atEndOfFileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1123
            self.match(NaturalParser.AT_END_OF_FILE)
            self.state = 1127
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,162,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1124
                    self.statement() 
                self.state = 1129
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,162,self._ctx)

            self.state = 1130
            self.match(NaturalParser.END_ENDFILE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WriteworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WRITE_WORK_FILE(self):
            return self.getToken(NaturalParser.WRITE_WORK_FILE, 0)

        def WRITE_WORK(self):
            return self.getToken(NaturalParser.WRITE_WORK, 0)

        def VARIABLE(self):
            return self.getToken(NaturalParser.VARIABLE, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_writeworkfileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWriteworkfileStatement" ):
                return visitor.visitWriteworkfileStatement(self)
            else:
                return visitor.visitChildren(self)




    def writeworkfileStatement(self):

        localctx = NaturalParser.WriteworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_writeworkfileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1132
            _la = self._input.LA(1)
            if not(_la==154 or _la==155):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1133
            self.match(NaturalParser.WS)
            self.state = 1134
            self.workfilenumberOption()
            self.state = 1139
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,164,self._ctx)
            if la_ == 1:
                self.state = 1136
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1135
                    self.match(NaturalParser.WS)


                self.state = 1138
                self.match(NaturalParser.VARIABLE)


            self.state = 1147
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,166,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1145
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
                    if la_ == 1:
                        self.state = 1141
                        self.operand()
                        pass

                    elif la_ == 2:
                        self.state = 1142
                        self.match(NaturalParser.LINE_NUMBER)
                        pass

                    elif la_ == 3:
                        self.state = 1143
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 4:
                        self.state = 1144
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 1149
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,166,self._ctx)

            self.state = 1150
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CloseworkfileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def workfilenumberOption(self):
            return self.getTypedRuleContext(NaturalParser.WorkfilenumberOptionContext,0)


        def CLOSE_WORK_FILE(self):
            return self.getToken(NaturalParser.CLOSE_WORK_FILE, 0)

        def CLOSE_WORK(self):
            return self.getToken(NaturalParser.CLOSE_WORK, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_closeworkfileStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCloseworkfileStatement" ):
                return visitor.visitCloseworkfileStatement(self)
            else:
                return visitor.visitChildren(self)




    def closeworkfileStatement(self):

        localctx = NaturalParser.CloseworkfileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_closeworkfileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1152
            _la = self._input.LA(1)
            if not(_la==160 or _la==161):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1153
            self.match(NaturalParser.WS)
            self.state = 1154
            self.workfilenumberOption()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NoRecordsFoundStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def END_NOREC(self):
            return self.getToken(NaturalParser.END_NOREC, 0)

        def NO_RECORDS_FOUND(self):
            return self.getToken(NaturalParser.NO_RECORDS_FOUND, 0)

        def NO_RECORD_FOUND(self):
            return self.getToken(NaturalParser.NO_RECORD_FOUND, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_noRecordsFoundStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNoRecordsFoundStatement" ):
                return visitor.visitNoRecordsFoundStatement(self)
            else:
                return visitor.visitChildren(self)




    def noRecordsFoundStatement(self):

        localctx = NaturalParser.NoRecordsFoundStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_noRecordsFoundStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1156
            self.match(NaturalParser.IF)
            self.state = 1157
            self.match(NaturalParser.WS)
            self.state = 1158
            _la = self._input.LA(1)
            if not(_la==73 or _la==74):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1162
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,167,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1159
                    self.statement() 
                self.state = 1164
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,167,self._ctx)

            self.state = 1165
            self.match(NaturalParser.END_NOREC)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtStartOfDataStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT_START_OF_DATA(self):
            return self.getToken(NaturalParser.AT_START_OF_DATA, 0)

        def END_START(self):
            return self.getToken(NaturalParser.END_START, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_atStartOfDataStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtStartOfDataStatement" ):
                return visitor.visitAtStartOfDataStatement(self)
            else:
                return visitor.visitChildren(self)




    def atStartOfDataStatement(self):

        localctx = NaturalParser.AtStartOfDataStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_atStartOfDataStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1167
            self.match(NaturalParser.AT_START_OF_DATA)
            self.state = 1169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,168,self._ctx)
            if la_ == 1:
                self.state = 1168
                self.match(NaturalParser.WS)


            self.state = 1172
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.state = 1171
                self.match(NaturalParser.IDENTIFIER)


            self.state = 1175
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,170,self._ctx)
            if la_ == 1:
                self.state = 1174
                self.match(NaturalParser.NL)


            self.state = 1179
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,171,self._ctx)
            if la_ == 1:
                self.state = 1177
                self.match(NaturalParser.DO)
                self.state = 1178
                self.match(NaturalParser.WS)


            self.state = 1184
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,172,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1181
                    self.statement() 
                self.state = 1186
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,172,self._ctx)

            self.state = 1187
            _la = self._input.LA(1)
            if not(_la==64 or _la==217):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formatOptions(self):
            return self.getTypedRuleContext(NaturalParser.FormatOptionsContext,0)


        def assignmentStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AssignmentStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_formatStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatStatement" ):
                return visitor.visitFormatStatement(self)
            else:
                return visitor.visitChildren(self)




    def formatStatement(self):

        localctx = NaturalParser.FormatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_formatStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1189
            self.formatOptions()
            self.state = 1208
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,177,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1193
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,173,self._ctx)
                    while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1+1:
                            self.state = 1190
                            self.match(NaturalParser.WS) 
                        self.state = 1195
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,173,self._ctx)

                    self.state = 1196
                    self.assignmentStatement()
                    self.state = 1198
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,174,self._ctx)
                    if la_ == 1:
                        self.state = 1197
                        self.match(NaturalParser.WS)


                    self.state = 1201
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,175,self._ctx)
                    if la_ == 1:
                        self.state = 1200
                        self.match(NaturalParser.NL)


                    self.state = 1204
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,176,self._ctx)
                    if la_ == 1:
                        self.state = 1203
                        self.match(NaturalParser.LINE_NUMBER)

             
                self.state = 1210
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,177,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormatOptionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORMAT(self):
            return self.getToken(NaturalParser.FORMAT, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_formatOptions

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFormatOptions" ):
                return visitor.visitFormatOptions(self)
            else:
                return visitor.visitChildren(self)




    def formatOptions(self):

        localctx = NaturalParser.FormatOptionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_formatOptions)
        self._la = 0 # Token type
        try:
            self.state = 1217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,179,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1211
                self.match(NaturalParser.FORMAT)
                self.state = 1213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1212
                    self.match(NaturalParser.WS)


                self.state = 1215
                self.match(NaturalParser.LINE_REF)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1216
                self.match(NaturalParser.FORMAT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def ON(self):
            return self.getToken(NaturalParser.ON, 0)

        def OFF(self):
            return self.getToken(NaturalParser.OFF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_assignmentStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignmentStatement" ):
                return visitor.visitAssignmentStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignmentStatement(self):

        localctx = NaturalParser.AssignmentStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_assignmentStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1219
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1220
            self.compOp()
            self.state = 1221
            _la = self._input.LA(1)
            if not(((((_la - 218)) & ~0x3f) == 0 and ((1 << (_la - 218)) & 72057594037927939) != 0) or _la==293):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IncludeStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(NaturalParser.INCLUDE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_includeStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIncludeStatement" ):
                return visitor.visitIncludeStatement(self)
            else:
                return visitor.visitChildren(self)




    def includeStatement(self):

        localctx = NaturalParser.IncludeStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_includeStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1223
            self.match(NaturalParser.INCLUDE)

            self.state = 1227
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,180,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 1224
                    self.match(NaturalParser.WS) 
                self.state = 1229
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,180,self._ctx)

            self.state = 1230
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1232
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,181,self._ctx)
            if la_ == 1:
                self.state = 1231
                self.match(NaturalParser.WS)


            self.state = 1235
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,182,self._ctx)
            if la_ == 1:
                self.state = 1234
                self.match(NaturalParser.NL)


            self.state = 1238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,183,self._ctx)
            if la_ == 1:
                self.state = 1237
                self.match(NaturalParser.LINE_NUMBER)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RedefineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REDEFINE(self):
            return self.getToken(NaturalParser.REDEFINE, 0)

        def redefineBody(self):
            return self.getTypedRuleContext(NaturalParser.RedefineBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_redefineStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRedefineStatement" ):
                return visitor.visitRedefineStatement(self)
            else:
                return visitor.visitChildren(self)




    def redefineStatement(self):

        localctx = NaturalParser.RedefineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_redefineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1240
            self.match(NaturalParser.REDEFINE)
            self.state = 1242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,184,self._ctx)
            if la_ == 1:
                self.state = 1241
                self.match(NaturalParser.WS)


            self.state = 1244
            self.redefineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RedefineBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_redefineBody

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRedefineBody" ):
                return visitor.visitRedefineBody(self)
            else:
                return visitor.visitChildren(self)




    def redefineBody(self):

        localctx = NaturalParser.RedefineBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_redefineBody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1251
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,186,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1249
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [274, 293]:
                        self.state = 1246
                        _la = self._input.LA(1)
                        if not(_la==274 or _la==293):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    elif token in [295]:
                        self.state = 1247
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 1248
                        self.match(NaturalParser.NL)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 1253
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,186,self._ctx)

            self.state = 1254
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ResetStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RESET(self):
            return self.getToken(NaturalParser.RESET, 0)

        def redefineBody(self):
            return self.getTypedRuleContext(NaturalParser.RedefineBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_resetStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetStatement" ):
                return visitor.visitResetStatement(self)
            else:
                return visitor.visitChildren(self)




    def resetStatement(self):

        localctx = NaturalParser.ResetStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_resetStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1256
            self.match(NaturalParser.RESET)
            self.state = 1258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,187,self._ctx)
            if la_ == 1:
                self.state = 1257
                self.match(NaturalParser.WS)


            self.state = 1260
            self.redefineBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallnatStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def CALLNAT(self):
            return self.getToken(NaturalParser.CALLNAT, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.VariableContext)
            else:
                return self.getTypedRuleContext(NaturalParser.VariableContext,i)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_callnatStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallnatStatement" ):
                return visitor.visitCallnatStatement(self)
            else:
                return visitor.visitChildren(self)




    def callnatStatement(self):

        localctx = NaturalParser.CallnatStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_callnatStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1262
            self.match(NaturalParser.CALLNAT)
            self.state = 1264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1263
                self.match(NaturalParser.WS)


            self.state = 1266
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1268
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
            if la_ == 1:
                self.state = 1267
                self.match(NaturalParser.WS)


            self.state = 1276
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,191,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1274
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [293]:
                        self.state = 1270
                        self.variable()
                        pass
                    elif token in [295]:
                        self.state = 1271
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 1272
                        self.match(NaturalParser.NL)
                        pass
                    elif token in [274]:
                        self.state = 1273
                        self.match(NaturalParser.LINE_NUMBER)
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 1278
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,191,self._ctx)

            self.state = 1279
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetkeyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET_KEY(self):
            return self.getToken(NaturalParser.SET_KEY, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_setkeyStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSetkeyStatement" ):
                return visitor.visitSetkeyStatement(self)
            else:
                return visitor.visitChildren(self)




    def setkeyStatement(self):

        localctx = NaturalParser.SetkeyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_setkeyStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1281
            self.match(NaturalParser.SET_KEY)
            self.state = 1285
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,192,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1282
                    self.match(NaturalParser.WS) 
                self.state = 1287
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,192,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PerformStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subroutineName = None # SubroutineNamesContext

        def PERFORM(self):
            return self.getToken(NaturalParser.PERFORM, 0)

        def subroutineNames(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineNamesContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_performStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPerformStatement" ):
                return visitor.visitPerformStatement(self)
            else:
                return visitor.visitChildren(self)




    def performStatement(self):

        localctx = NaturalParser.PerformStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_performStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1288
            self.match(NaturalParser.PERFORM)
            self.state = 1290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1289
                self.match(NaturalParser.WS)


            self.state = 1292
            localctx.subroutineName = self.subroutineNames()
            self.state = 1301
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
            if la_ == 1:
                self.state = 1294
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1293
                    self.match(NaturalParser.WS)


                self.state = 1296
                self.match(NaturalParser.USING)
                self.state = 1298
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1297
                    self.match(NaturalParser.WS)


                self.state = 1300
                self.variable()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineNamesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def TRANSLATE(self):
            return self.getToken(NaturalParser.TRANSLATE, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_subroutineNames

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineNames" ):
                return visitor.visitSubroutineNames(self)
            else:
                return visitor.visitChildren(self)




    def subroutineNames(self):

        localctx = NaturalParser.SubroutineNamesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_subroutineNames)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1303
            _la = self._input.LA(1)
            if not(_la==102 or _la==293):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FetchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def FETCH(self):
            return self.getToken(NaturalParser.FETCH, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def RETURN(self):
            return self.getToken(NaturalParser.RETURN, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_fetchStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFetchStatement" ):
                return visitor.visitFetchStatement(self)
            else:
                return visitor.visitChildren(self)




    def fetchStatement(self):

        localctx = NaturalParser.FetchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_fetchStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1305
            self.match(NaturalParser.FETCH)
            self.state = 1308
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,197,self._ctx)
            if la_ == 1:
                self.state = 1306
                self.match(NaturalParser.WS)
                self.state = 1307
                _la = self._input.LA(1)
                if not(_la==13 or _la==31):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1311
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1310
                self.match(NaturalParser.WS)


            self.state = 1313
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1323
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,200,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1317
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                        self.state = 1314
                        _la = self._input.LA(1)
                        if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1319
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1320
                    _la = self._input.LA(1)
                    if not(_la==272 or _la==293):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1325
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,200,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subprogramName = None # Token

        def CALL(self):
            return self.getToken(NaturalParser.CALL, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def INTERFACE4(self):
            return self.getToken(NaturalParser.INTERFACE4, 0)

        def USING(self):
            return self.getToken(NaturalParser.USING, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_callStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCallStatement" ):
                return visitor.visitCallStatement(self)
            else:
                return visitor.visitChildren(self)




    def callStatement(self):

        localctx = NaturalParser.CallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_callStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1326
            self.match(NaturalParser.CALL)
            self.state = 1329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.state = 1327
                self.match(NaturalParser.WS)
                self.state = 1328
                self.match(NaturalParser.INTERFACE4)


            self.state = 1332
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1331
                self.match(NaturalParser.WS)


            self.state = 1334
            localctx.subprogramName = self.match(NaturalParser.STRING)
            self.state = 1339
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
            if la_ == 1:
                self.state = 1336
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1335
                    self.match(NaturalParser.WS)


                self.state = 1338
                self.match(NaturalParser.USING)


            self.state = 1350
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,206,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1344
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                        self.state = 1341
                        _la = self._input.LA(1)
                        if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 1346
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1347
                    _la = self._input.LA(1)
                    if not(_la==272 or _la==293):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1352
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,206,self._ctx)

            self.state = 1354
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1353
                self.match(NaturalParser.WS)


            self.state = 1356
            self.match(NaturalParser.NL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def END_FOR(self):
            return self.getToken(NaturalParser.END_FOR, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_forStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForStatement" ):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)




    def forStatement(self):

        localctx = NaturalParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_forStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1358
            self.match(NaturalParser.FOR)
            self.state = 1359
            self.match(NaturalParser.WS)
            self.state = 1360
            self.condition()
            self.state = 1361
            self.match(NaturalParser.TO)
            self.state = 1362
            self.match(NaturalParser.WS)
            self.state = 1363
            self.operand()
            self.state = 1367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0):
                self.state = 1364
                self.statement()
                self.state = 1369
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1370
            _la = self._input.LA(1)
            if not(_la==32 or _la==33):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AcceptRejectIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def ACCEPT_IF(self):
            return self.getToken(NaturalParser.ACCEPT_IF, 0)

        def REJECT_IF(self):
            return self.getToken(NaturalParser.REJECT_IF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_acceptRejectIfStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAcceptRejectIfStatement" ):
                return visitor.visitAcceptRejectIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def acceptRejectIfStatement(self):

        localctx = NaturalParser.AcceptRejectIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_acceptRejectIfStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1372
            _la = self._input.LA(1)
            if not(_la==91 or _la==92):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1374
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1373
                self.match(NaturalParser.WS)


            self.state = 1376
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecisionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def END_DECIDE(self):
            return self.getToken(NaturalParser.END_DECIDE, 0)

        def DECIDE_FOR(self):
            return self.getToken(NaturalParser.DECIDE_FOR, 0)

        def DECIDE_ON(self):
            return self.getToken(NaturalParser.DECIDE_ON, 0)

        def FIRST(self):
            return self.getToken(NaturalParser.FIRST, 0)

        def EVERY(self):
            return self.getToken(NaturalParser.EVERY, 0)

        def WHEN(self):
            return self.getToken(NaturalParser.WHEN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def VALUE_OF(self):
            return self.getToken(NaturalParser.VALUE_OF, 0)

        def VALUE(self):
            return self.getToken(NaturalParser.VALUE, 0)

        def CONDITION(self):
            return self.getToken(NaturalParser.CONDITION, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_decisionStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecisionStatement" ):
                return visitor.visitDecisionStatement(self)
            else:
                return visitor.visitChildren(self)




    def decisionStatement(self):

        localctx = NaturalParser.DecisionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_decisionStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1378
            _la = self._input.LA(1)
            if not(_la==142 or _la==143):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1379
                self.match(NaturalParser.WS)


            self.state = 1382
            _la = self._input.LA(1)
            if not(_la==24 or _la==25):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,215,self._ctx)
            if la_ == 1:
                self.state = 1383
                self.match(NaturalParser.WS)
                self.state = 1385
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==26:
                    self.state = 1384
                    self.match(NaturalParser.CONDITION)


                self.state = 1388
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
                if la_ == 1:
                    self.state = 1387
                    self.match(NaturalParser.WS)


                self.state = 1391
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==296:
                    self.state = 1390
                    self.match(NaturalParser.NL)


                self.state = 1394
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1393
                    self.match(NaturalParser.LINE_NUMBER)




            self.state = 1399
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==48 or _la==63:
                self.state = 1398
                _la = self._input.LA(1)
                if not(_la==48 or _la==63):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1402
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,217,self._ctx)
            if la_ == 1:
                self.state = 1401
                self.match(NaturalParser.WS)


            self.state = 1405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==21:
                self.state = 1404
                self.match(NaturalParser.WHEN)


            self.state = 1407
            self.match(NaturalParser.WS)
            self.state = 1408
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1412
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,219,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1409
                    self.statement() 
                self.state = 1414
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,219,self._ctx)

            self.state = 1415
            self.match(NaturalParser.END_DECIDE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifStructuredStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStructuredStatementContext,0)


        def ifElseStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfElseStatementContext,0)


        def ifMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfMultilinedStatementContext,0)


        def ifSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfSinglelinedStatementContext,0)


        def acceptRejectIfStatement(self):
            return self.getTypedRuleContext(NaturalParser.AcceptRejectIfStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = NaturalParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_ifStatement)
        try:
            self.state = 1422
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1417
                self.ifStructuredStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1418
                self.ifElseStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1419
                self.ifMultilinedStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1420
                self.ifSinglelinedStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1421
                self.acceptRejectIfStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStructuredStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def END_IF(self):
            return self.getToken(NaturalParser.END_IF, 0)

        def elseStructured(self):
            return self.getTypedRuleContext(NaturalParser.ElseStructuredContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_ifStructuredStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStructuredStatement" ):
                return visitor.visitIfStructuredStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStructuredStatement(self):

        localctx = NaturalParser.IfStructuredStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_ifStructuredStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1424
            self.match(NaturalParser.IF)
            self.state = 1425
            self.match(NaturalParser.WS)
            self.state = 1426
            self.condition()
            self.state = 1430
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,221,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1427
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1432
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,221,self._ctx)

            self.state = 1434
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1433
                self.match(NaturalParser.THEN)


            self.state = 1437 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1436
                self.statement()
                self.state = 1439 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0)):
                    break

            self.state = 1443
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [18]:
                self.state = 1441
                self.match(NaturalParser.END_IF)
                pass
            elif token in [16]:
                self.state = 1442
                self.elseStructured()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseStructuredContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def END_IF(self):
            return self.getToken(NaturalParser.END_IF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_elseStructured

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseStructured" ):
                return visitor.visitElseStructured(self)
            else:
                return visitor.visitChildren(self)




    def elseStructured(self):

        localctx = NaturalParser.ElseStructuredContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_elseStructured)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1445
            self.match(NaturalParser.ELSE)
            self.state = 1449
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & -12885270530) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & -1) != 0) or ((((_la - 129)) & ~0x3f) == 0 and ((1 << (_la - 129)) & -1) != 0) or ((((_la - 193)) & ~0x3f) == 0 and ((1 << (_la - 193)) & -16385) != 0) or ((((_la - 257)) & ~0x3f) == 0 and ((1 << (_la - 257)) & 72057594037927935) != 0):
                self.state = 1446
                self.statement()
                self.state = 1451
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1452
            self.match(NaturalParser.END_IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfElseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_ifElseStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfElseStatement" ):
                return visitor.visitIfElseStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifElseStatement(self):

        localctx = NaturalParser.IfElseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_ifElseStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1454
            self.match(NaturalParser.IF)
            self.state = 1455
            self.match(NaturalParser.WS)
            self.state = 1456
            self.condition()
            self.state = 1463
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1457
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1458
                self.match(NaturalParser.NL)
                self.state = 1460
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1459
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1462
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1466
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1465
                self.match(NaturalParser.THEN)


            self.state = 1474
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1468
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1469
                self.match(NaturalParser.NL)
                self.state = 1471
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1470
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1473
                self.match(NaturalParser.WS)
                pass
            elif token in [50]:
                pass
            else:
                pass
            self.state = 1476
            self.doStatement()
            self.state = 1483
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1477
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1478
                self.match(NaturalParser.NL)
                self.state = 1480
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1479
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1482
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1487
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
            if la_ == 1:
                self.state = 1485
                self.elseMultilinedStatement()
                pass

            elif la_ == 2:
                self.state = 1486
                self.elseSinglelinedStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfMultilinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifMultilinedStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfMultilinedStatement" ):
                return visitor.visitIfMultilinedStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifMultilinedStatement(self):

        localctx = NaturalParser.IfMultilinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_ifMultilinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1489
            self.match(NaturalParser.IF)
            self.state = 1490
            self.match(NaturalParser.WS)
            self.state = 1491
            self.condition()
            self.state = 1495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                self.state = 1492
                _la = self._input.LA(1)
                if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1497
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1498
            self.match(NaturalParser.THEN)
            self.state = 1502
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                self.state = 1499
                _la = self._input.LA(1)
                if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1504
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1505
            self.doStatement()
            self.state = 1517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,239,self._ctx)
            if la_ == 1:
                self.state = 1511
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,237,self._ctx)
                if la_ == 1:
                    self.state = 1506
                    self.match(NaturalParser.WS)
                    pass

                elif la_ == 2:
                    self.state = 1508
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1507
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1510
                    self.match(NaturalParser.WS)
                    pass


                self.state = 1515
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
                if la_ == 1:
                    self.state = 1513
                    self.elseMultilinedStatement()
                    pass

                elif la_ == 2:
                    self.state = 1514
                    self.elseSinglelinedStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfSinglelinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def condition(self):
            return self.getTypedRuleContext(NaturalParser.ConditionContext,0)


        def onelinerBody(self):
            return self.getTypedRuleContext(NaturalParser.OnelinerBodyContext,0)


        def THEN(self):
            return self.getToken(NaturalParser.THEN, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def elseMultilinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseMultilinedStatementContext,0)


        def elseSinglelinedStatement(self):
            return self.getTypedRuleContext(NaturalParser.ElseSinglelinedStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_ifSinglelinedStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfSinglelinedStatement" ):
                return visitor.visitIfSinglelinedStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifSinglelinedStatement(self):

        localctx = NaturalParser.IfSinglelinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_ifSinglelinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1519
            self.match(NaturalParser.IF)
            self.state = 1520
            self.match(NaturalParser.WS)
            self.state = 1521
            self.condition()
            self.state = 1525
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,240,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1522
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1527
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,240,self._ctx)

            self.state = 1529
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 1528
                self.match(NaturalParser.THEN)


            self.state = 1534
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,242,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1531
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume() 
                self.state = 1536
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,242,self._ctx)

            self.state = 1537
            self.onelinerBody()
            self.state = 1548
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,245,self._ctx)
            if la_ == 1:
                self.state = 1541
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0):
                    self.state = 1538
                    _la = self._input.LA(1)
                    if not(((((_la - 274)) & ~0x3f) == 0 and ((1 << (_la - 274)) & 6291457) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1543
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1546
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
                if la_ == 1:
                    self.state = 1544
                    self.elseMultilinedStatement()
                    pass

                elif la_ == 2:
                    self.state = 1545
                    self.elseSinglelinedStatement()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseMultilinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_elseMultilinedStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseMultilinedStatement" ):
                return visitor.visitElseMultilinedStatement(self)
            else:
                return visitor.visitChildren(self)




    def elseMultilinedStatement(self):

        localctx = NaturalParser.ElseMultilinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_elseMultilinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1550
            self.match(NaturalParser.ELSE)
            self.state = 1557
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1551
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1552
                self.match(NaturalParser.NL)
                self.state = 1554
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1553
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1556
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1559
            self.doStatement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ElseSinglelinedStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ELSE(self):
            return self.getToken(NaturalParser.ELSE, 0)

        def onelinerBody(self):
            return self.getTypedRuleContext(NaturalParser.OnelinerBodyContext,0)


        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_elseSinglelinedStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElseSinglelinedStatement" ):
                return visitor.visitElseSinglelinedStatement(self)
            else:
                return visitor.visitChildren(self)




    def elseSinglelinedStatement(self):

        localctx = NaturalParser.ElseSinglelinedStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_elseSinglelinedStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1561
            self.match(NaturalParser.ELSE)
            self.state = 1568
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1562
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1563
                self.match(NaturalParser.NL)
                self.state = 1565
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1564
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1567
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1570
            self.onelinerBody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OnelinerBodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self):
            return self.getTypedRuleContext(NaturalParser.StatementContext,0)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def EOF(self):
            return self.getToken(NaturalParser.EOF, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_onelinerBody

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOnelinerBody" ):
                return visitor.visitOnelinerBody(self)
            else:
                return visitor.visitChildren(self)




    def onelinerBody(self):

        localctx = NaturalParser.OnelinerBodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_onelinerBody)
        self._la = 0 # Token type
        try:
            self.state = 1588
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,254,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1576
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
                if la_ == 1:
                    self.state = 1573
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1572
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1575
                    self.match(NaturalParser.WS)


                self.state = 1578
                self.statement()
                self.state = 1579
                _la = self._input.LA(1)
                if not(_la==-1 or _la==296):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1585
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,253,self._ctx)
                if la_ == 1:
                    self.state = 1582
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1581
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1584
                    self.match(NaturalParser.WS)


                self.state = 1587
                self.statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def logicalOp(self):
            return self.getTypedRuleContext(NaturalParser.LogicalOpContext,0)


        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def optionalCondition(self):
            return self.getTypedRuleContext(NaturalParser.OptionalConditionContext,0)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def NOT_TEXT(self):
            return self.getToken(NaturalParser.NOT_TEXT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_condition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondition" ):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)




    def condition(self):

        localctx = NaturalParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 1650
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,269,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1590
                self.operand()
                self.state = 1597
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [295]:
                    self.state = 1591
                    self.match(NaturalParser.WS)
                    pass
                elif token in [296]:
                    self.state = 1592
                    self.match(NaturalParser.NL)
                    self.state = 1594
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1593
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1596
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1602
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 301, 302]:
                    self.state = 1599
                    self.logicalOp()
                    pass
                elif token in [253, 254, 255, 256, 257, 258, 285, 286, 287, 288, 289, 290]:
                    self.state = 1600
                    self.compOp()
                    pass
                elif token in [281, 282, 283, 284]:
                    self.state = 1601
                    self.arithmaticOp()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1610
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [295]:
                    self.state = 1604
                    self.match(NaturalParser.WS)
                    pass
                elif token in [296]:
                    self.state = 1605
                    self.match(NaturalParser.NL)
                    self.state = 1607
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1606
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1609
                    self.match(NaturalParser.WS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1612
                self.operand()
                self.state = 1622
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,262,self._ctx)
                if la_ == 1:
                    self.state = 1619
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [295]:
                        self.state = 1613
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [296]:
                        self.state = 1614
                        self.match(NaturalParser.NL)
                        self.state = 1616
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==274:
                            self.state = 1615
                            self.match(NaturalParser.LINE_NUMBER)


                        self.state = 1618
                        self.match(NaturalParser.WS)
                        pass
                    elif token in [253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 301, 302]:
                        pass
                    else:
                        pass
                    self.state = 1621
                    self.optionalCondition()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1624
                self.operand()
                self.state = 1631
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
                if la_ == 1:
                    self.state = 1625
                    self.match(NaturalParser.WS)

                elif la_ == 2:
                    self.state = 1626
                    self.match(NaturalParser.NL)
                    self.state = 1628
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1627
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1630
                    self.match(NaturalParser.WS)


                self.state = 1634
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
                if la_ == 1:
                    self.state = 1633
                    self.optionalCondition()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1636
                self.match(NaturalParser.NOT_TEXT)
                self.state = 1637
                self.match(NaturalParser.WS)
                self.state = 1638
                self.operand()
                self.state = 1645
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,267,self._ctx)
                if la_ == 1:
                    self.state = 1639
                    self.match(NaturalParser.WS)

                elif la_ == 2:
                    self.state = 1640
                    self.match(NaturalParser.NL)
                    self.state = 1642
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==274:
                        self.state = 1641
                        self.match(NaturalParser.LINE_NUMBER)


                    self.state = 1644
                    self.match(NaturalParser.WS)


                self.state = 1648
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,268,self._ctx)
                if la_ == 1:
                    self.state = 1647
                    self.optionalCondition()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionalConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def logicalOp(self):
            return self.getTypedRuleContext(NaturalParser.LogicalOpContext,0)


        def compOp(self):
            return self.getTypedRuleContext(NaturalParser.CompOpContext,0)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def optionalCondition(self):
            return self.getTypedRuleContext(NaturalParser.OptionalConditionContext,0)


        def LINE_NUMBER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LINE_NUMBER)
            else:
                return self.getToken(NaturalParser.LINE_NUMBER, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_optionalCondition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionalCondition" ):
                return visitor.visitOptionalCondition(self)
            else:
                return visitor.visitChildren(self)




    def optionalCondition(self):

        localctx = NaturalParser.OptionalConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_optionalCondition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1655
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 301, 302]:
                self.state = 1652
                self.logicalOp()
                pass
            elif token in [253, 254, 255, 256, 257, 258, 285, 286, 287, 288, 289, 290]:
                self.state = 1653
                self.compOp()
                pass
            elif token in [281, 282, 283, 284]:
                self.state = 1654
                self.arithmaticOp()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1663
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [295]:
                self.state = 1657
                self.match(NaturalParser.WS)
                pass
            elif token in [296]:
                self.state = 1658
                self.match(NaturalParser.NL)
                self.state = 1660
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1659
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1662
                self.match(NaturalParser.WS)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1665
            self.operand()
            self.state = 1672
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,274,self._ctx)
            if la_ == 1:
                self.state = 1666
                self.match(NaturalParser.WS)

            elif la_ == 2:
                self.state = 1667
                self.match(NaturalParser.NL)
                self.state = 1669
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==274:
                    self.state = 1668
                    self.match(NaturalParser.LINE_NUMBER)


                self.state = 1671
                self.match(NaturalParser.WS)


            self.state = 1675
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,275,self._ctx)
            if la_ == 1:
                self.state = 1674
                self.optionalCondition()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def FLOAT(self):
            return self.getToken(NaturalParser.FLOAT, 0)

        def naturalKeywords(self):
            return self.getTypedRuleContext(NaturalParser.NaturalKeywordsContext,0)


        def LPAREN(self):
            return self.getToken(NaturalParser.LPAREN, 0)

        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def RPAREN(self):
            return self.getToken(NaturalParser.RPAREN, 0)

        def DATE_CONSTANT(self):
            return self.getToken(NaturalParser.DATE_CONSTANT, 0)

        def INPUT_PARAM(self):
            return self.getToken(NaturalParser.INPUT_PARAM, 0)

        def H_CONSTANT(self):
            return self.getToken(NaturalParser.H_CONSTANT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_operand

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperand" ):
                return visitor.visitOperand(self)
            else:
                return visitor.visitChildren(self)




    def operand(self):

        localctx = NaturalParser.OperandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_operand)
        try:
            self.state = 1689
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [293]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1677
                self.variable()
                pass
            elif token in [272]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1678
                self.match(NaturalParser.STRING)
                pass
            elif token in [274]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1679
                self.match(NaturalParser.LINE_NUMBER)
                pass
            elif token in [275]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1680
                self.match(NaturalParser.FLOAT)
                pass
            elif token in [80]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1681
                self.naturalKeywords()
                pass
            elif token in [291]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1682
                self.match(NaturalParser.LPAREN)
                self.state = 1683
                self.operand()
                self.state = 1684
                self.match(NaturalParser.RPAREN)
                pass
            elif token in [279]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1686
                self.match(NaturalParser.DATE_CONSTANT)
                pass
            elif token in [278]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1687
                self.match(NaturalParser.INPUT_PARAM)
                pass
            elif token in [280]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1688
                self.match(NaturalParser.H_CONSTANT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NaturalKeywordsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSITION(self):
            return self.getToken(NaturalParser.POSITION, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def LINE_REF(self):
            return self.getToken(NaturalParser.LINE_REF, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_naturalKeywords

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNaturalKeywords" ):
                return visitor.visitNaturalKeywords(self)
            else:
                return visitor.visitChildren(self)




    def naturalKeywords(self):

        localctx = NaturalParser.NaturalKeywordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_naturalKeywords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1691
            self.match(NaturalParser.POSITION)
            self.state = 1694
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,277,self._ctx)
            if la_ == 1:
                self.state = 1692
                self.match(NaturalParser.WS)
                self.state = 1693
                self.match(NaturalParser.LINE_REF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogicalOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND_TEXT(self):
            return self.getToken(NaturalParser.AND_TEXT, 0)

        def OR_TEXT(self):
            return self.getToken(NaturalParser.OR_TEXT, 0)

        def AND(self):
            return self.getToken(NaturalParser.AND, 0)

        def OR(self):
            return self.getToken(NaturalParser.OR, 0)

        def AND_EQ(self):
            return self.getToken(NaturalParser.AND_EQ, 0)

        def OR_RQ(self):
            return self.getToken(NaturalParser.OR_RQ, 0)

        def OR_SRQ(self):
            return self.getToken(NaturalParser.OR_SRQ, 0)

        def NOT_TEXT(self):
            return self.getToken(NaturalParser.NOT_TEXT, 0)

        def EQUAL(self):
            return self.getToken(NaturalParser.EQUAL, 0)

        def NOTEQUAL(self):
            return self.getToken(NaturalParser.NOTEQUAL, 0)

        def EQUAL_TO(self):
            return self.getToken(NaturalParser.EQUAL_TO, 0)

        def LESS_THAN(self):
            return self.getToken(NaturalParser.LESS_THAN, 0)

        def GREATER_THAN(self):
            return self.getToken(NaturalParser.GREATER_THAN, 0)

        def LESS_EQUAL(self):
            return self.getToken(NaturalParser.LESS_EQUAL, 0)

        def GREATER_EQUAL(self):
            return self.getToken(NaturalParser.GREATER_EQUAL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_logicalOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogicalOp" ):
                return visitor.visitLogicalOp(self)
            else:
                return visitor.visitChildren(self)




    def logicalOp(self):

        localctx = NaturalParser.LogicalOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_logicalOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1696
            _la = self._input.LA(1)
            if not(((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & 13194139541503) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.subroutineName = None # SubroutineNamesContext
            self.subroutineBody = None # BlockContentSubroutineContext

        def DEFINE_SUBROUTINE(self):
            return self.getToken(NaturalParser.DEFINE_SUBROUTINE, 0)

        def subroutineNames(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineNamesContext,0)


        def blockContentSubroutine(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentSubroutineContext,0)


        def END_SUBROUTINE(self):
            return self.getToken(NaturalParser.END_SUBROUTINE, 0)

        def RETURN(self):
            return self.getToken(NaturalParser.RETURN, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_subroutine

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutine" ):
                return visitor.visitSubroutine(self)
            else:
                return visitor.visitChildren(self)




    def subroutine(self):

        localctx = NaturalParser.SubroutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_subroutine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1698
            self.match(NaturalParser.DEFINE_SUBROUTINE)
            self.state = 1700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1699
                self.match(NaturalParser.WS)


            self.state = 1702
            localctx.subroutineName = self.subroutineNames()
            self.state = 1704
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,279,self._ctx)
            if la_ == 1:
                self.state = 1703
                self.match(NaturalParser.WS)


            self.state = 1706
            localctx.subroutineBody = self.blockContentSubroutine()
            self.state = 1707
            _la = self._input.LA(1)
            if not(_la==13 or _la==52):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContentSubroutineContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subroutineStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.SubroutineStatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.SubroutineStatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TRAILING_COMMENT(self):
            return self.getToken(NaturalParser.TRAILING_COMMENT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_blockContentSubroutine

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockContentSubroutine" ):
                return visitor.visitBlockContentSubroutine(self)
            else:
                return visitor.visitChildren(self)




    def blockContentSubroutine(self):

        localctx = NaturalParser.BlockContentSubroutineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_blockContentSubroutine)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1714
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,281,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1712
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,280,self._ctx)
                    if la_ == 1:
                        self.state = 1709
                        self.subroutineStatement()
                        pass

                    elif la_ == 2:
                        self.state = 1710
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 1711
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 1716
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,281,self._ctx)

            self.state = 1718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==294:
                self.state = 1717
                self.match(NaturalParser.TRAILING_COMMENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubroutineStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dataDefinition(self):
            return self.getTypedRuleContext(NaturalParser.DataDefinitionContext,0)


        def subroutine(self):
            return self.getTypedRuleContext(NaturalParser.SubroutineContext,0)


        def functionDefinition(self):
            return self.getTypedRuleContext(NaturalParser.FunctionDefinitionContext,0)


        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def forStatement(self):
            return self.getTypedRuleContext(NaturalParser.ForStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(NaturalParser.IfStatementContext,0)


        def performStatement(self):
            return self.getTypedRuleContext(NaturalParser.PerformStatementContext,0)


        def callnatStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallnatStatementContext,0)


        def redefineStatement(self):
            return self.getTypedRuleContext(NaturalParser.RedefineStatementContext,0)


        def resetStatement(self):
            return self.getTypedRuleContext(NaturalParser.ResetStatementContext,0)


        def examineStatement(self):
            return self.getTypedRuleContext(NaturalParser.ExamineStatementContext,0)


        def moveStatement(self):
            return self.getTypedRuleContext(NaturalParser.MoveStatementContext,0)


        def findStatement(self):
            return self.getTypedRuleContext(NaturalParser.FindStatementContext,0)


        def readStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadStatementContext,0)


        def storeStatement(self):
            return self.getTypedRuleContext(NaturalParser.StoreStatementContext,0)


        def updateStatement(self):
            return self.getTypedRuleContext(NaturalParser.UpdateStatementContext,0)


        def deleteStatement(self):
            return self.getTypedRuleContext(NaturalParser.DeleteStatementContext,0)


        def getStatements(self):
            return self.getTypedRuleContext(NaturalParser.GetStatementsContext,0)


        def histogramStatement(self):
            return self.getTypedRuleContext(NaturalParser.HistogramStatementContext,0)


        def endTransaction(self):
            return self.getTypedRuleContext(NaturalParser.EndTransactionContext,0)


        def backoutTransaction(self):
            return self.getTypedRuleContext(NaturalParser.BackoutTransactionContext,0)


        def readworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReadworkfileStatementContext,0)


        def writeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.WriteworkfileStatementContext,0)


        def closeworkfileStatement(self):
            return self.getTypedRuleContext(NaturalParser.CloseworkfileStatementContext,0)


        def inputStatement(self):
            return self.getTypedRuleContext(NaturalParser.InputStatementContext,0)


        def reinputStatement(self):
            return self.getTypedRuleContext(NaturalParser.ReinputStatementContext,0)


        def calculations(self):
            return self.getTypedRuleContext(NaturalParser.CalculationsContext,0)


        def assignStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignStatementContext,0)


        def sortStatement(self):
            return self.getTypedRuleContext(NaturalParser.SortStatementContext,0)


        def compressStatement(self):
            return self.getTypedRuleContext(NaturalParser.CompressStatementContext,0)


        def doStatement(self):
            return self.getTypedRuleContext(NaturalParser.DoStatementContext,0)


        def repeatStatement(self):
            return self.getTypedRuleContext(NaturalParser.RepeatStatementContext,0)


        def atStartOfDataStatement(self):
            return self.getTypedRuleContext(NaturalParser.AtStartOfDataStatementContext,0)


        def formatStatement(self):
            return self.getTypedRuleContext(NaturalParser.FormatStatementContext,0)


        def assignmentStatement(self):
            return self.getTypedRuleContext(NaturalParser.AssignmentStatementContext,0)


        def includeStatement(self):
            return self.getTypedRuleContext(NaturalParser.IncludeStatementContext,0)


        def fetchStatement(self):
            return self.getTypedRuleContext(NaturalParser.FetchStatementContext,0)


        def callStatement(self):
            return self.getTypedRuleContext(NaturalParser.CallStatementContext,0)


        def otherStatement(self):
            return self.getTypedRuleContext(NaturalParser.OtherStatementContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_subroutineStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubroutineStatement" ):
                return visitor.visitSubroutineStatement(self)
            else:
                return visitor.visitChildren(self)




    def subroutineStatement(self):

        localctx = NaturalParser.SubroutineStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_subroutineStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1759
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,283,self._ctx)
            if la_ == 1:
                self.state = 1720
                self.dataDefinition()
                pass

            elif la_ == 2:
                self.state = 1721
                self.subroutine()
                pass

            elif la_ == 3:
                self.state = 1722
                self.functionDefinition()
                pass

            elif la_ == 4:
                self.state = 1723
                self.valueAssignment()
                pass

            elif la_ == 5:
                self.state = 1724
                self.forStatement()
                pass

            elif la_ == 6:
                self.state = 1725
                self.ifStatement()
                pass

            elif la_ == 7:
                self.state = 1726
                self.performStatement()
                pass

            elif la_ == 8:
                self.state = 1727
                self.callnatStatement()
                pass

            elif la_ == 9:
                self.state = 1728
                self.redefineStatement()
                pass

            elif la_ == 10:
                self.state = 1729
                self.resetStatement()
                pass

            elif la_ == 11:
                self.state = 1730
                self.examineStatement()
                pass

            elif la_ == 12:
                self.state = 1731
                self.moveStatement()
                pass

            elif la_ == 13:
                self.state = 1732
                self.findStatement()
                pass

            elif la_ == 14:
                self.state = 1733
                self.readStatement()
                pass

            elif la_ == 15:
                self.state = 1734
                self.storeStatement()
                pass

            elif la_ == 16:
                self.state = 1735
                self.updateStatement()
                pass

            elif la_ == 17:
                self.state = 1736
                self.deleteStatement()
                pass

            elif la_ == 18:
                self.state = 1737
                self.getStatements()
                pass

            elif la_ == 19:
                self.state = 1738
                self.histogramStatement()
                pass

            elif la_ == 20:
                self.state = 1739
                self.endTransaction()
                pass

            elif la_ == 21:
                self.state = 1740
                self.backoutTransaction()
                pass

            elif la_ == 22:
                self.state = 1741
                self.readworkfileStatement()
                pass

            elif la_ == 23:
                self.state = 1742
                self.writeworkfileStatement()
                pass

            elif la_ == 24:
                self.state = 1743
                self.closeworkfileStatement()
                pass

            elif la_ == 25:
                self.state = 1744
                self.inputStatement()
                pass

            elif la_ == 26:
                self.state = 1745
                self.reinputStatement()
                pass

            elif la_ == 27:
                self.state = 1746
                self.calculations()
                pass

            elif la_ == 28:
                self.state = 1747
                self.assignStatement()
                pass

            elif la_ == 29:
                self.state = 1748
                self.sortStatement()
                pass

            elif la_ == 30:
                self.state = 1749
                self.compressStatement()
                pass

            elif la_ == 31:
                self.state = 1750
                self.doStatement()
                pass

            elif la_ == 32:
                self.state = 1751
                self.repeatStatement()
                pass

            elif la_ == 33:
                self.state = 1752
                self.atStartOfDataStatement()
                pass

            elif la_ == 34:
                self.state = 1753
                self.formatStatement()
                pass

            elif la_ == 35:
                self.state = 1754
                self.assignmentStatement()
                pass

            elif la_ == 36:
                self.state = 1755
                self.includeStatement()
                pass

            elif la_ == 37:
                self.state = 1756
                self.fetchStatement()
                pass

            elif la_ == 38:
                self.state = 1757
                self.callStatement()
                pass

            elif la_ == 39:
                self.state = 1758
                self.otherStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.functionName = None # Token
            self.returnType = None # Token
            self.functionBody = None # BlockContentContext

        def DEFINE_FUNCTION(self):
            return self.getToken(NaturalParser.DEFINE_FUNCTION, 0)

        def RETURNS(self):
            return self.getToken(NaturalParser.RETURNS, 0)

        def END_FUNCTION(self):
            return self.getToken(NaturalParser.END_FUNCTION, 0)

        def IDENTIFIER(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IDENTIFIER)
            else:
                return self.getToken(NaturalParser.IDENTIFIER, i)

        def blockContent(self):
            return self.getTypedRuleContext(NaturalParser.BlockContentContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_functionDefinition

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionDefinition" ):
                return visitor.visitFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)




    def functionDefinition(self):

        localctx = NaturalParser.FunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_functionDefinition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1761
            self.match(NaturalParser.DEFINE_FUNCTION)
            self.state = 1763
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1762
                self.match(NaturalParser.WS)


            self.state = 1765
            localctx.functionName = self.match(NaturalParser.IDENTIFIER)
            self.state = 1767
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1766
                self.match(NaturalParser.WS)


            self.state = 1769
            self.match(NaturalParser.RETURNS)
            self.state = 1771
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1770
                self.match(NaturalParser.WS)


            self.state = 1773
            localctx.returnType = self.match(NaturalParser.IDENTIFIER)
            self.state = 1775
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,287,self._ctx)
            if la_ == 1:
                self.state = 1774
                self.match(NaturalParser.WS)


            self.state = 1777
            localctx.functionBody = self.blockContent()
            self.state = 1779
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1778
                self.match(NaturalParser.WS)


            self.state = 1781
            self.match(NaturalParser.END_FUNCTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BlockContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.StatementContext)
            else:
                return self.getTypedRuleContext(NaturalParser.StatementContext,i)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def TRAILING_COMMENT(self):
            return self.getToken(NaturalParser.TRAILING_COMMENT, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_blockContent

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBlockContent" ):
                return visitor.visitBlockContent(self)
            else:
                return visitor.visitChildren(self)




    def blockContent(self):

        localctx = NaturalParser.BlockContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_blockContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1788
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,290,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1786
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,289,self._ctx)
                    if la_ == 1:
                        self.state = 1783
                        self.statement()
                        pass

                    elif la_ == 2:
                        self.state = 1784
                        self.match(NaturalParser.WS)
                        pass

                    elif la_ == 3:
                        self.state = 1785
                        self.match(NaturalParser.NL)
                        pass

             
                self.state = 1790
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,290,self._ctx)

            self.state = 1792
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==294:
                self.state = 1791
                self.match(NaturalParser.TRAILING_COMMENT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ValueAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUE(self):
            return self.getToken(NaturalParser.VALUE, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STRING)
            else:
                return self.getToken(NaturalParser.STRING, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.COMMA)
            else:
                return self.getToken(NaturalParser.COMMA, i)

        def ESCAPE_BOTTOM(self):
            return self.getToken(NaturalParser.ESCAPE_BOTTOM, 0)

        def NL(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.NL)
            else:
                return self.getToken(NaturalParser.NL, i)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def NONE(self):
            return self.getToken(NaturalParser.NONE, 0)

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def valueAssignment(self):
            return self.getTypedRuleContext(NaturalParser.ValueAssignmentContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_valueAssignment

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitValueAssignment" ):
                return visitor.visitValueAssignment(self)
            else:
                return visitor.visitChildren(self)




    def valueAssignment(self):

        localctx = NaturalParser.ValueAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_valueAssignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1794
            self.match(NaturalParser.VALUE)
            self.state = 1796
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,292,self._ctx)
            if la_ == 1:
                self.state = 1795
                self.match(NaturalParser.WS)


            self.state = 1799
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,293,self._ctx)
            if la_ == 1:
                self.state = 1798
                self.match(NaturalParser.STRING)


            self.state = 1802
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,294,self._ctx)
            if la_ == 1:
                self.state = 1801
                self.match(NaturalParser.WS)


            self.state = 1814
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,297,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1805
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 1804
                        self.match(NaturalParser.WS)


                    self.state = 1807
                    self.match(NaturalParser.COMMA)
                    self.state = 1809
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==295:
                        self.state = 1808
                        self.match(NaturalParser.WS)


                    self.state = 1811
                    self.match(NaturalParser.STRING) 
                self.state = 1816
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,297,self._ctx)

            self.state = 1818
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,298,self._ctx)
            if la_ == 1:
                self.state = 1817
                self.match(NaturalParser.ESCAPE_BOTTOM)


            self.state = 1821
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,299,self._ctx)
            if la_ == 1:
                self.state = 1820
                self.match(NaturalParser.NL)


            self.state = 1824
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,300,self._ctx)
            if la_ == 1:
                self.state = 1823
                self.match(NaturalParser.LINE_NUMBER)


            self.state = 1827
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,301,self._ctx)
            if la_ == 1:
                self.state = 1826
                self.match(NaturalParser.WS)


            self.state = 1830
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,302,self._ctx)
            if la_ == 1:
                self.state = 1829
                self.match(NaturalParser.NONE)


            self.state = 1833
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,303,self._ctx)
            if la_ == 1:
                self.state = 1832
                self.match(NaturalParser.WS)


            self.state = 1836
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,304,self._ctx)
            if la_ == 1:
                self.state = 1835
                self.match(NaturalParser.NL)


            self.state = 1839
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,305,self._ctx)
            if la_ == 1:
                self.state = 1838
                self.match(NaturalParser.WS)


            self.state = 1842
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,306,self._ctx)
            if la_ == 1:
                self.state = 1841
                self.match(NaturalParser.IDENTIFIER)


            self.state = 1845
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,307,self._ctx)
            if la_ == 1:
                self.state = 1844
                self.match(NaturalParser.WS)


            self.state = 1848
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,308,self._ctx)
            if la_ == 1:
                self.state = 1847
                self.match(NaturalParser.COLON)


            self.state = 1851
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,309,self._ctx)
            if la_ == 1:
                self.state = 1850
                self.match(NaturalParser.EQ)


            self.state = 1854
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,310,self._ctx)
            if la_ == 1:
                self.state = 1853
                self.match(NaturalParser.WS)


            self.state = 1857
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,311,self._ctx)
            if la_ == 1:
                self.state = 1856
                self.match(NaturalParser.STRING)


            self.state = 1860
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,312,self._ctx)
            if la_ == 1:
                self.state = 1859
                self.valueAssignment()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSIGN(self):
            return self.getToken(NaturalParser.ASSIGN, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def getRuleIndex(self):
            return NaturalParser.RULE_assignStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignStatement" ):
                return visitor.visitAssignStatement(self)
            else:
                return visitor.visitChildren(self)




    def assignStatement(self):

        localctx = NaturalParser.AssignStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_assignStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1862
            self.match(NaturalParser.ASSIGN)
            self.state = 1864
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,313,self._ctx)
            if la_ == 1:
                self.state = 1863
                self.match(NaturalParser.WS)


            self.state = 1867
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==124:
                self.state = 1866
                self.match(NaturalParser.ROUNDED)


            self.state = 1870
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1869
                self.match(NaturalParser.WS)


            self.state = 1872
            self.variable()
            self.state = 1874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1873
                self.match(NaturalParser.WS)


            self.state = 1877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==273:
                self.state = 1876
                self.match(NaturalParser.COLON)


            self.state = 1879
            self.match(NaturalParser.EQ)
            self.state = 1882 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1882
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [80, 272, 274, 275, 278, 279, 280, 291, 293]:
                        self.state = 1880
                        self.operand()
                        pass
                    elif token in [295]:
                        self.state = 1881
                        self.match(NaturalParser.WS)
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 1884 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,319,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(NaturalParser.ADD, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_addOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddOperation" ):
                return visitor.visitAddOperation(self)
            else:
                return visitor.visitChildren(self)




    def addOperation(self):

        localctx = NaturalParser.AddOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_addOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1886
            self.match(NaturalParser.ADD)
            self.state = 1890
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,320,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1887
                    self.addContent() 
                self.state = 1892
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,320,self._ctx)

            self.state = 1894
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,321,self._ctx)
            if la_ == 1:
                self.state = 1893
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultiplyOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTIPLY(self):
            return self.getToken(NaturalParser.MULTIPLY, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_multiplyOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultiplyOperation" ):
                return visitor.visitMultiplyOperation(self)
            else:
                return visitor.visitChildren(self)




    def multiplyOperation(self):

        localctx = NaturalParser.MultiplyOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_multiplyOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1896
            self.match(NaturalParser.MULTIPLY)
            self.state = 1900
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,322,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1897
                    self.addContent() 
                self.state = 1902
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,322,self._ctx)

            self.state = 1904
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,323,self._ctx)
            if la_ == 1:
                self.state = 1903
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubtractOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBTRACT(self):
            return self.getToken(NaturalParser.SUBTRACT, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_subtractOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSubtractOperation" ):
                return visitor.visitSubtractOperation(self)
            else:
                return visitor.visitChildren(self)




    def subtractOperation(self):

        localctx = NaturalParser.SubtractOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_subtractOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1906
            self.match(NaturalParser.SUBTRACT)
            self.state = 1910
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,324,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1907
                    self.addContent() 
                self.state = 1912
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,324,self._ctx)

            self.state = 1914
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,325,self._ctx)
            if la_ == 1:
                self.state = 1913
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DivideOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIVIDE(self):
            return self.getToken(NaturalParser.DIVIDE, 0)

        def addContent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.AddContentContext)
            else:
                return self.getTypedRuleContext(NaturalParser.AddContentContext,i)


        def NL(self):
            return self.getToken(NaturalParser.NL, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_divideOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDivideOperation" ):
                return visitor.visitDivideOperation(self)
            else:
                return visitor.visitChildren(self)




    def divideOperation(self):

        localctx = NaturalParser.DivideOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_divideOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1916
            self.match(NaturalParser.DIVIDE)
            self.state = 1920
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,326,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1917
                    self.addContent() 
                self.state = 1922
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,326,self._ctx)

            self.state = 1924
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,327,self._ctx)
            if la_ == 1:
                self.state = 1923
                self.match(NaturalParser.NL)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComputeOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMPUTE(self):
            return self.getToken(NaturalParser.COMPUTE, 0)

        def variable(self):
            return self.getTypedRuleContext(NaturalParser.VariableContext,0)


        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_computeOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComputeOperation" ):
                return visitor.visitComputeOperation(self)
            else:
                return visitor.visitChildren(self)




    def computeOperation(self):

        localctx = NaturalParser.ComputeOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_computeOperation)
        self._la = 0 # Token type
        try:
            self.state = 1985
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,344,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1926
                self.match(NaturalParser.COMPUTE)
                self.state = 1928
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,328,self._ctx)
                if la_ == 1:
                    self.state = 1927
                    self.match(NaturalParser.WS)


                self.state = 1931
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==124:
                    self.state = 1930
                    self.match(NaturalParser.ROUNDED)


                self.state = 1934
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1933
                    self.match(NaturalParser.WS)


                self.state = 1936
                self.variable()
                self.state = 1938
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1937
                    self.match(NaturalParser.WS)


                self.state = 1941
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==273:
                    self.state = 1940
                    self.match(NaturalParser.COLON)


                self.state = 1943
                self.match(NaturalParser.EQ)
                self.state = 1945
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1944
                    self.match(NaturalParser.WS)


                self.state = 1947
                self.operand()
                self.state = 1949
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1948
                    self.match(NaturalParser.WS)


                self.state = 1951
                self.arithmaticOp()
                self.state = 1953
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1952
                    self.match(NaturalParser.WS)


                self.state = 1955
                self.operand()
                self.state = 1957
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,336,self._ctx)
                if la_ == 1:
                    self.state = 1956
                    self.match(NaturalParser.WS)


                self.state = 1960
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,337,self._ctx)
                if la_ == 1:
                    self.state = 1959
                    self.optionalCompute()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1962
                self.match(NaturalParser.COMPUTE)
                self.state = 1964
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,338,self._ctx)
                if la_ == 1:
                    self.state = 1963
                    self.match(NaturalParser.WS)


                self.state = 1967
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==124:
                    self.state = 1966
                    self.match(NaturalParser.ROUNDED)


                self.state = 1970
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1969
                    self.match(NaturalParser.WS)


                self.state = 1972
                self.variable()
                self.state = 1974
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1973
                    self.match(NaturalParser.WS)


                self.state = 1977
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==273:
                    self.state = 1976
                    self.match(NaturalParser.COLON)


                self.state = 1979
                self.match(NaturalParser.EQ)
                self.state = 1981
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==295:
                    self.state = 1980
                    self.match(NaturalParser.WS)


                self.state = 1983
                self.operand()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmaticOperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def operand(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(NaturalParser.OperandContext)
            else:
                return self.getTypedRuleContext(NaturalParser.OperandContext,i)


        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def COLON(self):
            return self.getToken(NaturalParser.COLON, 0)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_arithmaticOperation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmaticOperation" ):
                return visitor.visitArithmaticOperation(self)
            else:
                return visitor.visitChildren(self)




    def arithmaticOperation(self):

        localctx = NaturalParser.ArithmaticOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_arithmaticOperation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1987
            self.match(NaturalParser.IDENTIFIER)
            self.state = 1989
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1988
                self.match(NaturalParser.WS)


            self.state = 1992
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==273:
                self.state = 1991
                self.match(NaturalParser.COLON)


            self.state = 1994
            self.match(NaturalParser.EQ)
            self.state = 1996
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1995
                self.match(NaturalParser.WS)


            self.state = 1998
            self.operand()
            self.state = 2000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 1999
                self.match(NaturalParser.WS)


            self.state = 2002
            self.arithmaticOp()
            self.state = 2004
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 2003
                self.match(NaturalParser.WS)


            self.state = 2006
            self.operand()
            self.state = 2008
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,350,self._ctx)
            if la_ == 1:
                self.state = 2007
                self.match(NaturalParser.WS)


            self.state = 2011
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,351,self._ctx)
            if la_ == 1:
                self.state = 2010
                self.optionalCompute()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionalComputeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arithmaticOp(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOpContext,0)


        def operand(self):
            return self.getTypedRuleContext(NaturalParser.OperandContext,0)


        def WS(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.WS)
            else:
                return self.getToken(NaturalParser.WS, i)

        def optionalCompute(self):
            return self.getTypedRuleContext(NaturalParser.OptionalComputeContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_optionalCompute

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOptionalCompute" ):
                return visitor.visitOptionalCompute(self)
            else:
                return visitor.visitChildren(self)




    def optionalCompute(self):

        localctx = NaturalParser.OptionalComputeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_optionalCompute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2013
            self.arithmaticOp()
            self.state = 2015
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==295:
                self.state = 2014
                self.match(NaturalParser.WS)


            self.state = 2017
            self.operand()
            self.state = 2019
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,353,self._ctx)
            if la_ == 1:
                self.state = 2018
                self.match(NaturalParser.WS)


            self.state = 2022
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,354,self._ctx)
            if la_ == 1:
                self.state = 2021
                self.optionalCompute()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CalculationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def addOperation(self):
            return self.getTypedRuleContext(NaturalParser.AddOperationContext,0)


        def subtractOperation(self):
            return self.getTypedRuleContext(NaturalParser.SubtractOperationContext,0)


        def multiplyOperation(self):
            return self.getTypedRuleContext(NaturalParser.MultiplyOperationContext,0)


        def divideOperation(self):
            return self.getTypedRuleContext(NaturalParser.DivideOperationContext,0)


        def computeOperation(self):
            return self.getTypedRuleContext(NaturalParser.ComputeOperationContext,0)


        def arithmaticOperation(self):
            return self.getTypedRuleContext(NaturalParser.ArithmaticOperationContext,0)


        def getRuleIndex(self):
            return NaturalParser.RULE_calculations

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCalculations" ):
                return visitor.visitCalculations(self)
            else:
                return visitor.visitChildren(self)




    def calculations(self):

        localctx = NaturalParser.CalculationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_calculations)
        try:
            self.state = 2030
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [43]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2024
                self.addOperation()
                pass
            elif token in [44]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2025
                self.subtractOperation()
                pass
            elif token in [45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2026
                self.multiplyOperation()
                pass
            elif token in [46]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2027
                self.divideOperation()
                pass
            elif token in [67]:
                self.enterOuterAlt(localctx, 5)
                self.state = 2028
                self.computeOperation()
                pass
            elif token in [293]:
                self.enterOuterAlt(localctx, 6)
                self.state = 2029
                self.arithmaticOperation()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AddContentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(NaturalParser.IDENTIFIER, 0)

        def LITERAL(self):
            return self.getToken(NaturalParser.LITERAL, 0)

        def FLOAT(self):
            return self.getToken(NaturalParser.FLOAT, 0)

        def LINE_NUMBER(self):
            return self.getToken(NaturalParser.LINE_NUMBER, 0)

        def TO(self):
            return self.getToken(NaturalParser.TO, 0)

        def GIVING(self):
            return self.getToken(NaturalParser.GIVING, 0)

        def ROUNDED(self):
            return self.getToken(NaturalParser.ROUNDED, 0)

        def WS(self):
            return self.getToken(NaturalParser.WS, 0)

        def STRING(self):
            return self.getToken(NaturalParser.STRING, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_addContent

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddContent" ):
                return visitor.visitAddContent(self)
            else:
                return visitor.visitChildren(self)




    def addContent(self):

        localctx = NaturalParser.AddContentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_addContent)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2032
            _la = self._input.LA(1)
            if not(_la==49 or _la==96 or _la==124 or ((((_la - 272)) & ~0x3f) == 0 and ((1 << (_la - 272)) & 10485789) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GT_TEXT(self):
            return self.getToken(NaturalParser.GT_TEXT, 0)

        def LT_TEXT(self):
            return self.getToken(NaturalParser.LT_TEXT, 0)

        def GE_TEXT(self):
            return self.getToken(NaturalParser.GE_TEXT, 0)

        def LE_TEXT(self):
            return self.getToken(NaturalParser.LE_TEXT, 0)

        def EQ_TEXT(self):
            return self.getToken(NaturalParser.EQ_TEXT, 0)

        def NE_TEXT(self):
            return self.getToken(NaturalParser.NE_TEXT, 0)

        def GT(self):
            return self.getToken(NaturalParser.GT, 0)

        def LT(self):
            return self.getToken(NaturalParser.LT, 0)

        def GE(self):
            return self.getToken(NaturalParser.GE, 0)

        def LE(self):
            return self.getToken(NaturalParser.LE, 0)

        def EQ(self):
            return self.getToken(NaturalParser.EQ, 0)

        def NE(self):
            return self.getToken(NaturalParser.NE, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_compOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompOp" ):
                return visitor.visitCompOp(self)
            else:
                return visitor.visitChildren(self)




    def compOp(self):

        localctx = NaturalParser.CompOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_compOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2034
            _la = self._input.LA(1)
            if not(((((_la - 253)) & ~0x3f) == 0 and ((1 << (_la - 253)) & 270582939711) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArithmaticOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(NaturalParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(NaturalParser.MINUS, 0)

        def MULT(self):
            return self.getToken(NaturalParser.MULT, 0)

        def DIV(self):
            return self.getToken(NaturalParser.DIV, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_arithmaticOp

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArithmaticOp" ):
                return visitor.visitArithmaticOp(self)
            else:
                return visitor.visitChildren(self)




    def arithmaticOp(self):

        localctx = NaturalParser.ArithmaticOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_arithmaticOp)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2036
            _la = self._input.LA(1)
            if not(((((_la - 281)) & ~0x3f) == 0 and ((1 << (_la - 281)) & 15) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EndStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READ(self):
            return self.getToken(NaturalParser.READ, 0)

        def FIND(self):
            return self.getToken(NaturalParser.FIND, 0)

        def HISTOGRAM(self):
            return self.getToken(NaturalParser.HISTOGRAM, 0)

        def GET(self):
            return self.getToken(NaturalParser.GET, 0)

        def GET_SAME(self):
            return self.getToken(NaturalParser.GET_SAME, 0)

        def PASSW(self):
            return self.getToken(NaturalParser.PASSW, 0)

        def LIMIT(self):
            return self.getToken(NaturalParser.LIMIT, 0)

        def STORE(self):
            return self.getToken(NaturalParser.STORE, 0)

        def UPDATE(self):
            return self.getToken(NaturalParser.UPDATE, 0)

        def DELETE(self):
            return self.getToken(NaturalParser.DELETE, 0)

        def END_TRANSACTION(self):
            return self.getToken(NaturalParser.END_TRANSACTION, 0)

        def BACKOUT_TRANSACTION(self):
            return self.getToken(NaturalParser.BACKOUT_TRANSACTION, 0)

        def GET_TRANSACTION_DATA(self):
            return self.getToken(NaturalParser.GET_TRANSACTION_DATA, 0)

        def RETRY(self):
            return self.getToken(NaturalParser.RETRY, 0)

        def AT_START_OF_DATA(self):
            return self.getToken(NaturalParser.AT_START_OF_DATA, 0)

        def AT_END_OF_DATA(self):
            return self.getToken(NaturalParser.AT_END_OF_DATA, 0)

        def AT_BREAK(self):
            return self.getToken(NaturalParser.AT_BREAK, 0)

        def BEFORE_BREAK_PROCESSING(self):
            return self.getToken(NaturalParser.BEFORE_BREAK_PROCESSING, 0)

        def PERFORM_BREAK_PROCESSING(self):
            return self.getToken(NaturalParser.PERFORM_BREAK_PROCESSING, 0)

        def CALLDBPROC(self):
            return self.getToken(NaturalParser.CALLDBPROC, 0)

        def COMMIT(self):
            return self.getToken(NaturalParser.COMMIT, 0)

        def INSERT(self):
            return self.getToken(NaturalParser.INSERT, 0)

        def PROCESS_SQL(self):
            return self.getToken(NaturalParser.PROCESS_SQL, 0)

        def READ_RESULT_SET(self):
            return self.getToken(NaturalParser.READ_RESULT_SET, 0)

        def ROLLBACK(self):
            return self.getToken(NaturalParser.ROLLBACK, 0)

        def SELECT(self):
            return self.getToken(NaturalParser.SELECT, 0)

        def COMPUTE(self):
            return self.getToken(NaturalParser.COMPUTE, 0)

        def ADD(self):
            return self.getToken(NaturalParser.ADD, 0)

        def SUBTRACT(self):
            return self.getToken(NaturalParser.SUBTRACT, 0)

        def MULTIPLY(self):
            return self.getToken(NaturalParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(NaturalParser.DIVIDE, 0)

        def MOVE(self):
            return self.getToken(NaturalParser.MOVE, 0)

        def COMPRESS(self):
            return self.getToken(NaturalParser.COMPRESS, 0)

        def SEPARATE(self):
            return self.getToken(NaturalParser.SEPARATE, 0)

        def EXAMINE(self):
            return self.getToken(NaturalParser.EXAMINE, 0)

        def RESET(self):
            return self.getToken(NaturalParser.RESET, 0)

        def ESCAPE(self):
            return self.getToken(NaturalParser.ESCAPE, 0)

        def FOR(self):
            return self.getToken(NaturalParser.FOR, 0)

        def REPEAT(self):
            return self.getToken(NaturalParser.REPEAT, 0)

        def SORT(self):
            return self.getToken(NaturalParser.SORT, 0)

        def FORMAT(self):
            return self.getToken(NaturalParser.FORMAT, 0)

        def DISPLAY(self):
            return self.getToken(NaturalParser.DISPLAY, 0)

        def WRITE(self):
            return self.getToken(NaturalParser.WRITE, 0)

        def WRITE_TITLE(self):
            return self.getToken(NaturalParser.WRITE_TITLE, 0)

        def WRITE_TRAILER(self):
            return self.getToken(NaturalParser.WRITE_TRAILER, 0)

        def AT_TOP_OF_PAGE(self):
            return self.getToken(NaturalParser.AT_TOP_OF_PAGE, 0)

        def AT_END_OF_PAGE(self):
            return self.getToken(NaturalParser.AT_END_OF_PAGE, 0)

        def EJECT(self):
            return self.getToken(NaturalParser.EJECT, 0)

        def NEWPAGE(self):
            return self.getToken(NaturalParser.NEWPAGE, 0)

        def SUSPEND_IDENTICAL_SUPPRESS(self):
            return self.getToken(NaturalParser.SUSPEND_IDENTICAL_SUPPRESS, 0)

        def DEFINE_PRINTER(self):
            return self.getToken(NaturalParser.DEFINE_PRINTER, 0)

        def CLOSE_PRINTER(self):
            return self.getToken(NaturalParser.CLOSE_PRINTER, 0)

        def INPUT(self):
            return self.getToken(NaturalParser.INPUT, 0)

        def REINPUT(self):
            return self.getToken(NaturalParser.REINPUT, 0)

        def DEFINE_WINDOW(self):
            return self.getToken(NaturalParser.DEFINE_WINDOW, 0)

        def SET_WINDOW(self):
            return self.getToken(NaturalParser.SET_WINDOW, 0)

        def PROCESS_PAGE(self):
            return self.getToken(NaturalParser.PROCESS_PAGE, 0)

        def PROCESS_PAGE_USING(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_USING, 0)

        def PROCESS_PAGE_UPDATE(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_UPDATE, 0)

        def PROCESS_PAGE_MODAL(self):
            return self.getToken(NaturalParser.PROCESS_PAGE_MODAL, 0)

        def IF(self):
            return self.getToken(NaturalParser.IF, 0)

        def IF_SELECTION(self):
            return self.getToken(NaturalParser.IF_SELECTION, 0)

        def DECIDE_FOR(self):
            return self.getToken(NaturalParser.DECIDE_FOR, 0)

        def DECIDE_ON(self):
            return self.getToken(NaturalParser.DECIDE_ON, 0)

        def CALL(self):
            return self.getToken(NaturalParser.CALL, 0)

        def CALLNAT(self):
            return self.getToken(NaturalParser.CALLNAT, 0)

        def CALL_FILE(self):
            return self.getToken(NaturalParser.CALL_FILE, 0)

        def CALL_LOOP(self):
            return self.getToken(NaturalParser.CALL_LOOP, 0)

        def DEFINE_SUBROUTINE(self):
            return self.getToken(NaturalParser.DEFINE_SUBROUTINE, 0)

        def FETCH(self):
            return self.getToken(NaturalParser.FETCH, 0)

        def PERFORM(self):
            return self.getToken(NaturalParser.PERFORM, 0)

        def PROCESS_COMMAND(self):
            return self.getToken(NaturalParser.PROCESS_COMMAND, 0)

        def RUN(self):
            return self.getToken(NaturalParser.RUN, 0)

        def DEFINE_FUNCTION(self):
            return self.getToken(NaturalParser.DEFINE_FUNCTION, 0)

        def DEFINE_PROTOTYPE(self):
            return self.getToken(NaturalParser.DEFINE_PROTOTYPE, 0)

        def FUNCTION_CALL(self):
            return self.getToken(NaturalParser.FUNCTION_CALL, 0)

        def STOP(self):
            return self.getToken(NaturalParser.STOP, 0)

        def TERMINATE(self):
            return self.getToken(NaturalParser.TERMINATE, 0)

        def WRITE_WORK_FILE(self):
            return self.getToken(NaturalParser.WRITE_WORK_FILE, 0)

        def DOWNLOAD_PC_FILE(self):
            return self.getToken(NaturalParser.DOWNLOAD_PC_FILE, 0)

        def READ_WORK_FILE(self):
            return self.getToken(NaturalParser.READ_WORK_FILE, 0)

        def UPLOAD_PC_FILE(self):
            return self.getToken(NaturalParser.UPLOAD_PC_FILE, 0)

        def CLOSE_WORK_FILE(self):
            return self.getToken(NaturalParser.CLOSE_WORK_FILE, 0)

        def CLOSE_PC_FILE(self):
            return self.getToken(NaturalParser.CLOSE_PC_FILE, 0)

        def DEFINE_WORK_FILE(self):
            return self.getToken(NaturalParser.DEFINE_WORK_FILE, 0)

        def DEFINE_CLASS(self):
            return self.getToken(NaturalParser.DEFINE_CLASS, 0)

        def CREATE_OBJECT(self):
            return self.getToken(NaturalParser.CREATE_OBJECT, 0)

        def SEND_METHOD(self):
            return self.getToken(NaturalParser.SEND_METHOD, 0)

        def INTERFACE(self):
            return self.getToken(NaturalParser.INTERFACE, 0)

        def METHOD(self):
            return self.getToken(NaturalParser.METHOD, 0)

        def PROPERTY(self):
            return self.getToken(NaturalParser.PROPERTY, 0)

        def EXPAND(self):
            return self.getToken(NaturalParser.EXPAND, 0)

        def REDUCE(self):
            return self.getToken(NaturalParser.REDUCE, 0)

        def RESIZE(self):
            return self.getToken(NaturalParser.RESIZE, 0)

        def OPEN_CONVERSATION(self):
            return self.getToken(NaturalParser.OPEN_CONVERSATION, 0)

        def CLOSE_CONVERSATION(self):
            return self.getToken(NaturalParser.CLOSE_CONVERSATION, 0)

        def DEFINE_DATA_CONTEXT(self):
            return self.getToken(NaturalParser.DEFINE_DATA_CONTEXT, 0)

        def PARSE(self):
            return self.getToken(NaturalParser.PARSE, 0)

        def REQUEST_DOCUMENT(self):
            return self.getToken(NaturalParser.REQUEST_DOCUMENT, 0)

        def DEFINE_DATA(self):
            return self.getToken(NaturalParser.DEFINE_DATA, 0)

        def END(self):
            return self.getToken(NaturalParser.END, 0)

        def INCLUDE(self):
            return self.getToken(NaturalParser.INCLUDE, 0)

        def ON_ERROR(self):
            return self.getToken(NaturalParser.ON_ERROR, 0)

        def RELEASE(self):
            return self.getToken(NaturalParser.RELEASE, 0)

        def SET_CONTROL(self):
            return self.getToken(NaturalParser.SET_CONTROL, 0)

        def SET_KEY(self):
            return self.getToken(NaturalParser.SET_KEY, 0)

        def SET_GLOBALS(self):
            return self.getToken(NaturalParser.SET_GLOBALS, 0)

        def SET_TIME(self):
            return self.getToken(NaturalParser.SET_TIME, 0)

        def STACK(self):
            return self.getToken(NaturalParser.STACK, 0)

        def LOOP(self):
            return self.getToken(NaturalParser.LOOP, 0)

        def DO(self):
            return self.getToken(NaturalParser.DO, 0)

        def DOEND(self):
            return self.getToken(NaturalParser.DOEND, 0)

        def OBTAIN(self):
            return self.getToken(NaturalParser.OBTAIN, 0)

        def REDEFINE(self):
            return self.getToken(NaturalParser.REDEFINE, 0)

        def END_START(self):
            return self.getToken(NaturalParser.END_START, 0)

        def getRuleIndex(self):
            return NaturalParser.RULE_endStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndStatement" ):
                return visitor.visitEndStatement(self)
            else:
                return visitor.visitChildren(self)




    def endStatement(self):

        localctx = NaturalParser.EndStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_endStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2038
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 3498452474803539712) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 6919640090553618905) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & -2305843019011588099) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & 33585661) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OtherStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.IF)
            else:
                return self.getToken(NaturalParser.IF, i)

        def ELSE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.ELSE)
            else:
                return self.getToken(NaturalParser.ELSE, i)

        def DECIDE_FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DECIDE_FOR)
            else:
                return self.getToken(NaturalParser.DECIDE_FOR, i)

        def DECIDE_ON(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DECIDE_ON)
            else:
                return self.getToken(NaturalParser.DECIDE_ON, i)

        def DEFINE_SUBROUTINE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DEFINE_SUBROUTINE)
            else:
                return self.getToken(NaturalParser.DEFINE_SUBROUTINE, i)

        def DEFINE_FUNCTION(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DEFINE_FUNCTION)
            else:
                return self.getToken(NaturalParser.DEFINE_FUNCTION, i)

        def RETURN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RETURN)
            else:
                return self.getToken(NaturalParser.RETURN, i)

        def VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.VALUE)
            else:
                return self.getToken(NaturalParser.VALUE, i)

        def CALLNAT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.CALLNAT)
            else:
                return self.getToken(NaturalParser.CALLNAT, i)

        def PERFORM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.PERFORM)
            else:
                return self.getToken(NaturalParser.PERFORM, i)

        def FIND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FIND)
            else:
                return self.getToken(NaturalParser.FIND, i)

        def STORE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.STORE)
            else:
                return self.getToken(NaturalParser.STORE, i)

        def INPUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.INPUT)
            else:
                return self.getToken(NaturalParser.INPUT, i)

        def REINPUT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.REINPUT)
            else:
                return self.getToken(NaturalParser.REINPUT, i)

        def DOEND(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DOEND)
            else:
                return self.getToken(NaturalParser.DOEND, i)

        def END_IF(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_IF)
            else:
                return self.getToken(NaturalParser.END_IF, i)

        def END_FOR(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_FOR)
            else:
                return self.getToken(NaturalParser.END_FOR, i)

        def LOOP(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.LOOP)
            else:
                return self.getToken(NaturalParser.LOOP, i)

        def DO(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.DO)
            else:
                return self.getToken(NaturalParser.DO, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.THEN)
            else:
                return self.getToken(NaturalParser.THEN, i)

        def RESET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.RESET)
            else:
                return self.getToken(NaturalParser.RESET, i)

        def REDEFINE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.REDEFINE)
            else:
                return self.getToken(NaturalParser.REDEFINE, i)

        def GET(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.GET)
            else:
                return self.getToken(NaturalParser.GET, i)

        def UPDATE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.UPDATE)
            else:
                return self.getToken(NaturalParser.UPDATE, i)

        def READ(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.READ)
            else:
                return self.getToken(NaturalParser.READ, i)

        def MOVE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.MOVE)
            else:
                return self.getToken(NaturalParser.MOVE, i)

        def AT_START_OF_DATA(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.AT_START_OF_DATA)
            else:
                return self.getToken(NaturalParser.AT_START_OF_DATA, i)

        def FORMAT(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.FORMAT)
            else:
                return self.getToken(NaturalParser.FORMAT, i)

        def INCLUDE(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.INCLUDE)
            else:
                return self.getToken(NaturalParser.INCLUDE, i)

        def HISTOGRAM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.HISTOGRAM)
            else:
                return self.getToken(NaturalParser.HISTOGRAM, i)

        def END_HISTOGRAM(self, i:int=None):
            if i is None:
                return self.getTokens(NaturalParser.END_HISTOGRAM)
            else:
                return self.getToken(NaturalParser.END_HISTOGRAM, i)

        def getRuleIndex(self):
            return NaturalParser.RULE_otherStatement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOtherStatement" ):
                return visitor.visitOtherStatement(self)
            else:
                return visitor.visitChildren(self)




    def otherStatement(self):

        localctx = NaturalParser.OtherStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_otherStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2041 
            self._errHandler.sync(self)
            _alt = 1+1
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1+1:
                    self.state = 2040
                    _la = self._input.LA(1)
                    if _la <= 0 or (((_la) & ~0x3f) == 0 and ((1 << _la) & -9183821663005448448) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 4177) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & 2251799813734401) != 0) or ((((_la - 194)) & ~0x3f) == 0 and ((1 << (_la - 194)) & 12289) != 0):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 2043 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,356,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





